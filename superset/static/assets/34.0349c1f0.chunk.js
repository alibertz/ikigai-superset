(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[34],{

/***/ "./node_modules/@superset-ui/plugin-chart-pivot-table/esm/PivotTableChart.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@superset-ui/plugin-chart-pivot-table/esm/PivotTableChart.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PivotTableChart; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ant-design/icons */ \"./node_modules/@ant-design/icons/es/icons/PlusSquareOutlined.js\");\n/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ant-design/icons */ \"./node_modules/@ant-design/icons/es/icons/MinusSquareOutlined.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@superset-ui/core/esm/style/index.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@superset-ui/core/esm/number-format/NumberFormatterRegistrySingleton.js\");\n/* harmony import */ var _superset_ui_react_pivottable_PivotTable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @superset-ui/react-pivottable/PivotTable */ \"./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/PivotTable.js\");\n/* harmony import */ var _superset_ui_react_pivottable_PivotTable__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_superset_ui_react_pivottable_PivotTable__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @superset-ui/react-pivottable/Utilities */ \"./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/Utilities.js\");\n/* harmony import */ var _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _superset_ui_react_pivottable_pivottable_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @superset-ui/react-pivottable/pivottable.css */ \"./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/pivottable.css\");\n/* harmony import */ var _superset_ui_react_pivottable_pivottable_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_superset_ui_react_pivottable_pivottable_css__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./types */ \"./node_modules/@superset-ui/plugin-chart-pivot-table/esm/types.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n // @ts-ignore\n\n // @ts-ignore\n\n\n\n\n\nconst Styles = _superset_ui_core__WEBPACK_IMPORTED_MODULE_3__[\"styled\"].div`\n  ${({\n  height,\n  width,\n  margin\n}) => `\n      margin: ${margin}px;\n      height: ${height - margin * 2}px;\n      width: ${width - margin * 2}px;\n `}\n`;\nconst PivotTableWrapper = _superset_ui_core__WEBPACK_IMPORTED_MODULE_3__[\"styled\"].div`\n  height: 100%;\n  max-width: fit-content;\n  overflow: auto;\n`;\nconst METRIC_KEY = 'metric';\nconst iconStyle = {\n  stroke: 'black',\n  strokeWidth: '16px'\n};\n\nconst aggregatorsFactory = formatter => ({\n  Count: _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].count(formatter),\n  'Count Unique Values': _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].countUnique(formatter),\n  'List Unique Values': _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].listUnique(', ', formatter),\n  Sum: _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].sum(formatter),\n  Average: _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].average(formatter),\n  Median: _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].median(formatter),\n  'Sample Variance': _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].var(1, formatter),\n  'Sample Standard Deviation': _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].stdev(1, formatter),\n  Minimum: _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].min(formatter),\n  Maximum: _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].max(formatter),\n  First: _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].first(formatter),\n  Last: _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].last(formatter),\n  'Sum as Fraction of Total': _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].fractionOf(_superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].sum(), 'total', formatter),\n  'Sum as Fraction of Rows': _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].fractionOf(_superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].sum(), 'row', formatter),\n  'Sum as Fraction of Columns': _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].fractionOf(_superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].sum(), 'col', formatter),\n  'Count as Fraction of Total': _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].fractionOf(_superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].count(), 'total', formatter),\n  'Count as Fraction of Rows': _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].fractionOf(_superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].count(), 'row', formatter),\n  'Count as Fraction of Columns': _superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].fractionOf(_superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"aggregatorTemplates\"].count(), 'col', formatter)\n});\n/* If you change this logic, please update the corresponding Python\n * function (https://github.com/apache/superset/blob/master/superset/charts/post_processing.py),\n * or reach out to @betodealmeida.\n */\n\n\nfunction PivotTableChart(props) {\n  const {\n    data,\n    height,\n    width,\n    groupbyRows,\n    groupbyColumns,\n    metrics,\n    colOrder,\n    rowOrder,\n    aggregateFunction,\n    transposePivot,\n    combineMetric,\n    rowSubtotalPosition,\n    colSubtotalPosition,\n    colTotals,\n    rowTotals,\n    valueFormat,\n    emitFilter,\n    setDataMask,\n    selectedFilters,\n    verboseMap,\n    columnFormats,\n    metricsLayout,\n    metricColorFormatters,\n    dateFormatters\n  } = props;\n  const theme = Object(_superset_ui_core__WEBPACK_IMPORTED_MODULE_3__[\"useTheme\"])();\n  const defaultFormatter = Object(_superset_ui_core__WEBPACK_IMPORTED_MODULE_4__[\"getNumberFormatter\"])(valueFormat);\n  const columnFormatsArray = Object.entries(columnFormats);\n  const hasCustomMetricFormatters = columnFormatsArray.length > 0;\n  const metricFormatters = hasCustomMetricFormatters && Object.fromEntries(columnFormatsArray.map(([metric, format]) => [metric, Object(_superset_ui_core__WEBPACK_IMPORTED_MODULE_4__[\"getNumberFormatter\"])(format)]));\n  const metricNames = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(() => metrics.map(metric => typeof metric === 'string' ? metric : metric.label), [metrics]);\n  const unpivotedData = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"])(() => data.reduce((acc, record) => [...acc, ...metricNames.map(name => ({ ...record,\n    [METRIC_KEY]: name,\n    value: record[name]\n  })).filter(record => record.value !== null)], []), [data, metricNames]);\n  let [rows, cols] = transposePivot ? [groupbyColumns, groupbyRows] : [groupbyRows, groupbyColumns];\n\n  if (metricsLayout === _types__WEBPACK_IMPORTED_MODULE_8__[\"MetricsLayoutEnum\"].ROWS) {\n    rows = combineMetric ? [...rows, METRIC_KEY] : [METRIC_KEY, ...rows];\n  } else {\n    cols = combineMetric ? [...cols, METRIC_KEY] : [METRIC_KEY, ...cols];\n  }\n\n  const handleChange = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(filters => {\n    const groupBy = Object.keys(filters);\n    setDataMask({\n      extraFormData: {\n        filters: groupBy.length === 0 ? undefined : groupBy.map(col => {\n          const val = filters == null ? void 0 : filters[col];\n          if (val === null || val === undefined) return {\n            col,\n            op: 'IS NULL'\n          };\n          return {\n            col,\n            op: 'IN',\n            val: val\n          };\n        })\n      },\n      filterState: {\n        value: filters && Object.keys(filters).length ? Object.values(filters) : null,\n        selectedFilters: filters && Object.keys(filters).length ? filters : null\n      }\n    });\n  }, [setDataMask]);\n  const toggleFilter = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((e, value, filters, pivotData, isSubtotal, isGrandTotal) => {\n    if (isSubtotal || isGrandTotal || !emitFilter) {\n      return;\n    }\n\n    const isActiveFilterValue = (key, val) => {\n      var _selectedFilters$key;\n\n      return !!selectedFilters && ((_selectedFilters$key = selectedFilters[key]) == null ? void 0 : _selectedFilters$key.includes(val));\n    };\n\n    const filtersCopy = { ...filters\n    };\n    delete filtersCopy[METRIC_KEY];\n    const filtersEntries = Object.entries(filtersCopy);\n\n    if (filtersEntries.length === 0) {\n      return;\n    }\n\n    const [key, val] = filtersEntries[filtersEntries.length - 1];\n    let updatedFilters = { ...(selectedFilters || {})\n    }; // multi select\n    // if (selectedFilters && isActiveFilterValue(key, val)) {\n    //   updatedFilters[key] = selectedFilters[key].filter((x: DataRecordValue) => x !== val);\n    // } else {\n    //   updatedFilters[key] = [...(selectedFilters?.[key] || []), val];\n    // }\n    // single select\n\n    if (selectedFilters && isActiveFilterValue(key, val)) {\n      updatedFilters = {};\n    } else {\n      updatedFilters = {\n        [key]: [val]\n      };\n    }\n\n    if (Array.isArray(updatedFilters[key]) && updatedFilters[key].length === 0) {\n      delete updatedFilters[key];\n    }\n\n    handleChange(updatedFilters);\n  }, [emitFilter, selectedFilters, handleChange]);\n  return Object(_emotion_react__WEBPACK_IMPORTED_MODULE_9__[\"jsx\"])(Styles, {\n    height: height,\n    width: width,\n    margin: theme.gridUnit * 4\n  }, Object(_emotion_react__WEBPACK_IMPORTED_MODULE_9__[\"jsx\"])(PivotTableWrapper, null, Object(_emotion_react__WEBPACK_IMPORTED_MODULE_9__[\"jsx\"])(_superset_ui_react_pivottable_PivotTable__WEBPACK_IMPORTED_MODULE_5___default.a, {\n    data: unpivotedData,\n    rows: rows,\n    cols: cols,\n    aggregatorsFactory: aggregatorsFactory,\n    defaultFormatter: defaultFormatter,\n    customFormatters: hasCustomMetricFormatters ? {\n      [METRIC_KEY]: metricFormatters\n    } : undefined,\n    aggregatorName: aggregateFunction,\n    vals: ['value'],\n    rendererName: \"Table With Subtotal\",\n    colOrder: colOrder,\n    rowOrder: rowOrder,\n    sorters: {\n      metric: Object(_superset_ui_react_pivottable_Utilities__WEBPACK_IMPORTED_MODULE_6__[\"sortAs\"])(metricNames)\n    },\n    tableOptions: {\n      clickRowHeaderCallback: toggleFilter,\n      clickColumnHeaderCallback: toggleFilter,\n      colTotals,\n      rowTotals,\n      highlightHeaderCellsOnHover: emitFilter,\n      highlightedHeaderCells: selectedFilters,\n      omittedHighlightHeaderGroups: [METRIC_KEY],\n      cellColorFormatters: {\n        [METRIC_KEY]: metricColorFormatters\n      },\n      dateFormatters\n    },\n    subtotalOptions: {\n      colSubtotalDisplay: {\n        displayOnTop: colSubtotalPosition\n      },\n      rowSubtotalDisplay: {\n        displayOnTop: rowSubtotalPosition\n      },\n      arrowCollapsed: Object(_emotion_react__WEBPACK_IMPORTED_MODULE_9__[\"jsx\"])(_ant_design_icons__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n        style: iconStyle\n      }),\n      arrowExpanded: Object(_emotion_react__WEBPACK_IMPORTED_MODULE_9__[\"jsx\"])(_ant_design_icons__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        style: iconStyle\n      })\n    },\n    namesMapping: verboseMap\n  })));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9lc20vUGl2b3RUYWJsZUNoYXJ0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcnNldC11aS9wbHVnaW4tY2hhcnQtcGl2b3QtdGFibGUvZXNtL1Bpdm90VGFibGVDaGFydC5qcz8wNzFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFBsdXNTcXVhcmVPdXRsaW5lZCwgTWludXNTcXVhcmVPdXRsaW5lZCB9IGZyb20gJ0BhbnQtZGVzaWduL2ljb25zJztcbmltcG9ydCB7IHN0eWxlZCwgZ2V0TnVtYmVyRm9ybWF0dGVyLCB1c2VUaGVtZSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJzsgLy8gQHRzLWlnbm9yZVxuXG5pbXBvcnQgUGl2b3RUYWJsZSBmcm9tICdAc3VwZXJzZXQtdWkvcmVhY3QtcGl2b3R0YWJsZS9QaXZvdFRhYmxlJzsgLy8gQHRzLWlnbm9yZVxuXG5pbXBvcnQgeyBzb3J0QXMsIGFnZ3JlZ2F0b3JUZW1wbGF0ZXMgfSBmcm9tICdAc3VwZXJzZXQtdWkvcmVhY3QtcGl2b3R0YWJsZS9VdGlsaXRpZXMnO1xuaW1wb3J0ICdAc3VwZXJzZXQtdWkvcmVhY3QtcGl2b3R0YWJsZS9waXZvdHRhYmxlLmNzcyc7XG5pbXBvcnQgeyBNZXRyaWNzTGF5b3V0RW51bSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsganN4IGFzIF9fX0Vtb3Rpb25KU1ggfSBmcm9tIFwiQGVtb3Rpb24vcmVhY3RcIjtcbmNvbnN0IFN0eWxlcyA9IHN0eWxlZC5kaXZgXG4gICR7KHtcbiAgaGVpZ2h0LFxuICB3aWR0aCxcbiAgbWFyZ2luXG59KSA9PiBgXG4gICAgICBtYXJnaW46ICR7bWFyZ2lufXB4O1xuICAgICAgaGVpZ2h0OiAke2hlaWdodCAtIG1hcmdpbiAqIDJ9cHg7XG4gICAgICB3aWR0aDogJHt3aWR0aCAtIG1hcmdpbiAqIDJ9cHg7XG4gYH1cbmA7XG5jb25zdCBQaXZvdFRhYmxlV3JhcHBlciA9IHN0eWxlZC5kaXZgXG4gIGhlaWdodDogMTAwJTtcbiAgbWF4LXdpZHRoOiBmaXQtY29udGVudDtcbiAgb3ZlcmZsb3c6IGF1dG87XG5gO1xuY29uc3QgTUVUUklDX0tFWSA9ICdtZXRyaWMnO1xuY29uc3QgaWNvblN0eWxlID0ge1xuICBzdHJva2U6ICdibGFjaycsXG4gIHN0cm9rZVdpZHRoOiAnMTZweCdcbn07XG5cbmNvbnN0IGFnZ3JlZ2F0b3JzRmFjdG9yeSA9IGZvcm1hdHRlciA9PiAoe1xuICBDb3VudDogYWdncmVnYXRvclRlbXBsYXRlcy5jb3VudChmb3JtYXR0ZXIpLFxuICAnQ291bnQgVW5pcXVlIFZhbHVlcyc6IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuY291bnRVbmlxdWUoZm9ybWF0dGVyKSxcbiAgJ0xpc3QgVW5pcXVlIFZhbHVlcyc6IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMubGlzdFVuaXF1ZSgnLCAnLCBmb3JtYXR0ZXIpLFxuICBTdW06IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuc3VtKGZvcm1hdHRlciksXG4gIEF2ZXJhZ2U6IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuYXZlcmFnZShmb3JtYXR0ZXIpLFxuICBNZWRpYW46IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMubWVkaWFuKGZvcm1hdHRlciksXG4gICdTYW1wbGUgVmFyaWFuY2UnOiBhZ2dyZWdhdG9yVGVtcGxhdGVzLnZhcigxLCBmb3JtYXR0ZXIpLFxuICAnU2FtcGxlIFN0YW5kYXJkIERldmlhdGlvbic6IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuc3RkZXYoMSwgZm9ybWF0dGVyKSxcbiAgTWluaW11bTogYWdncmVnYXRvclRlbXBsYXRlcy5taW4oZm9ybWF0dGVyKSxcbiAgTWF4aW11bTogYWdncmVnYXRvclRlbXBsYXRlcy5tYXgoZm9ybWF0dGVyKSxcbiAgRmlyc3Q6IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuZmlyc3QoZm9ybWF0dGVyKSxcbiAgTGFzdDogYWdncmVnYXRvclRlbXBsYXRlcy5sYXN0KGZvcm1hdHRlciksXG4gICdTdW0gYXMgRnJhY3Rpb24gb2YgVG90YWwnOiBhZ2dyZWdhdG9yVGVtcGxhdGVzLmZyYWN0aW9uT2YoYWdncmVnYXRvclRlbXBsYXRlcy5zdW0oKSwgJ3RvdGFsJywgZm9ybWF0dGVyKSxcbiAgJ1N1bSBhcyBGcmFjdGlvbiBvZiBSb3dzJzogYWdncmVnYXRvclRlbXBsYXRlcy5mcmFjdGlvbk9mKGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuc3VtKCksICdyb3cnLCBmb3JtYXR0ZXIpLFxuICAnU3VtIGFzIEZyYWN0aW9uIG9mIENvbHVtbnMnOiBhZ2dyZWdhdG9yVGVtcGxhdGVzLmZyYWN0aW9uT2YoYWdncmVnYXRvclRlbXBsYXRlcy5zdW0oKSwgJ2NvbCcsIGZvcm1hdHRlciksXG4gICdDb3VudCBhcyBGcmFjdGlvbiBvZiBUb3RhbCc6IGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuZnJhY3Rpb25PZihhZ2dyZWdhdG9yVGVtcGxhdGVzLmNvdW50KCksICd0b3RhbCcsIGZvcm1hdHRlciksXG4gICdDb3VudCBhcyBGcmFjdGlvbiBvZiBSb3dzJzogYWdncmVnYXRvclRlbXBsYXRlcy5mcmFjdGlvbk9mKGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuY291bnQoKSwgJ3JvdycsIGZvcm1hdHRlciksXG4gICdDb3VudCBhcyBGcmFjdGlvbiBvZiBDb2x1bW5zJzogYWdncmVnYXRvclRlbXBsYXRlcy5mcmFjdGlvbk9mKGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuY291bnQoKSwgJ2NvbCcsIGZvcm1hdHRlcilcbn0pO1xuLyogSWYgeW91IGNoYW5nZSB0aGlzIGxvZ2ljLCBwbGVhc2UgdXBkYXRlIHRoZSBjb3JyZXNwb25kaW5nIFB5dGhvblxuICogZnVuY3Rpb24gKGh0dHBzOi8vZ2l0aHViLmNvbS9hcGFjaGUvc3VwZXJzZXQvYmxvYi9tYXN0ZXIvc3VwZXJzZXQvY2hhcnRzL3Bvc3RfcHJvY2Vzc2luZy5weSksXG4gKiBvciByZWFjaCBvdXQgdG8gQGJldG9kZWFsbWVpZGEuXG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQaXZvdFRhYmxlQ2hhcnQocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGRhdGEsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoLFxuICAgIGdyb3VwYnlSb3dzLFxuICAgIGdyb3VwYnlDb2x1bW5zLFxuICAgIG1ldHJpY3MsXG4gICAgY29sT3JkZXIsXG4gICAgcm93T3JkZXIsXG4gICAgYWdncmVnYXRlRnVuY3Rpb24sXG4gICAgdHJhbnNwb3NlUGl2b3QsXG4gICAgY29tYmluZU1ldHJpYyxcbiAgICByb3dTdWJ0b3RhbFBvc2l0aW9uLFxuICAgIGNvbFN1YnRvdGFsUG9zaXRpb24sXG4gICAgY29sVG90YWxzLFxuICAgIHJvd1RvdGFscyxcbiAgICB2YWx1ZUZvcm1hdCxcbiAgICBlbWl0RmlsdGVyLFxuICAgIHNldERhdGFNYXNrLFxuICAgIHNlbGVjdGVkRmlsdGVycyxcbiAgICB2ZXJib3NlTWFwLFxuICAgIGNvbHVtbkZvcm1hdHMsXG4gICAgbWV0cmljc0xheW91dCxcbiAgICBtZXRyaWNDb2xvckZvcm1hdHRlcnMsXG4gICAgZGF0ZUZvcm1hdHRlcnNcbiAgfSA9IHByb3BzO1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGRlZmF1bHRGb3JtYXR0ZXIgPSBnZXROdW1iZXJGb3JtYXR0ZXIodmFsdWVGb3JtYXQpO1xuICBjb25zdCBjb2x1bW5Gb3JtYXRzQXJyYXkgPSBPYmplY3QuZW50cmllcyhjb2x1bW5Gb3JtYXRzKTtcbiAgY29uc3QgaGFzQ3VzdG9tTWV0cmljRm9ybWF0dGVycyA9IGNvbHVtbkZvcm1hdHNBcnJheS5sZW5ndGggPiAwO1xuICBjb25zdCBtZXRyaWNGb3JtYXR0ZXJzID0gaGFzQ3VzdG9tTWV0cmljRm9ybWF0dGVycyAmJiBPYmplY3QuZnJvbUVudHJpZXMoY29sdW1uRm9ybWF0c0FycmF5Lm1hcCgoW21ldHJpYywgZm9ybWF0XSkgPT4gW21ldHJpYywgZ2V0TnVtYmVyRm9ybWF0dGVyKGZvcm1hdCldKSk7XG4gIGNvbnN0IG1ldHJpY05hbWVzID0gdXNlTWVtbygoKSA9PiBtZXRyaWNzLm1hcChtZXRyaWMgPT4gdHlwZW9mIG1ldHJpYyA9PT0gJ3N0cmluZycgPyBtZXRyaWMgOiBtZXRyaWMubGFiZWwpLCBbbWV0cmljc10pO1xuICBjb25zdCB1bnBpdm90ZWREYXRhID0gdXNlTWVtbygoKSA9PiBkYXRhLnJlZHVjZSgoYWNjLCByZWNvcmQpID0+IFsuLi5hY2MsIC4uLm1ldHJpY05hbWVzLm1hcChuYW1lID0+ICh7IC4uLnJlY29yZCxcbiAgICBbTUVUUklDX0tFWV06IG5hbWUsXG4gICAgdmFsdWU6IHJlY29yZFtuYW1lXVxuICB9KSkuZmlsdGVyKHJlY29yZCA9PiByZWNvcmQudmFsdWUgIT09IG51bGwpXSwgW10pLCBbZGF0YSwgbWV0cmljTmFtZXNdKTtcbiAgbGV0IFtyb3dzLCBjb2xzXSA9IHRyYW5zcG9zZVBpdm90ID8gW2dyb3VwYnlDb2x1bW5zLCBncm91cGJ5Um93c10gOiBbZ3JvdXBieVJvd3MsIGdyb3VwYnlDb2x1bW5zXTtcblxuICBpZiAobWV0cmljc0xheW91dCA9PT0gTWV0cmljc0xheW91dEVudW0uUk9XUykge1xuICAgIHJvd3MgPSBjb21iaW5lTWV0cmljID8gWy4uLnJvd3MsIE1FVFJJQ19LRVldIDogW01FVFJJQ19LRVksIC4uLnJvd3NdO1xuICB9IGVsc2Uge1xuICAgIGNvbHMgPSBjb21iaW5lTWV0cmljID8gWy4uLmNvbHMsIE1FVFJJQ19LRVldIDogW01FVFJJQ19LRVksIC4uLmNvbHNdO1xuICB9XG5cbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2soZmlsdGVycyA9PiB7XG4gICAgY29uc3QgZ3JvdXBCeSA9IE9iamVjdC5rZXlzKGZpbHRlcnMpO1xuICAgIHNldERhdGFNYXNrKHtcbiAgICAgIGV4dHJhRm9ybURhdGE6IHtcbiAgICAgICAgZmlsdGVyczogZ3JvdXBCeS5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBncm91cEJ5Lm1hcChjb2wgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IGZpbHRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGZpbHRlcnNbY29sXTtcbiAgICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4ge1xuICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgb3A6ICdJUyBOVUxMJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgIG9wOiAnSU4nLFxuICAgICAgICAgICAgdmFsOiB2YWxcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGZpbHRlclN0YXRlOiB7XG4gICAgICAgIHZhbHVlOiBmaWx0ZXJzICYmIE9iamVjdC5rZXlzKGZpbHRlcnMpLmxlbmd0aCA/IE9iamVjdC52YWx1ZXMoZmlsdGVycykgOiBudWxsLFxuICAgICAgICBzZWxlY3RlZEZpbHRlcnM6IGZpbHRlcnMgJiYgT2JqZWN0LmtleXMoZmlsdGVycykubGVuZ3RoID8gZmlsdGVycyA6IG51bGxcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3NldERhdGFNYXNrXSk7XG4gIGNvbnN0IHRvZ2dsZUZpbHRlciA9IHVzZUNhbGxiYWNrKChlLCB2YWx1ZSwgZmlsdGVycywgcGl2b3REYXRhLCBpc1N1YnRvdGFsLCBpc0dyYW5kVG90YWwpID0+IHtcbiAgICBpZiAoaXNTdWJ0b3RhbCB8fCBpc0dyYW5kVG90YWwgfHwgIWVtaXRGaWx0ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpc0FjdGl2ZUZpbHRlclZhbHVlID0gKGtleSwgdmFsKSA9PiB7XG4gICAgICB2YXIgX3NlbGVjdGVkRmlsdGVycyRrZXk7XG5cbiAgICAgIHJldHVybiAhIXNlbGVjdGVkRmlsdGVycyAmJiAoKF9zZWxlY3RlZEZpbHRlcnMka2V5ID0gc2VsZWN0ZWRGaWx0ZXJzW2tleV0pID09IG51bGwgPyB2b2lkIDAgOiBfc2VsZWN0ZWRGaWx0ZXJzJGtleS5pbmNsdWRlcyh2YWwpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlsdGVyc0NvcHkgPSB7IC4uLmZpbHRlcnNcbiAgICB9O1xuICAgIGRlbGV0ZSBmaWx0ZXJzQ29weVtNRVRSSUNfS0VZXTtcbiAgICBjb25zdCBmaWx0ZXJzRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGZpbHRlcnNDb3B5KTtcblxuICAgIGlmIChmaWx0ZXJzRW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBba2V5LCB2YWxdID0gZmlsdGVyc0VudHJpZXNbZmlsdGVyc0VudHJpZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IHVwZGF0ZWRGaWx0ZXJzID0geyAuLi4oc2VsZWN0ZWRGaWx0ZXJzIHx8IHt9KVxuICAgIH07IC8vIG11bHRpIHNlbGVjdFxuICAgIC8vIGlmIChzZWxlY3RlZEZpbHRlcnMgJiYgaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXksIHZhbCkpIHtcbiAgICAvLyAgIHVwZGF0ZWRGaWx0ZXJzW2tleV0gPSBzZWxlY3RlZEZpbHRlcnNba2V5XS5maWx0ZXIoKHg6IERhdGFSZWNvcmRWYWx1ZSkgPT4geCAhPT0gdmFsKTtcbiAgICAvLyB9IGVsc2Uge1xuICAgIC8vICAgdXBkYXRlZEZpbHRlcnNba2V5XSA9IFsuLi4oc2VsZWN0ZWRGaWx0ZXJzPy5ba2V5XSB8fCBbXSksIHZhbF07XG4gICAgLy8gfVxuICAgIC8vIHNpbmdsZSBzZWxlY3RcblxuICAgIGlmIChzZWxlY3RlZEZpbHRlcnMgJiYgaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXksIHZhbCkpIHtcbiAgICAgIHVwZGF0ZWRGaWx0ZXJzID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZWRGaWx0ZXJzID0ge1xuICAgICAgICBba2V5XTogW3ZhbF1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlZEZpbHRlcnNba2V5XSkgJiYgdXBkYXRlZEZpbHRlcnNba2V5XS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB1cGRhdGVkRmlsdGVyc1trZXldO1xuICAgIH1cblxuICAgIGhhbmRsZUNoYW5nZSh1cGRhdGVkRmlsdGVycyk7XG4gIH0sIFtlbWl0RmlsdGVyLCBzZWxlY3RlZEZpbHRlcnMsIGhhbmRsZUNoYW5nZV0pO1xuICByZXR1cm4gX19fRW1vdGlvbkpTWChTdHlsZXMsIHtcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgbWFyZ2luOiB0aGVtZS5ncmlkVW5pdCAqIDRcbiAgfSwgX19fRW1vdGlvbkpTWChQaXZvdFRhYmxlV3JhcHBlciwgbnVsbCwgX19fRW1vdGlvbkpTWChQaXZvdFRhYmxlLCB7XG4gICAgZGF0YTogdW5waXZvdGVkRGF0YSxcbiAgICByb3dzOiByb3dzLFxuICAgIGNvbHM6IGNvbHMsXG4gICAgYWdncmVnYXRvcnNGYWN0b3J5OiBhZ2dyZWdhdG9yc0ZhY3RvcnksXG4gICAgZGVmYXVsdEZvcm1hdHRlcjogZGVmYXVsdEZvcm1hdHRlcixcbiAgICBjdXN0b21Gb3JtYXR0ZXJzOiBoYXNDdXN0b21NZXRyaWNGb3JtYXR0ZXJzID8ge1xuICAgICAgW01FVFJJQ19LRVldOiBtZXRyaWNGb3JtYXR0ZXJzXG4gICAgfSA6IHVuZGVmaW5lZCxcbiAgICBhZ2dyZWdhdG9yTmFtZTogYWdncmVnYXRlRnVuY3Rpb24sXG4gICAgdmFsczogWyd2YWx1ZSddLFxuICAgIHJlbmRlcmVyTmFtZTogXCJUYWJsZSBXaXRoIFN1YnRvdGFsXCIsXG4gICAgY29sT3JkZXI6IGNvbE9yZGVyLFxuICAgIHJvd09yZGVyOiByb3dPcmRlcixcbiAgICBzb3J0ZXJzOiB7XG4gICAgICBtZXRyaWM6IHNvcnRBcyhtZXRyaWNOYW1lcylcbiAgICB9LFxuICAgIHRhYmxlT3B0aW9uczoge1xuICAgICAgY2xpY2tSb3dIZWFkZXJDYWxsYmFjazogdG9nZ2xlRmlsdGVyLFxuICAgICAgY2xpY2tDb2x1bW5IZWFkZXJDYWxsYmFjazogdG9nZ2xlRmlsdGVyLFxuICAgICAgY29sVG90YWxzLFxuICAgICAgcm93VG90YWxzLFxuICAgICAgaGlnaGxpZ2h0SGVhZGVyQ2VsbHNPbkhvdmVyOiBlbWl0RmlsdGVyLFxuICAgICAgaGlnaGxpZ2h0ZWRIZWFkZXJDZWxsczogc2VsZWN0ZWRGaWx0ZXJzLFxuICAgICAgb21pdHRlZEhpZ2hsaWdodEhlYWRlckdyb3VwczogW01FVFJJQ19LRVldLFxuICAgICAgY2VsbENvbG9yRm9ybWF0dGVyczoge1xuICAgICAgICBbTUVUUklDX0tFWV06IG1ldHJpY0NvbG9yRm9ybWF0dGVyc1xuICAgICAgfSxcbiAgICAgIGRhdGVGb3JtYXR0ZXJzXG4gICAgfSxcbiAgICBzdWJ0b3RhbE9wdGlvbnM6IHtcbiAgICAgIGNvbFN1YnRvdGFsRGlzcGxheToge1xuICAgICAgICBkaXNwbGF5T25Ub3A6IGNvbFN1YnRvdGFsUG9zaXRpb25cbiAgICAgIH0sXG4gICAgICByb3dTdWJ0b3RhbERpc3BsYXk6IHtcbiAgICAgICAgZGlzcGxheU9uVG9wOiByb3dTdWJ0b3RhbFBvc2l0aW9uXG4gICAgICB9LFxuICAgICAgYXJyb3dDb2xsYXBzZWQ6IF9fX0Vtb3Rpb25KU1goUGx1c1NxdWFyZU91dGxpbmVkLCB7XG4gICAgICAgIHN0eWxlOiBpY29uU3R5bGVcbiAgICAgIH0pLFxuICAgICAgYXJyb3dFeHBhbmRlZDogX19fRW1vdGlvbkpTWChNaW51c1NxdWFyZU91dGxpbmVkLCB7XG4gICAgICAgIHN0eWxlOiBpY29uU3R5bGVcbiAgICAgIH0pXG4gICAgfSxcbiAgICBuYW1lc01hcHBpbmc6IHZlcmJvc2VNYXBcbiAgfSkpKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/plugin-chart-pivot-table/esm/PivotTableChart.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/PivotTable.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/PivotTable.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _Utilities = __webpack_require__(/*! ./Utilities */ \"./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/Utilities.js\");\n\nvar _TableRenderers = __webpack_require__(/*! ./TableRenderers */ \"./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/TableRenderers.js\");\n\nvar _TableRenderers2 = _interopRequireDefault(_TableRenderers);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/* eslint-disable react/prop-types */\n// eslint can't see inherited propTypes!\n\nvar PivotTable = function (_React$PureComponent) {\n  _inherits(PivotTable, _React$PureComponent);\n\n  function PivotTable() {\n    _classCallCheck(this, PivotTable);\n\n    return _possibleConstructorReturn(this, (PivotTable.__proto__ || Object.getPrototypeOf(PivotTable)).apply(this, arguments));\n  }\n\n  _createClass(PivotTable, [{\n    key: 'render',\n    value: function render() {\n      var Renderer = this.props.renderers[this.props.rendererName in this.props.renderers ? this.props.rendererName : Object.keys(this.props.renderers)[0]];\n      return _react2.default.createElement(Renderer, this.props);\n    }\n  }]);\n\n  return PivotTable;\n}(_react2.default.PureComponent);\n\nPivotTable.propTypes = Object.assign({}, _Utilities.PivotData.propTypes, {\n  rendererName: _propTypes2.default.string,\n  renderers: _propTypes2.default.objectOf(_propTypes2.default.func)\n});\n\nPivotTable.defaultProps = Object.assign({}, _Utilities.PivotData.defaultProps, {\n  rendererName: 'Table',\n  renderers: _TableRenderers2.default\n});\n\nexports.default = PivotTable;\nmodule.exports = exports.default;\n//# sourceMappingURL=PivotTable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3JlYWN0LXBpdm90dGFibGUvUGl2b3RUYWJsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvcGx1Z2luLWNoYXJ0LXBpdm90LXRhYmxlL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvcmVhY3QtcGl2b3R0YWJsZS9QaXZvdFRhYmxlLmpzP2U5NDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX1V0aWxpdGllcyA9IHJlcXVpcmUoJy4vVXRpbGl0aWVzJyk7XG5cbnZhciBfVGFibGVSZW5kZXJlcnMgPSByZXF1aXJlKCcuL1RhYmxlUmVuZGVyZXJzJyk7XG5cbnZhciBfVGFibGVSZW5kZXJlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGFibGVSZW5kZXJlcnMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3Byb3AtdHlwZXMgKi9cbi8vIGVzbGludCBjYW4ndCBzZWUgaW5oZXJpdGVkIHByb3BUeXBlcyFcblxudmFyIFBpdm90VGFibGUgPSBmdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBpdm90VGFibGUsIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQaXZvdFRhYmxlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQaXZvdFRhYmxlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUGl2b3RUYWJsZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBpdm90VGFibGUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQaXZvdFRhYmxlLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBSZW5kZXJlciA9IHRoaXMucHJvcHMucmVuZGVyZXJzW3RoaXMucHJvcHMucmVuZGVyZXJOYW1lIGluIHRoaXMucHJvcHMucmVuZGVyZXJzID8gdGhpcy5wcm9wcy5yZW5kZXJlck5hbWUgOiBPYmplY3Qua2V5cyh0aGlzLnByb3BzLnJlbmRlcmVycylbMF1dO1xuICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlbmRlcmVyLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGl2b3RUYWJsZTtcbn0oX3JlYWN0Mi5kZWZhdWx0LlB1cmVDb21wb25lbnQpO1xuXG5QaXZvdFRhYmxlLnByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oe30sIF9VdGlsaXRpZXMuUGl2b3REYXRhLnByb3BUeXBlcywge1xuICByZW5kZXJlck5hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICByZW5kZXJlcnM6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0T2YoX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jKVxufSk7XG5cblBpdm90VGFibGUuZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgX1V0aWxpdGllcy5QaXZvdERhdGEuZGVmYXVsdFByb3BzLCB7XG4gIHJlbmRlcmVyTmFtZTogJ1RhYmxlJyxcbiAgcmVuZGVyZXJzOiBfVGFibGVSZW5kZXJlcnMyLmRlZmF1bHRcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQaXZvdFRhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaXZvdFRhYmxlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/PivotTable.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/TableRenderers.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/TableRenderers.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _Utilities = __webpack_require__(/*! ./Utilities */ \"./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/Utilities.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/* eslint-disable react/prop-types */\n// eslint can't see inherited propTypes!\n\nfunction redColorScaleGenerator(values) {\n  var min = Math.min.apply(Math, values);\n  var max = Math.max.apply(Math, values);\n  return function (x) {\n    // eslint-disable-next-line no-magic-numbers\n    var nonRed = 255 - Math.round(255 * (x - min) / (max - min));\n    return { backgroundColor: 'rgb(255,' + nonRed + ',' + nonRed + ')' };\n  };\n}\n\nvar parseLabel = function parseLabel(value) {\n  if (typeof value === 'number' || typeof value === 'string') {\n    return value;\n  }\n  return String(value);\n};\n\nfunction defaultBarchartScaleGenerator(values) {\n  var min = Math.min.apply(Math, values);\n  var max = Math.max.apply(Math, values);\n  var range = min < 0 ? max - min : Math.max(max, 0);\n  // eslint-disable-next-line no-magic-numbers\n  var maxScale = 100 / 1.4;\n  var scaler = function scaler(val) {\n    return Math.min(maxScale, maxScale * (val / range));\n  };\n\n  return function (val, text) {\n    var bgColor = 'gray';\n    var bBase = 0;\n    if (min < 0) {\n      bBase = scaler(-min);\n    }\n    if (val < 0) {\n      bBase += scaler(val);\n      bgColor = 'darkred';\n    }\n\n    return _react2.default.createElement(\n      'div',\n      { style: { position: 'relative', height: '100%' } },\n      _react2.default.createElement('div', {\n        style: {\n          position: 'absolute',\n          bottom: bBase + '%',\n          left: 0,\n          right: 0,\n          height: scaler(Math.abs(val)) + '%',\n          backgroundColor: bgColor\n        }\n      }),\n      _react2.default.createElement(\n        'div',\n        { style: { position: 'relative', padding: '0 5px' } },\n        text\n      )\n    );\n  };\n}\n\nfunction displayHeaderCell(needToggle, ArrowIcon, onArrowClick, value, namesMapping) {\n  var name = namesMapping[value] || value;\n  return needToggle ? _react2.default.createElement(\n    'span',\n    { className: 'toggle-wrapper' },\n    _react2.default.createElement(\n      'span',\n      { className: 'toggle', onClick: onArrowClick },\n      ArrowIcon\n    ),\n    _react2.default.createElement(\n      'span',\n      { className: 'toggle-val' },\n      parseLabel(name)\n    )\n  ) : parseLabel(name);\n}\n\nfunction makeRenderer() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var TableRenderer = function (_React$Component) {\n    _inherits(TableRenderer, _React$Component);\n\n    function TableRenderer(props) {\n      _classCallCheck(this, TableRenderer);\n\n      // We need state to record which entries are collapsed and which aren't.\n      // This is an object with flat-keys indicating if the corresponding rows\n      // should be collapsed.\n      var _this = _possibleConstructorReturn(this, (TableRenderer.__proto__ || Object.getPrototypeOf(TableRenderer)).call(this, props));\n\n      _this.state = { collapsedRows: {}, collapsedCols: {} };\n\n      _this.clickHeaderHandler = _this.clickHeaderHandler.bind(_this);\n      _this.clickHandler = _this.clickHandler.bind(_this);\n      return _this;\n    }\n\n    _createClass(TableRenderer, [{\n      key: 'getBasePivotSettings',\n      value: function getBasePivotSettings() {\n        // One-time extraction of pivot settings that we'll use throughout the render.\n\n        var props = this.props;\n        var colAttrs = props.cols;\n        var rowAttrs = props.rows;\n\n        var tableOptions = Object.assign({\n          rowTotals: true,\n          colTotals: true\n        }, props.tableOptions);\n        var rowTotals = tableOptions.rowTotals || colAttrs.length === 0;\n        var colTotals = tableOptions.colTotals || rowAttrs.length === 0;\n\n        var namesMapping = props.namesMapping || {};\n        var subtotalOptions = Object.assign({\n          arrowCollapsed: '\\u25B2',\n          arrowExpanded: '\\u25BC'\n        }, props.subtotalOptions);\n\n        var colSubtotalDisplay = Object.assign({\n          displayOnTop: false,\n          enabled: rowTotals,\n          hideOnExpand: false\n        }, subtotalOptions.colSubtotalDisplay);\n\n        var rowSubtotalDisplay = Object.assign({\n          displayOnTop: false,\n          enabled: colTotals,\n          hideOnExpand: false\n        }, subtotalOptions.rowSubtotalDisplay);\n\n        var pivotData = new _Utilities.PivotData(props, !opts.subtotals ? {} : {\n          rowEnabled: rowSubtotalDisplay.enabled,\n          colEnabled: colSubtotalDisplay.enabled,\n          rowPartialOnTop: rowSubtotalDisplay.displayOnTop,\n          colPartialOnTop: colSubtotalDisplay.displayOnTop\n        });\n        var rowKeys = pivotData.getRowKeys();\n        var colKeys = pivotData.getColKeys();\n\n        // Also pre-calculate all the callbacks for cells, etc... This is nice to have to\n        // avoid re-calculations of the call-backs on cell expansions, etc...\n        var cellCallbacks = {};\n        var rowTotalCallbacks = {};\n        var colTotalCallbacks = {};\n        var grandTotalCallback = null;\n        if (tableOptions.clickCallback) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = rowKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var rowKey = _step.value;\n\n              var flatRowKey = (0, _Utilities.flatKey)(rowKey);\n              if (!(flatRowKey in cellCallbacks)) {\n                cellCallbacks[flatRowKey] = {};\n              }\n              var _iteratorNormalCompletion4 = true;\n              var _didIteratorError4 = false;\n              var _iteratorError4 = undefined;\n\n              try {\n                for (var _iterator4 = colKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                  var _colKey = _step4.value;\n\n                  cellCallbacks[flatRowKey][(0, _Utilities.flatKey)(_colKey)] = this.clickHandler(pivotData, rowKey, _colKey);\n                }\n              } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                    _iterator4.return();\n                  }\n                } finally {\n                  if (_didIteratorError4) {\n                    throw _iteratorError4;\n                  }\n                }\n              }\n            }\n\n            // Add in totals as well.\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          if (rowTotals) {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = rowKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var _rowKey = _step2.value;\n\n                rowTotalCallbacks[(0, _Utilities.flatKey)(_rowKey)] = this.clickHandler(pivotData, _rowKey, []);\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          }\n          if (colTotals) {\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n              for (var _iterator3 = colKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var colKey = _step3.value;\n\n                colTotalCallbacks[(0, _Utilities.flatKey)(colKey)] = this.clickHandler(pivotData, [], colKey);\n              }\n            } catch (err) {\n              _didIteratorError3 = true;\n              _iteratorError3 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                  _iterator3.return();\n                }\n              } finally {\n                if (_didIteratorError3) {\n                  throw _iteratorError3;\n                }\n              }\n            }\n          }\n          if (rowTotals && colTotals) {\n            grandTotalCallback = this.clickHandler(pivotData, [], []);\n          }\n        }\n\n        return Object.assign({\n          pivotData: pivotData,\n          colAttrs: colAttrs,\n          rowAttrs: rowAttrs,\n          colKeys: colKeys,\n          rowKeys: rowKeys,\n          rowTotals: rowTotals,\n          colTotals: colTotals,\n          arrowCollapsed: subtotalOptions.arrowCollapsed,\n          arrowExpanded: subtotalOptions.arrowExpanded,\n          colSubtotalDisplay: colSubtotalDisplay,\n          rowSubtotalDisplay: rowSubtotalDisplay,\n          cellCallbacks: cellCallbacks,\n          rowTotalCallbacks: rowTotalCallbacks,\n          colTotalCallbacks: colTotalCallbacks,\n          grandTotalCallback: grandTotalCallback,\n          namesMapping: namesMapping\n        }, TableRenderer.heatmapMappers(pivotData, props.tableColorScaleGenerator, colTotals, rowTotals), TableRenderer.barchartMapper(pivotData, props.barScaleGenerator, colTotals, rowTotals));\n      }\n    }, {\n      key: 'clickHandler',\n      value: function clickHandler(pivotData, rowValues, colValues) {\n        var _this2 = this;\n\n        var colAttrs = this.props.cols;\n        var rowAttrs = this.props.rows;\n        var value = pivotData.getAggregator(rowValues, colValues).value();\n        var filters = {};\n        var colLimit = Math.min(colAttrs.length, colValues.length);\n        for (var i = 0; i < colLimit; i++) {\n          var attr = colAttrs[i];\n          if (colValues[i] !== null) {\n            filters[attr] = colValues[i];\n          }\n        }\n        var rowLimit = Math.min(rowAttrs.length, rowValues.length);\n        for (var _i = 0; _i < rowLimit; _i++) {\n          var _attr = rowAttrs[_i];\n          if (rowValues[_i] !== null) {\n            filters[_attr] = rowValues[_i];\n          }\n        }\n        return function (e) {\n          return _this2.props.tableOptions.clickCallback(e, value, filters, pivotData);\n        };\n      }\n    }, {\n      key: 'clickHeaderHandler',\n      value: function clickHeaderHandler(pivotData, values, attrs, attrIdx, callback) {\n        var isSubtotal = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n        var isGrandTotal = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n\n        var filters = {};\n        for (var i = 0; i <= attrIdx; i++) {\n          var attr = attrs[i];\n          filters[attr] = values[i];\n        }\n        return function (e) {\n          return callback(e, values[attrIdx], filters, pivotData, isSubtotal, isGrandTotal);\n        };\n      }\n    }, {\n      key: 'collapseAttr',\n      value: function collapseAttr(rowOrCol, attrIdx, allKeys) {\n        var _this3 = this;\n\n        return function (e) {\n          // Collapse an entire attribute.\n          e.stopPropagation();\n          var keyLen = attrIdx + 1;\n          var collapsed = allKeys.filter(function (k) {\n            return k.length === keyLen;\n          }).map(_Utilities.flatKey);\n\n          var updates = {};\n          collapsed.forEach(function (k) {\n            updates[k] = true;\n          });\n\n          if (rowOrCol) {\n            _this3.setState(function (state) {\n              return {\n                collapsedRows: Object.assign({}, state.collapsedRows, updates)\n              };\n            });\n          } else {\n            _this3.setState(function (state) {\n              return {\n                collapsedCols: Object.assign({}, state.collapsedCols, updates)\n              };\n            });\n          }\n        };\n      }\n    }, {\n      key: 'expandAttr',\n      value: function expandAttr(rowOrCol, attrIdx, allKeys) {\n        var _this4 = this;\n\n        return function (e) {\n          // Expand an entire attribute. This implicitly implies expanding all of the\n          // parents as well. It's a bit inefficient but ah well...\n          e.stopPropagation();\n          var updates = {};\n          allKeys.forEach(function (k) {\n            for (var i = 0; i <= attrIdx; i++) {\n              updates[(0, _Utilities.flatKey)(k.slice(0, i + 1))] = false;\n            }\n          });\n\n          if (rowOrCol) {\n            _this4.setState(function (state) {\n              return {\n                collapsedRows: Object.assign({}, state.collapsedRows, updates)\n              };\n            });\n          } else {\n            _this4.setState(function (state) {\n              return {\n                collapsedCols: Object.assign({}, state.collapsedCols, updates)\n              };\n            });\n          }\n        };\n      }\n    }, {\n      key: 'toggleRowKey',\n      value: function toggleRowKey(flatRowKey) {\n        var _this5 = this;\n\n        return function (e) {\n          e.stopPropagation();\n          _this5.setState(function (state) {\n            return {\n              collapsedRows: Object.assign({}, state.collapsedRows, _defineProperty({}, flatRowKey, !state.collapsedRows[flatRowKey]))\n            };\n          });\n        };\n      }\n    }, {\n      key: 'toggleColKey',\n      value: function toggleColKey(flatColKey) {\n        var _this6 = this;\n\n        return function (e) {\n          e.stopPropagation();\n          _this6.setState(function (state) {\n            return {\n              collapsedCols: Object.assign({}, state.collapsedCols, _defineProperty({}, flatColKey, !state.collapsedCols[flatColKey]))\n            };\n          });\n        };\n      }\n    }, {\n      key: 'calcAttrSpans',\n      value: function calcAttrSpans(attrArr, numAttrs) {\n        // Given an array of attribute values (i.e. each element is another array with\n        // the value at every level), compute the spans for every attribute value at\n        // every level. The return value is a nested array of the same shape. It has\n        // -1's for repeated values and the span number otherwise.\n\n        var spans = [];\n        // Index of the last new value\n        var li = Array(numAttrs).map(function () {\n          return 0;\n        });\n        var lv = Array(numAttrs).map(function () {\n          return null;\n        });\n        for (var i = 0; i < attrArr.length; i++) {\n          // Keep increasing span values as long as the last keys are the same. For\n          // the rest, record spans of 1. Update the indices too.\n          var cv = attrArr[i];\n          var ent = [];\n          var depth = 0;\n          var limit = Math.min(lv.length, cv.length);\n          while (depth < limit && lv[depth] === cv[depth]) {\n            ent.push(-1);\n            spans[li[depth]][depth]++;\n            depth++;\n          }\n          while (depth < cv.length) {\n            li[depth] = i;\n            ent.push(1);\n            depth++;\n          }\n          spans.push(ent);\n          lv = cv;\n        }\n        return spans;\n      }\n    }, {\n      key: 'renderColHeaderRow',\n      value: function renderColHeaderRow(attrName, attrIdx, pivotSettings) {\n        // Render a single row in the column header at the top of the pivot table.\n\n        var rowAttrs = pivotSettings.rowAttrs,\n            colAttrs = pivotSettings.colAttrs,\n            colKeys = pivotSettings.colKeys,\n            visibleColKeys = pivotSettings.visibleColKeys,\n            colAttrSpans = pivotSettings.colAttrSpans,\n            rowTotals = pivotSettings.rowTotals,\n            arrowExpanded = pivotSettings.arrowExpanded,\n            arrowCollapsed = pivotSettings.arrowCollapsed,\n            colSubtotalDisplay = pivotSettings.colSubtotalDisplay,\n            maxColVisible = pivotSettings.maxColVisible,\n            pivotData = pivotSettings.pivotData,\n            namesMapping = pivotSettings.namesMapping;\n        var _props$tableOptions = this.props.tableOptions,\n            highlightHeaderCellsOnHover = _props$tableOptions.highlightHeaderCellsOnHover,\n            _props$tableOptions$o = _props$tableOptions.omittedHighlightHeaderGroups,\n            omittedHighlightHeaderGroups = _props$tableOptions$o === undefined ? [] : _props$tableOptions$o,\n            highlightedHeaderCells = _props$tableOptions.highlightedHeaderCells,\n            dateFormatters = _props$tableOptions.dateFormatters;\n\n\n        var spaceCell = attrIdx === 0 && rowAttrs.length !== 0 ? _react2.default.createElement('th', {\n          key: 'padding',\n          colSpan: rowAttrs.length,\n          rowSpan: colAttrs.length\n        }) : null;\n\n        var needToggle = opts.subtotals && colSubtotalDisplay.enabled && attrIdx !== colAttrs.length - 1;\n        var arrowClickHandle = null;\n        var subArrow = null;\n        if (needToggle) {\n          arrowClickHandle = attrIdx + 1 < maxColVisible ? this.collapseAttr(false, attrIdx, colKeys) : this.expandAttr(false, attrIdx, colKeys);\n          subArrow = attrIdx + 1 < maxColVisible ? arrowExpanded : arrowCollapsed;\n        }\n        var attrNameCell = _react2.default.createElement(\n          'th',\n          { key: 'label', className: 'pvtAxisLabel' },\n          displayHeaderCell(needToggle, subArrow, arrowClickHandle, attrName, namesMapping)\n        );\n\n        var attrValueCells = [];\n        var rowIncrSpan = rowAttrs.length !== 0 ? 1 : 0;\n        // Iterate through columns. Jump over duplicate values.\n        var i = 0;\n        while (i < visibleColKeys.length) {\n          var colKey = visibleColKeys[i];\n          var colSpan = attrIdx < colKey.length ? colAttrSpans[i][attrIdx] : 1;\n          var colLabelClass = 'pvtColLabel';\n          if (attrIdx < colKey.length) {\n            if (highlightHeaderCellsOnHover && !omittedHighlightHeaderGroups.includes(colAttrs[attrIdx])) {\n              colLabelClass += ' hoverable';\n            }\n            if (highlightedHeaderCells && Array.isArray(highlightedHeaderCells[colAttrs[attrIdx]]) && highlightedHeaderCells[colAttrs[attrIdx]].includes(colKey[attrIdx])) {\n              colLabelClass += ' active';\n            }\n\n            var rowSpan = 1 + (attrIdx === colAttrs.length - 1 ? rowIncrSpan : 0);\n            var flatColKey = (0, _Utilities.flatKey)(colKey.slice(0, attrIdx + 1));\n            var onArrowClick = needToggle ? this.toggleColKey(flatColKey) : null;\n\n            var headerCellFormattedValue = dateFormatters && dateFormatters[attrName] && typeof dateFormatters[attrName] === 'function' ? dateFormatters[attrName](colKey[attrIdx]) : colKey[attrIdx];\n            attrValueCells.push(_react2.default.createElement(\n              'th',\n              {\n                className: colLabelClass,\n                key: 'colKey-' + flatColKey,\n                colSpan: colSpan,\n                rowSpan: rowSpan,\n                onClick: this.clickHeaderHandler(pivotData, colKey, this.props.cols, attrIdx, this.props.tableOptions.clickColumnHeaderCallback)\n              },\n              displayHeaderCell(needToggle, this.state.collapsedCols[flatColKey] ? arrowCollapsed : arrowExpanded, onArrowClick, headerCellFormattedValue, namesMapping)\n            ));\n          } else if (attrIdx === colKey.length) {\n            var _rowSpan = colAttrs.length - colKey.length + rowIncrSpan;\n            attrValueCells.push(_react2.default.createElement(\n              'th',\n              {\n                className: colLabelClass + ' pvtSubtotalLabel',\n                key: 'colKeyBuffer-' + (0, _Utilities.flatKey)(colKey),\n                colSpan: colSpan,\n                rowSpan: _rowSpan,\n                onClick: this.clickHeaderHandler(pivotData, colKey, this.props.cols, attrIdx, this.props.tableOptions.clickColumnHeaderCallback, true)\n              },\n              'Subtotal'\n            ));\n          }\n          // The next colSpan columns will have the same value anyway...\n          i = i + colSpan;\n        }\n\n        var totalCell = attrIdx === 0 && rowTotals ? _react2.default.createElement(\n          'th',\n          {\n            key: 'total',\n            className: 'pvtTotalLabel',\n            rowSpan: colAttrs.length + Math.min(rowAttrs.length, 1),\n            onClick: this.clickHeaderHandler(pivotData, [], this.props.cols, attrIdx, this.props.tableOptions.clickColumnHeaderCallback, false, true)\n          },\n          'Total (' + this.props.aggregatorName + ')'\n        ) : null;\n\n        var cells = [spaceCell, attrNameCell].concat(attrValueCells, [totalCell]);\n        return _react2.default.createElement(\n          'tr',\n          { key: 'colAttr-' + attrIdx },\n          cells\n        );\n      }\n    }, {\n      key: 'renderRowHeaderRow',\n      value: function renderRowHeaderRow(pivotSettings) {\n        var _this7 = this;\n\n        // Render just the attribute names of the rows (the actual attribute values\n        // will show up in the individual rows).\n\n        var rowAttrs = pivotSettings.rowAttrs,\n            colAttrs = pivotSettings.colAttrs,\n            rowKeys = pivotSettings.rowKeys,\n            arrowCollapsed = pivotSettings.arrowCollapsed,\n            arrowExpanded = pivotSettings.arrowExpanded,\n            rowSubtotalDisplay = pivotSettings.rowSubtotalDisplay,\n            maxRowVisible = pivotSettings.maxRowVisible,\n            pivotData = pivotSettings.pivotData,\n            namesMapping = pivotSettings.namesMapping;\n\n        return _react2.default.createElement(\n          'tr',\n          { key: 'rowHdr' },\n          rowAttrs.map(function (r, i) {\n            var needLabelToggle = opts.subtotals && rowSubtotalDisplay.enabled && i !== rowAttrs.length - 1;\n            var arrowClickHandle = null;\n            var subArrow = null;\n            if (needLabelToggle) {\n              arrowClickHandle = i + 1 < maxRowVisible ? _this7.collapseAttr(true, i, rowKeys) : _this7.expandAttr(true, i, rowKeys);\n              subArrow = i + 1 < maxRowVisible ? arrowExpanded : arrowCollapsed;\n            }\n            return _react2.default.createElement(\n              'th',\n              { className: 'pvtAxisLabel', key: 'rowAttr-' + i },\n              displayHeaderCell(needLabelToggle, subArrow, arrowClickHandle, r, namesMapping)\n            );\n          }),\n          _react2.default.createElement(\n            'th',\n            {\n              className: 'pvtTotalLabel',\n              key: 'padding',\n              onClick: this.clickHeaderHandler(pivotData, [], this.props.rows, 0, this.props.tableOptions.clickRowHeaderCallback, false, true)\n            },\n            colAttrs.length === 0 ? 'Total (' + this.props.aggregatorName + ')' : null\n          )\n        );\n      }\n    }, {\n      key: 'renderTableRow',\n      value: function renderTableRow(rowKey, rowIdx, pivotSettings) {\n        var _this8 = this;\n\n        // Render a single row in the pivot table.\n\n        var rowAttrs = pivotSettings.rowAttrs,\n            colAttrs = pivotSettings.colAttrs,\n            rowAttrSpans = pivotSettings.rowAttrSpans,\n            visibleColKeys = pivotSettings.visibleColKeys,\n            pivotData = pivotSettings.pivotData,\n            rowTotals = pivotSettings.rowTotals,\n            rowSubtotalDisplay = pivotSettings.rowSubtotalDisplay,\n            valueCellColors = pivotSettings.valueCellColors,\n            cellStyle = pivotSettings.cellStyle,\n            valueCellBar = pivotSettings.valueCellBar,\n            arrowExpanded = pivotSettings.arrowExpanded,\n            arrowCollapsed = pivotSettings.arrowCollapsed,\n            cellCallbacks = pivotSettings.cellCallbacks,\n            rowTotalCallbacks = pivotSettings.rowTotalCallbacks,\n            namesMapping = pivotSettings.namesMapping;\n        var _props$tableOptions2 = this.props.tableOptions,\n            highlightHeaderCellsOnHover = _props$tableOptions2.highlightHeaderCellsOnHover,\n            _props$tableOptions2$ = _props$tableOptions2.omittedHighlightHeaderGroups,\n            omittedHighlightHeaderGroups = _props$tableOptions2$ === undefined ? [] : _props$tableOptions2$,\n            highlightedHeaderCells = _props$tableOptions2.highlightedHeaderCells,\n            cellColorFormatters = _props$tableOptions2.cellColorFormatters,\n            dateFormatters = _props$tableOptions2.dateFormatters;\n\n        var flatRowKey = (0, _Utilities.flatKey)(rowKey);\n\n        var colIncrSpan = colAttrs.length !== 0 ? 1 : 0;\n        var attrValueCells = rowKey.map(function (r, i) {\n          var valueCellClassName = 'pvtRowLabel';\n          if (highlightHeaderCellsOnHover && !omittedHighlightHeaderGroups.includes(rowAttrs[i])) {\n            valueCellClassName += ' hoverable';\n          }\n          if (highlightedHeaderCells && Array.isArray(highlightedHeaderCells[rowAttrs[i]]) && highlightedHeaderCells[rowAttrs[i]].includes(r)) {\n            valueCellClassName += ' active';\n          }\n          var rowSpan = rowAttrSpans[rowIdx][i];\n          if (rowSpan > 0) {\n            var _flatRowKey = (0, _Utilities.flatKey)(rowKey.slice(0, i + 1));\n            var colSpan = 1 + (i === rowAttrs.length - 1 ? colIncrSpan : 0);\n            var needRowToggle = opts.subtotals && rowSubtotalDisplay.enabled && i !== rowAttrs.length - 1;\n            var onArrowClick = needRowToggle ? _this8.toggleRowKey(_flatRowKey) : null;\n\n            var headerCellFormattedValue = dateFormatters && dateFormatters[rowAttrs[i]] ? dateFormatters[rowAttrs[i]](r) : r;\n            return _react2.default.createElement(\n              'th',\n              {\n                key: 'rowKeyLabel-' + i,\n                className: valueCellClassName,\n                rowSpan: rowSpan,\n                colSpan: colSpan,\n                onClick: _this8.clickHeaderHandler(pivotData, rowKey, _this8.props.rows, i, _this8.props.tableOptions.clickRowHeaderCallback)\n              },\n              displayHeaderCell(needRowToggle, _this8.state.collapsedRows[_flatRowKey] ? arrowCollapsed : arrowExpanded, onArrowClick, headerCellFormattedValue, namesMapping)\n            );\n          }\n          return null;\n        });\n\n        var attrValuePaddingCell = rowKey.length < rowAttrs.length ? _react2.default.createElement(\n          'th',\n          {\n            className: 'pvtRowLabel pvtSubtotalLabel',\n            key: 'rowKeyBuffer',\n            colSpan: rowAttrs.length - rowKey.length + colIncrSpan,\n            rowSpan: 1,\n            onClick: this.clickHeaderHandler(pivotData, rowKey, this.props.rows, rowKey.length, this.props.tableOptions.clickRowHeaderCallback, true)\n          },\n          'Subtotal'\n        ) : null;\n\n        var rowClickHandlers = cellCallbacks[flatRowKey] || {};\n        var valueCells = visibleColKeys.map(function (colKey) {\n          var flatColKey = (0, _Utilities.flatKey)(colKey);\n          var agg = pivotData.getAggregator(rowKey, colKey);\n          var aggValue = agg.value();\n          var backgroundColor = void 0;\n          var keys = [].concat(_toConsumableArray(rowKey), _toConsumableArray(colKey));\n          if (cellColorFormatters) {\n            Object.values(cellColorFormatters).forEach(function (cellColorFormatter) {\n              if (Array.isArray(cellColorFormatter)) {\n                var _loop = function _loop(key) {\n                  cellColorFormatter.filter(function (formatter) {\n                    return formatter.column === key;\n                  }).forEach(function (formatter) {\n                    var formatterResult = formatter.getColorFromValue(aggValue);\n                    if (formatterResult) {\n                      backgroundColor = formatterResult;\n                    }\n                  });\n                  if (backgroundColor) {\n                    return 'break';\n                  }\n                };\n\n                var _iteratorNormalCompletion5 = true;\n                var _didIteratorError5 = false;\n                var _iteratorError5 = undefined;\n\n                try {\n                  for (var _iterator5 = keys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var key = _step5.value;\n\n                    var _ret = _loop(key);\n\n                    if (_ret === 'break') break;\n                  }\n                } catch (err) {\n                  _didIteratorError5 = true;\n                  _iteratorError5 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                      _iterator5.return();\n                    }\n                  } finally {\n                    if (_didIteratorError5) {\n                      throw _iteratorError5;\n                    }\n                  }\n                }\n              }\n            });\n          }\n\n          var style = Object.assign({}, agg.isSubtotal ? { fontWeight: 'bold' } : valueCellColors(rowKey, colKey, aggValue), !agg.isSubtotal ? { backgroundColor: backgroundColor } : {}, cellStyle);\n\n          return _react2.default.createElement(\n            'td',\n            {\n              className: 'pvtVal',\n              key: 'pvtVal-' + flatColKey,\n              onClick: rowClickHandlers[flatColKey],\n              style: style\n            },\n            agg.isSubtotal ? agg.format(aggValue) : valueCellBar(rowKey, colKey, aggValue, agg.format(aggValue))\n          );\n        });\n\n        var totalCell = null;\n        if (rowTotals) {\n          var agg = pivotData.getAggregator(rowKey, []);\n          var aggValue = agg.value();\n          totalCell = _react2.default.createElement(\n            'td',\n            {\n              key: 'total',\n              className: 'pvtTotal',\n              onClick: rowTotalCallbacks[flatRowKey],\n              style: cellStyle\n            },\n            agg.format(aggValue)\n          );\n        }\n\n        var rowCells = [].concat(_toConsumableArray(attrValueCells), [attrValuePaddingCell], _toConsumableArray(valueCells), [totalCell]);\n\n        return _react2.default.createElement(\n          'tr',\n          { key: 'keyRow-' + flatRowKey },\n          rowCells\n        );\n      }\n    }, {\n      key: 'renderTotalsRow',\n      value: function renderTotalsRow(pivotSettings) {\n        // Render the final totals rows that has the totals for all the columns.\n\n        var rowAttrs = pivotSettings.rowAttrs,\n            colAttrs = pivotSettings.colAttrs,\n            visibleColKeys = pivotSettings.visibleColKeys,\n            rowTotals = pivotSettings.rowTotals,\n            pivotData = pivotSettings.pivotData,\n            cellStyle = pivotSettings.cellStyle,\n            colTotalCallbacks = pivotSettings.colTotalCallbacks,\n            grandTotalCallback = pivotSettings.grandTotalCallback;\n\n\n        var totalLabelCell = _react2.default.createElement(\n          'th',\n          {\n            key: 'label',\n            className: 'pvtTotalLabel pvtRowTotalLabel',\n            colSpan: rowAttrs.length + Math.min(colAttrs.length, 1),\n            onClick: this.clickHeaderHandler(pivotData, [], this.props.rows, 0, this.props.tableOptions.clickRowHeaderCallback, false, true)\n          },\n          'Total (' + this.props.aggregatorName + ')'\n        );\n\n        var totalValueStyle = Object.assign({}, cellStyle, {\n          padding: '5px'\n        });\n        var totalValueCells = visibleColKeys.map(function (colKey) {\n          var flatColKey = (0, _Utilities.flatKey)(colKey);\n          var agg = pivotData.getAggregator([], colKey);\n          var aggValue = agg.value();\n\n          return _react2.default.createElement(\n            'td',\n            {\n              className: 'pvtTotal pvtRowTotal',\n              key: 'total-' + flatColKey,\n              onClick: colTotalCallbacks[flatColKey],\n              style: totalValueStyle\n            },\n            agg.format(aggValue)\n          );\n        });\n\n        var grandTotalCell = null;\n        if (rowTotals) {\n          var agg = pivotData.getAggregator([], []);\n          var aggValue = agg.value();\n          grandTotalCell = _react2.default.createElement(\n            'td',\n            {\n              key: 'total',\n              className: 'pvtGrandTotal pvtRowTotal',\n              onClick: grandTotalCallback\n            },\n            agg.format(aggValue)\n          );\n        }\n\n        var totalCells = [totalLabelCell].concat(_toConsumableArray(totalValueCells), [grandTotalCell]);\n\n        return _react2.default.createElement(\n          'tr',\n          { key: 'total', className: 'pvtRowTotals' },\n          totalCells\n        );\n      }\n    }, {\n      key: 'visibleKeys',\n      value: function visibleKeys(keys, collapsed, numAttrs, subtotalDisplay) {\n        return keys.filter(function (key) {\n          return (\n            // Is the key hidden by one of its parents?\n            !key.some(function (k, j) {\n              return collapsed[(0, _Utilities.flatKey)(key.slice(0, j))];\n            }) && (\n            // Leaf key.\n            key.length === numAttrs ||\n            // Children hidden. Must show total.\n            (0, _Utilities.flatKey)(key) in collapsed ||\n            // Don't hide totals.\n            !subtotalDisplay.hideOnExpand)\n          );\n        });\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var _this9 = this;\n\n        if (this.cachedProps !== this.props) {\n          this.cachedProps = this.props;\n          this.cachedBasePivotSettings = this.getBasePivotSettings();\n        }\n        var _cachedBasePivotSetti = this.cachedBasePivotSettings,\n            colAttrs = _cachedBasePivotSetti.colAttrs,\n            rowAttrs = _cachedBasePivotSetti.rowAttrs,\n            rowKeys = _cachedBasePivotSetti.rowKeys,\n            colKeys = _cachedBasePivotSetti.colKeys,\n            colTotals = _cachedBasePivotSetti.colTotals,\n            rowSubtotalDisplay = _cachedBasePivotSetti.rowSubtotalDisplay,\n            colSubtotalDisplay = _cachedBasePivotSetti.colSubtotalDisplay;\n\n        // Need to account for exclusions to compute the effective row\n        // and column keys.\n\n        var visibleRowKeys = opts.subtotals ? this.visibleKeys(rowKeys, this.state.collapsedRows, rowAttrs.length, rowSubtotalDisplay) : rowKeys;\n        var visibleColKeys = opts.subtotals ? this.visibleKeys(colKeys, this.state.collapsedCols, colAttrs.length, colSubtotalDisplay) : colKeys;\n\n        var pivotSettings = Object.assign({\n          visibleRowKeys: visibleRowKeys,\n          maxRowVisible: Math.max.apply(Math, _toConsumableArray(visibleRowKeys.map(function (k) {\n            return k.length;\n          }))),\n          visibleColKeys: visibleColKeys,\n          maxColVisible: Math.max.apply(Math, _toConsumableArray(visibleColKeys.map(function (k) {\n            return k.length;\n          }))),\n          rowAttrSpans: this.calcAttrSpans(visibleRowKeys, rowAttrs.length),\n          colAttrSpans: this.calcAttrSpans(visibleColKeys, colAttrs.length)\n        }, this.cachedBasePivotSettings);\n\n        return _react2.default.createElement(\n          'table',\n          { className: 'pvtTable' },\n          _react2.default.createElement(\n            'thead',\n            null,\n            colAttrs.map(function (c, j) {\n              return _this9.renderColHeaderRow(c, j, pivotSettings);\n            }),\n            rowAttrs.length !== 0 && this.renderRowHeaderRow(pivotSettings)\n          ),\n          _react2.default.createElement(\n            'tbody',\n            null,\n            visibleRowKeys.map(function (r, i) {\n              return _this9.renderTableRow(r, i, pivotSettings);\n            }),\n            colTotals && this.renderTotalsRow(pivotSettings)\n          )\n        );\n      }\n    }], [{\n      key: 'heatmapMappers',\n      value: function heatmapMappers(pivotData, colorScaleGenerator, colTotals, rowTotals) {\n        var valueCellColors = function valueCellColors() {\n          return {};\n        };\n        var rowTotalColors = function rowTotalColors() {\n          return {};\n        };\n        var colTotalColors = function colTotalColors() {\n          return {};\n        };\n        if (opts.heatmapMode) {\n          if (colTotals) {\n            var colTotalValues = Object.values(pivotData.colTotals).map(function (a) {\n              return a.value();\n            });\n            colTotalColors = colorScaleGenerator(colTotalValues);\n          }\n          if (rowTotals) {\n            var rowTotalValues = Object.values(pivotData.rowTotals).map(function (a) {\n              return a.value();\n            });\n            rowTotalColors = colorScaleGenerator(rowTotalValues);\n          }\n          if (opts.heatmapMode === 'full') {\n            var allValues = [];\n            Object.values(pivotData.tree).map(function (cd) {\n              return Object.values(cd).map(function (a) {\n                return !a.isSubtotal && allValues.push(a.value());\n              });\n            });\n            var colorScale = colorScaleGenerator(allValues);\n            valueCellColors = function valueCellColors(r, c, v) {\n              return colorScale(v);\n            };\n          } else if (opts.heatmapMode === 'row') {\n            var rowColorScales = {};\n            Object.entries(pivotData.tree).map(function (_ref) {\n              var _ref2 = _slicedToArray(_ref, 2),\n                  rk = _ref2[0],\n                  cd = _ref2[1];\n\n              var rowValues = Object.values(cd).map(function (a) {\n                return !a.isSubtotal && a.value();\n              });\n              rowColorScales[rk] = colorScaleGenerator(rowValues);\n            });\n            valueCellColors = function valueCellColors(r, c, v) {\n              return rowColorScales[(0, _Utilities.flatKey)(r)](v);\n            };\n          } else if (opts.heatmapMode === 'col') {\n            var colColorScales = {};\n            var colValues = {};\n            Object.values(pivotData.tree).map(function (cd) {\n              return Object.entries(cd).map(function (_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2),\n                    ck = _ref4[0],\n                    a = _ref4[1];\n\n                if (!(ck in colValues)) {\n                  colValues[ck] = [];\n                }\n                if (!a.isSubtotal) {\n                  colValues[ck].push(a.value());\n                }\n              });\n            });\n            for (var k in colValues) {\n              colColorScales[k] = colorScaleGenerator(colValues[k]);\n            }\n            valueCellColors = function valueCellColors(r, c, v) {\n              return colColorScales[(0, _Utilities.flatKey)(c)](v);\n            };\n          }\n        }\n        return { valueCellColors: valueCellColors, rowTotalColors: rowTotalColors, colTotalColors: colTotalColors };\n      }\n    }, {\n      key: 'barchartMapper',\n      value: function barchartMapper(pivotData, barScaleGenerator, colTotals, rowTotals) {\n        var cellStyle = {};\n        var valueCellBar = function valueCellBar(r, c, v, t) {\n          return t;\n        };\n        var rowTotalBar = function rowTotalBar(v, t) {\n          return t;\n        };\n        var colTotalBar = function colTotalBar(v, t) {\n          return t;\n        };\n\n        if (opts.barchartMode) {\n          cellStyle = {\n            textAlign: 'center',\n            padding: 0,\n            paddingTop: '5px',\n            height: '60px'\n          };\n          if (colTotals) {\n            var colTotalValues = Object.values(pivotData.colTotals).filter(function (a) {\n              return !a.isSubtotal;\n            }).map(function (a) {\n              return a.value();\n            });\n            colTotalBar = barScaleGenerator(colTotalValues);\n          }\n          if (rowTotals) {\n            var rowTotalValues = Object.values(pivotData.rowTotals).filter(function (a) {\n              return !a.isSubtotal;\n            }).map(function (a) {\n              return a.value();\n            });\n            rowTotalBar = barScaleGenerator(rowTotalValues);\n          }\n          if (opts.barchartMode === 'full') {\n            var allValues = [];\n            Object.values(pivotData.tree).map(function (cd) {\n              return Object.values(cd).map(function (a) {\n                return !a.isSubtotal && allValues.push(a.value());\n              });\n            });\n            var barScales = barScaleGenerator(allValues);\n            valueCellBar = function valueCellBar(r, c, v, t) {\n              return barScales(v, t);\n            };\n          } else if (opts.barchartMode === 'row') {\n            var rowBarScales = {};\n            Object.entries(pivotData.tree).map(function (_ref5) {\n              var _ref6 = _slicedToArray(_ref5, 2),\n                  rk = _ref6[0],\n                  cd = _ref6[1];\n\n              var rowValues = Object.values(cd).map(function (a) {\n                return !a.isSubtotal && a.value();\n              });\n              rowBarScales[rk] = barScaleGenerator(rowValues);\n            });\n            valueCellBar = function valueCellBar(r, c, v, t) {\n              return rowBarScales[(0, _Utilities.flatKey)(r)](v, t);\n            };\n          } else if (opts.barchartMode === 'col') {\n            var colBarScales = {};\n            var colValues = {};\n            Object.values(pivotData.tree).map(function (cd) {\n              return Object.entries(cd).map(function (_ref7) {\n                var _ref8 = _slicedToArray(_ref7, 2),\n                    ck = _ref8[0],\n                    a = _ref8[1];\n\n                if (!(ck in colValues)) {\n                  colValues[ck] = [];\n                }\n                if (!a.isSubtotal) {\n                  colValues[ck].push(a.value());\n                }\n              });\n            });\n            for (var k in colValues) {\n              colBarScales[k] = barScaleGenerator(colValues[k]);\n            }\n            valueCellBar = function valueCellBar(r, c, v, t) {\n              return colBarScales[(0, _Utilities.flatKey)(c)](v, t);\n            };\n          }\n        }\n        return { cellStyle: cellStyle, valueCellBar: valueCellBar, rowTotalBar: rowTotalBar, colTotalBar: colTotalBar };\n      }\n    }]);\n\n    return TableRenderer;\n  }(_react2.default.Component);\n\n  TableRenderer.defaultProps = _Utilities.PivotData.defaultProps;\n  TableRenderer.propTypes = _Utilities.PivotData.propTypes;\n  TableRenderer.defaultProps.tableColorScaleGenerator = redColorScaleGenerator;\n  TableRenderer.defaultProps.barScaleGenerator = defaultBarchartScaleGenerator;\n  TableRenderer.defaultProps.tableOptions = {};\n  TableRenderer.propTypes.tableColorScaleGenerator = _propTypes2.default.func;\n  TableRenderer.propTypes.tableOptions = _propTypes2.default.object;\n  return TableRenderer;\n}\n\nvar TSVExportRenderer = function (_React$PureComponent) {\n  _inherits(TSVExportRenderer, _React$PureComponent);\n\n  function TSVExportRenderer() {\n    _classCallCheck(this, TSVExportRenderer);\n\n    return _possibleConstructorReturn(this, (TSVExportRenderer.__proto__ || Object.getPrototypeOf(TSVExportRenderer)).apply(this, arguments));\n  }\n\n  _createClass(TSVExportRenderer, [{\n    key: 'render',\n    value: function render() {\n      var pivotData = new _Utilities.PivotData(this.props);\n      var rowKeys = pivotData.getRowKeys();\n      var colKeys = pivotData.getColKeys();\n      if (rowKeys.length === 0) {\n        rowKeys.push([]);\n      }\n      if (colKeys.length === 0) {\n        colKeys.push([]);\n      }\n\n      var headerRow = pivotData.props.rows.map(function (r) {\n        return r;\n      });\n      if (colKeys.length === 1 && colKeys[0].length === 0) {\n        headerRow.push(this.props.aggregatorName);\n      } else {\n        colKeys.map(function (c) {\n          return headerRow.push(c.join('-'));\n        });\n      }\n\n      var result = rowKeys.map(function (r) {\n        var row = r.map(function (x) {\n          return x;\n        });\n        colKeys.map(function (c) {\n          var v = pivotData.getAggregator(r, c).value();\n          row.push(v ? v : '');\n        });\n        return row;\n      });\n\n      result.unshift(headerRow);\n\n      return _react2.default.createElement('textarea', {\n        value: result.map(function (r) {\n          return r.join('\\t');\n        }).join('\\n'),\n        style: { width: window.innerWidth / 2, height: window.innerHeight / 2 },\n        readOnly: true\n      });\n    }\n  }]);\n\n  return TSVExportRenderer;\n}(_react2.default.PureComponent);\n\nTSVExportRenderer.defaultProps = _Utilities.PivotData.defaultProps;\nTSVExportRenderer.propTypes = _Utilities.PivotData.propTypes;\n\nexports.default = {\n  Table: makeRenderer(),\n  'Table Heatmap': makeRenderer({ heatmapMode: 'full' }),\n  'Table Col Heatmap': makeRenderer({ heatmapMode: 'col' }),\n  'Table Row Heatmap': makeRenderer({ heatmapMode: 'row' }),\n  'Table Barchart': makeRenderer({ barchartMode: 'full' }),\n  'Table Col Barchart': makeRenderer({ barchartMode: 'col' }),\n  'Table Row Barchart': makeRenderer({ barchartMode: 'row' }),\n  'Table With Subtotal': makeRenderer({ subtotals: true }),\n  'Table With Subtotal Heatmap': makeRenderer({\n    heatmapMode: 'full',\n    subtotals: true\n  }),\n  'Table With Subtotal Col Heatmap': makeRenderer({\n    heatmapMode: 'col',\n    subtotals: true\n  }),\n  'Table With Subtotal Row Heatmap': makeRenderer({\n    heatmapMode: 'row',\n    subtotals: true\n  }),\n  'Table With Subtotal Barchart': makeRenderer({\n    barchartMode: 'full',\n    subtotals: true\n  }),\n  'Table With Subtotal Col Barchart': makeRenderer({\n    barchartMode: 'col',\n    subtotals: true\n  }),\n  'Table With Subtotal Row Barchart': makeRenderer({\n    barchartMode: 'row',\n    subtotals: true\n  }),\n  'Exportable TSV': TSVExportRenderer\n};\nmodule.exports = exports.default;\n//# sourceMappingURL=TableRenderers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3JlYWN0LXBpdm90dGFibGUvVGFibGVSZW5kZXJlcnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3JlYWN0LXBpdm90dGFibGUvVGFibGVSZW5kZXJlcnMuanM/Njg1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9VdGlsaXRpZXMgPSByZXF1aXJlKCcuL1V0aWxpdGllcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcm9wLXR5cGVzICovXG4vLyBlc2xpbnQgY2FuJ3Qgc2VlIGluaGVyaXRlZCBwcm9wVHlwZXMhXG5cbmZ1bmN0aW9uIHJlZENvbG9yU2NhbGVHZW5lcmF0b3IodmFsdWVzKSB7XG4gIHZhciBtaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgICB2YXIgbm9uUmVkID0gMjU1IC0gTWF0aC5yb3VuZCgyNTUgKiAoeCAtIG1pbikgLyAobWF4IC0gbWluKSk7XG4gICAgcmV0dXJuIHsgYmFja2dyb3VuZENvbG9yOiAncmdiKDI1NSwnICsgbm9uUmVkICsgJywnICsgbm9uUmVkICsgJyknIH07XG4gIH07XG59XG5cbnZhciBwYXJzZUxhYmVsID0gZnVuY3Rpb24gcGFyc2VMYWJlbCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufTtcblxuZnVuY3Rpb24gZGVmYXVsdEJhcmNoYXJ0U2NhbGVHZW5lcmF0b3IodmFsdWVzKSB7XG4gIHZhciBtaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcbiAgdmFyIHJhbmdlID0gbWluIDwgMCA/IG1heCAtIG1pbiA6IE1hdGgubWF4KG1heCwgMCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gIHZhciBtYXhTY2FsZSA9IDEwMCAvIDEuNDtcbiAgdmFyIHNjYWxlciA9IGZ1bmN0aW9uIHNjYWxlcih2YWwpIHtcbiAgICByZXR1cm4gTWF0aC5taW4obWF4U2NhbGUsIG1heFNjYWxlICogKHZhbCAvIHJhbmdlKSk7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHRleHQpIHtcbiAgICB2YXIgYmdDb2xvciA9ICdncmF5JztcbiAgICB2YXIgYkJhc2UgPSAwO1xuICAgIGlmIChtaW4gPCAwKSB7XG4gICAgICBiQmFzZSA9IHNjYWxlcigtbWluKTtcbiAgICB9XG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgIGJCYXNlICs9IHNjYWxlcih2YWwpO1xuICAgICAgYmdDb2xvciA9ICdkYXJrcmVkJztcbiAgICB9XG5cbiAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZGl2JyxcbiAgICAgIHsgc3R5bGU6IHsgcG9zaXRpb246ICdyZWxhdGl2ZScsIGhlaWdodDogJzEwMCUnIH0gfSxcbiAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgYm90dG9tOiBiQmFzZSArICclJyxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgIGhlaWdodDogc2NhbGVyKE1hdGguYWJzKHZhbCkpICsgJyUnLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYmdDb2xvclxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBzdHlsZTogeyBwb3NpdGlvbjogJ3JlbGF0aXZlJywgcGFkZGluZzogJzAgNXB4JyB9IH0sXG4gICAgICAgIHRleHRcbiAgICAgIClcbiAgICApO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkaXNwbGF5SGVhZGVyQ2VsbChuZWVkVG9nZ2xlLCBBcnJvd0ljb24sIG9uQXJyb3dDbGljaywgdmFsdWUsIG5hbWVzTWFwcGluZykge1xuICB2YXIgbmFtZSA9IG5hbWVzTWFwcGluZ1t2YWx1ZV0gfHwgdmFsdWU7XG4gIHJldHVybiBuZWVkVG9nZ2xlID8gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ3NwYW4nLFxuICAgIHsgY2xhc3NOYW1lOiAndG9nZ2xlLXdyYXBwZXInIH0sXG4gICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnc3BhbicsXG4gICAgICB7IGNsYXNzTmFtZTogJ3RvZ2dsZScsIG9uQ2xpY2s6IG9uQXJyb3dDbGljayB9LFxuICAgICAgQXJyb3dJY29uXG4gICAgKSxcbiAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICdzcGFuJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAndG9nZ2xlLXZhbCcgfSxcbiAgICAgIHBhcnNlTGFiZWwobmFtZSlcbiAgICApXG4gICkgOiBwYXJzZUxhYmVsKG5hbWUpO1xufVxuXG5mdW5jdGlvbiBtYWtlUmVuZGVyZXIoKSB7XG4gIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgVGFibGVSZW5kZXJlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFRhYmxlUmVuZGVyZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gVGFibGVSZW5kZXJlcihwcm9wcykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmxlUmVuZGVyZXIpO1xuXG4gICAgICAvLyBXZSBuZWVkIHN0YXRlIHRvIHJlY29yZCB3aGljaCBlbnRyaWVzIGFyZSBjb2xsYXBzZWQgYW5kIHdoaWNoIGFyZW4ndC5cbiAgICAgIC8vIFRoaXMgaXMgYW4gb2JqZWN0IHdpdGggZmxhdC1rZXlzIGluZGljYXRpbmcgaWYgdGhlIGNvcnJlc3BvbmRpbmcgcm93c1xuICAgICAgLy8gc2hvdWxkIGJlIGNvbGxhcHNlZC5cbiAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUYWJsZVJlbmRlcmVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGFibGVSZW5kZXJlcikpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgX3RoaXMuc3RhdGUgPSB7IGNvbGxhcHNlZFJvd3M6IHt9LCBjb2xsYXBzZWRDb2xzOiB7fSB9O1xuXG4gICAgICBfdGhpcy5jbGlja0hlYWRlckhhbmRsZXIgPSBfdGhpcy5jbGlja0hlYWRlckhhbmRsZXIuYmluZChfdGhpcyk7XG4gICAgICBfdGhpcy5jbGlja0hhbmRsZXIgPSBfdGhpcy5jbGlja0hhbmRsZXIuYmluZChfdGhpcyk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRhYmxlUmVuZGVyZXIsIFt7XG4gICAgICBrZXk6ICdnZXRCYXNlUGl2b3RTZXR0aW5ncycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzZVBpdm90U2V0dGluZ3MoKSB7XG4gICAgICAgIC8vIE9uZS10aW1lIGV4dHJhY3Rpb24gb2YgcGl2b3Qgc2V0dGluZ3MgdGhhdCB3ZSdsbCB1c2UgdGhyb3VnaG91dCB0aGUgcmVuZGVyLlxuXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBjb2xBdHRycyA9IHByb3BzLmNvbHM7XG4gICAgICAgIHZhciByb3dBdHRycyA9IHByb3BzLnJvd3M7XG5cbiAgICAgICAgdmFyIHRhYmxlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHJvd1RvdGFsczogdHJ1ZSxcbiAgICAgICAgICBjb2xUb3RhbHM6IHRydWVcbiAgICAgICAgfSwgcHJvcHMudGFibGVPcHRpb25zKTtcbiAgICAgICAgdmFyIHJvd1RvdGFscyA9IHRhYmxlT3B0aW9ucy5yb3dUb3RhbHMgfHwgY29sQXR0cnMubGVuZ3RoID09PSAwO1xuICAgICAgICB2YXIgY29sVG90YWxzID0gdGFibGVPcHRpb25zLmNvbFRvdGFscyB8fCByb3dBdHRycy5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgdmFyIG5hbWVzTWFwcGluZyA9IHByb3BzLm5hbWVzTWFwcGluZyB8fCB7fTtcbiAgICAgICAgdmFyIHN1YnRvdGFsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGFycm93Q29sbGFwc2VkOiAnXFx1MjVCMicsXG4gICAgICAgICAgYXJyb3dFeHBhbmRlZDogJ1xcdTI1QkMnXG4gICAgICAgIH0sIHByb3BzLnN1YnRvdGFsT3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIGNvbFN1YnRvdGFsRGlzcGxheSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGRpc3BsYXlPblRvcDogZmFsc2UsXG4gICAgICAgICAgZW5hYmxlZDogcm93VG90YWxzLFxuICAgICAgICAgIGhpZGVPbkV4cGFuZDogZmFsc2VcbiAgICAgICAgfSwgc3VidG90YWxPcHRpb25zLmNvbFN1YnRvdGFsRGlzcGxheSk7XG5cbiAgICAgICAgdmFyIHJvd1N1YnRvdGFsRGlzcGxheSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIGRpc3BsYXlPblRvcDogZmFsc2UsXG4gICAgICAgICAgZW5hYmxlZDogY29sVG90YWxzLFxuICAgICAgICAgIGhpZGVPbkV4cGFuZDogZmFsc2VcbiAgICAgICAgfSwgc3VidG90YWxPcHRpb25zLnJvd1N1YnRvdGFsRGlzcGxheSk7XG5cbiAgICAgICAgdmFyIHBpdm90RGF0YSA9IG5ldyBfVXRpbGl0aWVzLlBpdm90RGF0YShwcm9wcywgIW9wdHMuc3VidG90YWxzID8ge30gOiB7XG4gICAgICAgICAgcm93RW5hYmxlZDogcm93U3VidG90YWxEaXNwbGF5LmVuYWJsZWQsXG4gICAgICAgICAgY29sRW5hYmxlZDogY29sU3VidG90YWxEaXNwbGF5LmVuYWJsZWQsXG4gICAgICAgICAgcm93UGFydGlhbE9uVG9wOiByb3dTdWJ0b3RhbERpc3BsYXkuZGlzcGxheU9uVG9wLFxuICAgICAgICAgIGNvbFBhcnRpYWxPblRvcDogY29sU3VidG90YWxEaXNwbGF5LmRpc3BsYXlPblRvcFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJvd0tleXMgPSBwaXZvdERhdGEuZ2V0Um93S2V5cygpO1xuICAgICAgICB2YXIgY29sS2V5cyA9IHBpdm90RGF0YS5nZXRDb2xLZXlzKCk7XG5cbiAgICAgICAgLy8gQWxzbyBwcmUtY2FsY3VsYXRlIGFsbCB0aGUgY2FsbGJhY2tzIGZvciBjZWxscywgZXRjLi4uIFRoaXMgaXMgbmljZSB0byBoYXZlIHRvXG4gICAgICAgIC8vIGF2b2lkIHJlLWNhbGN1bGF0aW9ucyBvZiB0aGUgY2FsbC1iYWNrcyBvbiBjZWxsIGV4cGFuc2lvbnMsIGV0Yy4uLlxuICAgICAgICB2YXIgY2VsbENhbGxiYWNrcyA9IHt9O1xuICAgICAgICB2YXIgcm93VG90YWxDYWxsYmFja3MgPSB7fTtcbiAgICAgICAgdmFyIGNvbFRvdGFsQ2FsbGJhY2tzID0ge307XG4gICAgICAgIHZhciBncmFuZFRvdGFsQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBpZiAodGFibGVPcHRpb25zLmNsaWNrQ2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHJvd0tleXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciByb3dLZXkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICB2YXIgZmxhdFJvd0tleSA9ICgwLCBfVXRpbGl0aWVzLmZsYXRLZXkpKHJvd0tleSk7XG4gICAgICAgICAgICAgIGlmICghKGZsYXRSb3dLZXkgaW4gY2VsbENhbGxiYWNrcykpIHtcbiAgICAgICAgICAgICAgICBjZWxsQ2FsbGJhY2tzW2ZsYXRSb3dLZXldID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IGNvbEtleXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfY29sS2V5ID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICBjZWxsQ2FsbGJhY2tzW2ZsYXRSb3dLZXldWygwLCBfVXRpbGl0aWVzLmZsYXRLZXkpKF9jb2xLZXkpXSA9IHRoaXMuY2xpY2tIYW5kbGVyKHBpdm90RGF0YSwgcm93S2V5LCBfY29sS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgaW4gdG90YWxzIGFzIHdlbGwuXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJvd1RvdGFscykge1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSByb3dLZXlzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yb3dLZXkgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgICAgICByb3dUb3RhbENhbGxiYWNrc1soMCwgX1V0aWxpdGllcy5mbGF0S2V5KShfcm93S2V5KV0gPSB0aGlzLmNsaWNrSGFuZGxlcihwaXZvdERhdGEsIF9yb3dLZXksIFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29sVG90YWxzKSB7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGNvbEtleXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sS2V5ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgY29sVG90YWxDYWxsYmFja3NbKDAsIF9VdGlsaXRpZXMuZmxhdEtleSkoY29sS2V5KV0gPSB0aGlzLmNsaWNrSGFuZGxlcihwaXZvdERhdGEsIFtdLCBjb2xLZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb3dUb3RhbHMgJiYgY29sVG90YWxzKSB7XG4gICAgICAgICAgICBncmFuZFRvdGFsQ2FsbGJhY2sgPSB0aGlzLmNsaWNrSGFuZGxlcihwaXZvdERhdGEsIFtdLCBbXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHBpdm90RGF0YTogcGl2b3REYXRhLFxuICAgICAgICAgIGNvbEF0dHJzOiBjb2xBdHRycyxcbiAgICAgICAgICByb3dBdHRyczogcm93QXR0cnMsXG4gICAgICAgICAgY29sS2V5czogY29sS2V5cyxcbiAgICAgICAgICByb3dLZXlzOiByb3dLZXlzLFxuICAgICAgICAgIHJvd1RvdGFsczogcm93VG90YWxzLFxuICAgICAgICAgIGNvbFRvdGFsczogY29sVG90YWxzLFxuICAgICAgICAgIGFycm93Q29sbGFwc2VkOiBzdWJ0b3RhbE9wdGlvbnMuYXJyb3dDb2xsYXBzZWQsXG4gICAgICAgICAgYXJyb3dFeHBhbmRlZDogc3VidG90YWxPcHRpb25zLmFycm93RXhwYW5kZWQsXG4gICAgICAgICAgY29sU3VidG90YWxEaXNwbGF5OiBjb2xTdWJ0b3RhbERpc3BsYXksXG4gICAgICAgICAgcm93U3VidG90YWxEaXNwbGF5OiByb3dTdWJ0b3RhbERpc3BsYXksXG4gICAgICAgICAgY2VsbENhbGxiYWNrczogY2VsbENhbGxiYWNrcyxcbiAgICAgICAgICByb3dUb3RhbENhbGxiYWNrczogcm93VG90YWxDYWxsYmFja3MsXG4gICAgICAgICAgY29sVG90YWxDYWxsYmFja3M6IGNvbFRvdGFsQ2FsbGJhY2tzLFxuICAgICAgICAgIGdyYW5kVG90YWxDYWxsYmFjazogZ3JhbmRUb3RhbENhbGxiYWNrLFxuICAgICAgICAgIG5hbWVzTWFwcGluZzogbmFtZXNNYXBwaW5nXG4gICAgICAgIH0sIFRhYmxlUmVuZGVyZXIuaGVhdG1hcE1hcHBlcnMocGl2b3REYXRhLCBwcm9wcy50YWJsZUNvbG9yU2NhbGVHZW5lcmF0b3IsIGNvbFRvdGFscywgcm93VG90YWxzKSwgVGFibGVSZW5kZXJlci5iYXJjaGFydE1hcHBlcihwaXZvdERhdGEsIHByb3BzLmJhclNjYWxlR2VuZXJhdG9yLCBjb2xUb3RhbHMsIHJvd1RvdGFscykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NsaWNrSGFuZGxlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xpY2tIYW5kbGVyKHBpdm90RGF0YSwgcm93VmFsdWVzLCBjb2xWYWx1ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNvbEF0dHJzID0gdGhpcy5wcm9wcy5jb2xzO1xuICAgICAgICB2YXIgcm93QXR0cnMgPSB0aGlzLnByb3BzLnJvd3M7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBpdm90RGF0YS5nZXRBZ2dyZWdhdG9yKHJvd1ZhbHVlcywgY29sVmFsdWVzKS52YWx1ZSgpO1xuICAgICAgICB2YXIgZmlsdGVycyA9IHt9O1xuICAgICAgICB2YXIgY29sTGltaXQgPSBNYXRoLm1pbihjb2xBdHRycy5sZW5ndGgsIGNvbFZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbExpbWl0OyBpKyspIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IGNvbEF0dHJzW2ldO1xuICAgICAgICAgIGlmIChjb2xWYWx1ZXNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbHRlcnNbYXR0cl0gPSBjb2xWYWx1ZXNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByb3dMaW1pdCA9IE1hdGgubWluKHJvd0F0dHJzLmxlbmd0aCwgcm93VmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCByb3dMaW1pdDsgX2krKykge1xuICAgICAgICAgIHZhciBfYXR0ciA9IHJvd0F0dHJzW19pXTtcbiAgICAgICAgICBpZiAocm93VmFsdWVzW19pXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmlsdGVyc1tfYXR0cl0gPSByb3dWYWx1ZXNbX2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnByb3BzLnRhYmxlT3B0aW9ucy5jbGlja0NhbGxiYWNrKGUsIHZhbHVlLCBmaWx0ZXJzLCBwaXZvdERhdGEpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NsaWNrSGVhZGVySGFuZGxlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xpY2tIZWFkZXJIYW5kbGVyKHBpdm90RGF0YSwgdmFsdWVzLCBhdHRycywgYXR0cklkeCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGlzU3VidG90YWwgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IGZhbHNlO1xuICAgICAgICB2YXIgaXNHcmFuZFRvdGFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBmYWxzZTtcblxuICAgICAgICB2YXIgZmlsdGVycyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBhdHRySWR4OyBpKyspIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgICAgICAgIGZpbHRlcnNbYXR0cl0gPSB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIHZhbHVlc1thdHRySWR4XSwgZmlsdGVycywgcGl2b3REYXRhLCBpc1N1YnRvdGFsLCBpc0dyYW5kVG90YWwpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NvbGxhcHNlQXR0cicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29sbGFwc2VBdHRyKHJvd09yQ29sLCBhdHRySWR4LCBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIENvbGxhcHNlIGFuIGVudGlyZSBhdHRyaWJ1dGUuXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB2YXIga2V5TGVuID0gYXR0cklkeCArIDE7XG4gICAgICAgICAgdmFyIGNvbGxhcHNlZCA9IGFsbEtleXMuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gay5sZW5ndGggPT09IGtleUxlbjtcbiAgICAgICAgICB9KS5tYXAoX1V0aWxpdGllcy5mbGF0S2V5KTtcblxuICAgICAgICAgIHZhciB1cGRhdGVzID0ge307XG4gICAgICAgICAgY29sbGFwc2VkLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHVwZGF0ZXNba10gPSB0cnVlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHJvd09yQ29sKSB7XG4gICAgICAgICAgICBfdGhpczMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29sbGFwc2VkUm93czogT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuY29sbGFwc2VkUm93cywgdXBkYXRlcylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29sbGFwc2VkQ29sczogT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuY29sbGFwc2VkQ29scywgdXBkYXRlcylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdleHBhbmRBdHRyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmRBdHRyKHJvd09yQ29sLCBhdHRySWR4LCBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIEV4cGFuZCBhbiBlbnRpcmUgYXR0cmlidXRlLiBUaGlzIGltcGxpY2l0bHkgaW1wbGllcyBleHBhbmRpbmcgYWxsIG9mIHRoZVxuICAgICAgICAgIC8vIHBhcmVudHMgYXMgd2VsbC4gSXQncyBhIGJpdCBpbmVmZmljaWVudCBidXQgYWggd2VsbC4uLlxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgdmFyIHVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICBhbGxLZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGF0dHJJZHg7IGkrKykge1xuICAgICAgICAgICAgICB1cGRhdGVzWygwLCBfVXRpbGl0aWVzLmZsYXRLZXkpKGsuc2xpY2UoMCwgaSArIDEpKV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChyb3dPckNvbCkge1xuICAgICAgICAgICAgX3RoaXM0LnNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbGxhcHNlZFJvd3M6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmNvbGxhcHNlZFJvd3MsIHVwZGF0ZXMpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXM0LnNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbGxhcHNlZENvbHM6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmNvbGxhcHNlZENvbHMsIHVwZGF0ZXMpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAndG9nZ2xlUm93S2V5JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVSb3dLZXkoZmxhdFJvd0tleSkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIF90aGlzNS5zZXRTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGNvbGxhcHNlZFJvd3M6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmNvbGxhcHNlZFJvd3MsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgZmxhdFJvd0tleSwgIXN0YXRlLmNvbGxhcHNlZFJvd3NbZmxhdFJvd0tleV0pKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b2dnbGVDb2xLZXknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZUNvbEtleShmbGF0Q29sS2V5KSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgX3RoaXM2LnNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgY29sbGFwc2VkQ29sczogT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuY29sbGFwc2VkQ29scywgX2RlZmluZVByb3BlcnR5KHt9LCBmbGF0Q29sS2V5LCAhc3RhdGUuY29sbGFwc2VkQ29sc1tmbGF0Q29sS2V5XSkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NhbGNBdHRyU3BhbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNBdHRyU3BhbnMoYXR0ckFyciwgbnVtQXR0cnMpIHtcbiAgICAgICAgLy8gR2l2ZW4gYW4gYXJyYXkgb2YgYXR0cmlidXRlIHZhbHVlcyAoaS5lLiBlYWNoIGVsZW1lbnQgaXMgYW5vdGhlciBhcnJheSB3aXRoXG4gICAgICAgIC8vIHRoZSB2YWx1ZSBhdCBldmVyeSBsZXZlbCksIGNvbXB1dGUgdGhlIHNwYW5zIGZvciBldmVyeSBhdHRyaWJ1dGUgdmFsdWUgYXRcbiAgICAgICAgLy8gZXZlcnkgbGV2ZWwuIFRoZSByZXR1cm4gdmFsdWUgaXMgYSBuZXN0ZWQgYXJyYXkgb2YgdGhlIHNhbWUgc2hhcGUuIEl0IGhhc1xuICAgICAgICAvLyAtMSdzIGZvciByZXBlYXRlZCB2YWx1ZXMgYW5kIHRoZSBzcGFuIG51bWJlciBvdGhlcndpc2UuXG5cbiAgICAgICAgdmFyIHNwYW5zID0gW107XG4gICAgICAgIC8vIEluZGV4IG9mIHRoZSBsYXN0IG5ldyB2YWx1ZVxuICAgICAgICB2YXIgbGkgPSBBcnJheShudW1BdHRycykubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsdiA9IEFycmF5KG51bUF0dHJzKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gS2VlcCBpbmNyZWFzaW5nIHNwYW4gdmFsdWVzIGFzIGxvbmcgYXMgdGhlIGxhc3Qga2V5cyBhcmUgdGhlIHNhbWUuIEZvclxuICAgICAgICAgIC8vIHRoZSByZXN0LCByZWNvcmQgc3BhbnMgb2YgMS4gVXBkYXRlIHRoZSBpbmRpY2VzIHRvby5cbiAgICAgICAgICB2YXIgY3YgPSBhdHRyQXJyW2ldO1xuICAgICAgICAgIHZhciBlbnQgPSBbXTtcbiAgICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICAgIHZhciBsaW1pdCA9IE1hdGgubWluKGx2Lmxlbmd0aCwgY3YubGVuZ3RoKTtcbiAgICAgICAgICB3aGlsZSAoZGVwdGggPCBsaW1pdCAmJiBsdltkZXB0aF0gPT09IGN2W2RlcHRoXSkge1xuICAgICAgICAgICAgZW50LnB1c2goLTEpO1xuICAgICAgICAgICAgc3BhbnNbbGlbZGVwdGhdXVtkZXB0aF0rKztcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChkZXB0aCA8IGN2Lmxlbmd0aCkge1xuICAgICAgICAgICAgbGlbZGVwdGhdID0gaTtcbiAgICAgICAgICAgIGVudC5wdXNoKDEpO1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3BhbnMucHVzaChlbnQpO1xuICAgICAgICAgIGx2ID0gY3Y7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW5zO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbmRlckNvbEhlYWRlclJvdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ29sSGVhZGVyUm93KGF0dHJOYW1lLCBhdHRySWR4LCBwaXZvdFNldHRpbmdzKSB7XG4gICAgICAgIC8vIFJlbmRlciBhIHNpbmdsZSByb3cgaW4gdGhlIGNvbHVtbiBoZWFkZXIgYXQgdGhlIHRvcCBvZiB0aGUgcGl2b3QgdGFibGUuXG5cbiAgICAgICAgdmFyIHJvd0F0dHJzID0gcGl2b3RTZXR0aW5ncy5yb3dBdHRycyxcbiAgICAgICAgICAgIGNvbEF0dHJzID0gcGl2b3RTZXR0aW5ncy5jb2xBdHRycyxcbiAgICAgICAgICAgIGNvbEtleXMgPSBwaXZvdFNldHRpbmdzLmNvbEtleXMsXG4gICAgICAgICAgICB2aXNpYmxlQ29sS2V5cyA9IHBpdm90U2V0dGluZ3MudmlzaWJsZUNvbEtleXMsXG4gICAgICAgICAgICBjb2xBdHRyU3BhbnMgPSBwaXZvdFNldHRpbmdzLmNvbEF0dHJTcGFucyxcbiAgICAgICAgICAgIHJvd1RvdGFscyA9IHBpdm90U2V0dGluZ3Mucm93VG90YWxzLFxuICAgICAgICAgICAgYXJyb3dFeHBhbmRlZCA9IHBpdm90U2V0dGluZ3MuYXJyb3dFeHBhbmRlZCxcbiAgICAgICAgICAgIGFycm93Q29sbGFwc2VkID0gcGl2b3RTZXR0aW5ncy5hcnJvd0NvbGxhcHNlZCxcbiAgICAgICAgICAgIGNvbFN1YnRvdGFsRGlzcGxheSA9IHBpdm90U2V0dGluZ3MuY29sU3VidG90YWxEaXNwbGF5LFxuICAgICAgICAgICAgbWF4Q29sVmlzaWJsZSA9IHBpdm90U2V0dGluZ3MubWF4Q29sVmlzaWJsZSxcbiAgICAgICAgICAgIHBpdm90RGF0YSA9IHBpdm90U2V0dGluZ3MucGl2b3REYXRhLFxuICAgICAgICAgICAgbmFtZXNNYXBwaW5nID0gcGl2b3RTZXR0aW5ncy5uYW1lc01hcHBpbmc7XG4gICAgICAgIHZhciBfcHJvcHMkdGFibGVPcHRpb25zID0gdGhpcy5wcm9wcy50YWJsZU9wdGlvbnMsXG4gICAgICAgICAgICBoaWdobGlnaHRIZWFkZXJDZWxsc09uSG92ZXIgPSBfcHJvcHMkdGFibGVPcHRpb25zLmhpZ2hsaWdodEhlYWRlckNlbGxzT25Ib3ZlcixcbiAgICAgICAgICAgIF9wcm9wcyR0YWJsZU9wdGlvbnMkbyA9IF9wcm9wcyR0YWJsZU9wdGlvbnMub21pdHRlZEhpZ2hsaWdodEhlYWRlckdyb3VwcyxcbiAgICAgICAgICAgIG9taXR0ZWRIaWdobGlnaHRIZWFkZXJHcm91cHMgPSBfcHJvcHMkdGFibGVPcHRpb25zJG8gPT09IHVuZGVmaW5lZCA/IFtdIDogX3Byb3BzJHRhYmxlT3B0aW9ucyRvLFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZWRIZWFkZXJDZWxscyA9IF9wcm9wcyR0YWJsZU9wdGlvbnMuaGlnaGxpZ2h0ZWRIZWFkZXJDZWxscyxcbiAgICAgICAgICAgIGRhdGVGb3JtYXR0ZXJzID0gX3Byb3BzJHRhYmxlT3B0aW9ucy5kYXRlRm9ybWF0dGVycztcblxuXG4gICAgICAgIHZhciBzcGFjZUNlbGwgPSBhdHRySWR4ID09PSAwICYmIHJvd0F0dHJzLmxlbmd0aCAhPT0gMCA/IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCd0aCcsIHtcbiAgICAgICAgICBrZXk6ICdwYWRkaW5nJyxcbiAgICAgICAgICBjb2xTcGFuOiByb3dBdHRycy5sZW5ndGgsXG4gICAgICAgICAgcm93U3BhbjogY29sQXR0cnMubGVuZ3RoXG4gICAgICAgIH0pIDogbnVsbDtcblxuICAgICAgICB2YXIgbmVlZFRvZ2dsZSA9IG9wdHMuc3VidG90YWxzICYmIGNvbFN1YnRvdGFsRGlzcGxheS5lbmFibGVkICYmIGF0dHJJZHggIT09IGNvbEF0dHJzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBhcnJvd0NsaWNrSGFuZGxlID0gbnVsbDtcbiAgICAgICAgdmFyIHN1YkFycm93ID0gbnVsbDtcbiAgICAgICAgaWYgKG5lZWRUb2dnbGUpIHtcbiAgICAgICAgICBhcnJvd0NsaWNrSGFuZGxlID0gYXR0cklkeCArIDEgPCBtYXhDb2xWaXNpYmxlID8gdGhpcy5jb2xsYXBzZUF0dHIoZmFsc2UsIGF0dHJJZHgsIGNvbEtleXMpIDogdGhpcy5leHBhbmRBdHRyKGZhbHNlLCBhdHRySWR4LCBjb2xLZXlzKTtcbiAgICAgICAgICBzdWJBcnJvdyA9IGF0dHJJZHggKyAxIDwgbWF4Q29sVmlzaWJsZSA/IGFycm93RXhwYW5kZWQgOiBhcnJvd0NvbGxhcHNlZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0ck5hbWVDZWxsID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RoJyxcbiAgICAgICAgICB7IGtleTogJ2xhYmVsJywgY2xhc3NOYW1lOiAncHZ0QXhpc0xhYmVsJyB9LFxuICAgICAgICAgIGRpc3BsYXlIZWFkZXJDZWxsKG5lZWRUb2dnbGUsIHN1YkFycm93LCBhcnJvd0NsaWNrSGFuZGxlLCBhdHRyTmFtZSwgbmFtZXNNYXBwaW5nKVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBhdHRyVmFsdWVDZWxscyA9IFtdO1xuICAgICAgICB2YXIgcm93SW5jclNwYW4gPSByb3dBdHRycy5sZW5ndGggIT09IDAgPyAxIDogMDtcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGNvbHVtbnMuIEp1bXAgb3ZlciBkdXBsaWNhdGUgdmFsdWVzLlxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdmlzaWJsZUNvbEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNvbEtleSA9IHZpc2libGVDb2xLZXlzW2ldO1xuICAgICAgICAgIHZhciBjb2xTcGFuID0gYXR0cklkeCA8IGNvbEtleS5sZW5ndGggPyBjb2xBdHRyU3BhbnNbaV1bYXR0cklkeF0gOiAxO1xuICAgICAgICAgIHZhciBjb2xMYWJlbENsYXNzID0gJ3B2dENvbExhYmVsJztcbiAgICAgICAgICBpZiAoYXR0cklkeCA8IGNvbEtleS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoaWdobGlnaHRIZWFkZXJDZWxsc09uSG92ZXIgJiYgIW9taXR0ZWRIaWdobGlnaHRIZWFkZXJHcm91cHMuaW5jbHVkZXMoY29sQXR0cnNbYXR0cklkeF0pKSB7XG4gICAgICAgICAgICAgIGNvbExhYmVsQ2xhc3MgKz0gJyBob3ZlcmFibGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhpZ2hsaWdodGVkSGVhZGVyQ2VsbHMgJiYgQXJyYXkuaXNBcnJheShoaWdobGlnaHRlZEhlYWRlckNlbGxzW2NvbEF0dHJzW2F0dHJJZHhdXSkgJiYgaGlnaGxpZ2h0ZWRIZWFkZXJDZWxsc1tjb2xBdHRyc1thdHRySWR4XV0uaW5jbHVkZXMoY29sS2V5W2F0dHJJZHhdKSkge1xuICAgICAgICAgICAgICBjb2xMYWJlbENsYXNzICs9ICcgYWN0aXZlJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJvd1NwYW4gPSAxICsgKGF0dHJJZHggPT09IGNvbEF0dHJzLmxlbmd0aCAtIDEgPyByb3dJbmNyU3BhbiA6IDApO1xuICAgICAgICAgICAgdmFyIGZsYXRDb2xLZXkgPSAoMCwgX1V0aWxpdGllcy5mbGF0S2V5KShjb2xLZXkuc2xpY2UoMCwgYXR0cklkeCArIDEpKTtcbiAgICAgICAgICAgIHZhciBvbkFycm93Q2xpY2sgPSBuZWVkVG9nZ2xlID8gdGhpcy50b2dnbGVDb2xLZXkoZmxhdENvbEtleSkgOiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVyQ2VsbEZvcm1hdHRlZFZhbHVlID0gZGF0ZUZvcm1hdHRlcnMgJiYgZGF0ZUZvcm1hdHRlcnNbYXR0ck5hbWVdICYmIHR5cGVvZiBkYXRlRm9ybWF0dGVyc1thdHRyTmFtZV0gPT09ICdmdW5jdGlvbicgPyBkYXRlRm9ybWF0dGVyc1thdHRyTmFtZV0oY29sS2V5W2F0dHJJZHhdKSA6IGNvbEtleVthdHRySWR4XTtcbiAgICAgICAgICAgIGF0dHJWYWx1ZUNlbGxzLnB1c2goX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICd0aCcsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNvbExhYmVsQ2xhc3MsXG4gICAgICAgICAgICAgICAga2V5OiAnY29sS2V5LScgKyBmbGF0Q29sS2V5LFxuICAgICAgICAgICAgICAgIGNvbFNwYW46IGNvbFNwYW4sXG4gICAgICAgICAgICAgICAgcm93U3Bhbjogcm93U3BhbixcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLmNsaWNrSGVhZGVySGFuZGxlcihwaXZvdERhdGEsIGNvbEtleSwgdGhpcy5wcm9wcy5jb2xzLCBhdHRySWR4LCB0aGlzLnByb3BzLnRhYmxlT3B0aW9ucy5jbGlja0NvbHVtbkhlYWRlckNhbGxiYWNrKVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkaXNwbGF5SGVhZGVyQ2VsbChuZWVkVG9nZ2xlLCB0aGlzLnN0YXRlLmNvbGxhcHNlZENvbHNbZmxhdENvbEtleV0gPyBhcnJvd0NvbGxhcHNlZCA6IGFycm93RXhwYW5kZWQsIG9uQXJyb3dDbGljaywgaGVhZGVyQ2VsbEZvcm1hdHRlZFZhbHVlLCBuYW1lc01hcHBpbmcpXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJJZHggPT09IGNvbEtleS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBfcm93U3BhbiA9IGNvbEF0dHJzLmxlbmd0aCAtIGNvbEtleS5sZW5ndGggKyByb3dJbmNyU3BhbjtcbiAgICAgICAgICAgIGF0dHJWYWx1ZUNlbGxzLnB1c2goX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICd0aCcsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNvbExhYmVsQ2xhc3MgKyAnIHB2dFN1YnRvdGFsTGFiZWwnLFxuICAgICAgICAgICAgICAgIGtleTogJ2NvbEtleUJ1ZmZlci0nICsgKDAsIF9VdGlsaXRpZXMuZmxhdEtleSkoY29sS2V5KSxcbiAgICAgICAgICAgICAgICBjb2xTcGFuOiBjb2xTcGFuLFxuICAgICAgICAgICAgICAgIHJvd1NwYW46IF9yb3dTcGFuLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuY2xpY2tIZWFkZXJIYW5kbGVyKHBpdm90RGF0YSwgY29sS2V5LCB0aGlzLnByb3BzLmNvbHMsIGF0dHJJZHgsIHRoaXMucHJvcHMudGFibGVPcHRpb25zLmNsaWNrQ29sdW1uSGVhZGVyQ2FsbGJhY2ssIHRydWUpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICdTdWJ0b3RhbCdcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgbmV4dCBjb2xTcGFuIGNvbHVtbnMgd2lsbCBoYXZlIHRoZSBzYW1lIHZhbHVlIGFueXdheS4uLlxuICAgICAgICAgIGkgPSBpICsgY29sU3BhbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbENlbGwgPSBhdHRySWR4ID09PSAwICYmIHJvd1RvdGFscyA/IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0aCcsXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiAndG90YWwnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAncHZ0VG90YWxMYWJlbCcsXG4gICAgICAgICAgICByb3dTcGFuOiBjb2xBdHRycy5sZW5ndGggKyBNYXRoLm1pbihyb3dBdHRycy5sZW5ndGgsIDEpLFxuICAgICAgICAgICAgb25DbGljazogdGhpcy5jbGlja0hlYWRlckhhbmRsZXIocGl2b3REYXRhLCBbXSwgdGhpcy5wcm9wcy5jb2xzLCBhdHRySWR4LCB0aGlzLnByb3BzLnRhYmxlT3B0aW9ucy5jbGlja0NvbHVtbkhlYWRlckNhbGxiYWNrLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgICdUb3RhbCAoJyArIHRoaXMucHJvcHMuYWdncmVnYXRvck5hbWUgKyAnKSdcbiAgICAgICAgKSA6IG51bGw7XG5cbiAgICAgICAgdmFyIGNlbGxzID0gW3NwYWNlQ2VsbCwgYXR0ck5hbWVDZWxsXS5jb25jYXQoYXR0clZhbHVlQ2VsbHMsIFt0b3RhbENlbGxdKTtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0cicsXG4gICAgICAgICAgeyBrZXk6ICdjb2xBdHRyLScgKyBhdHRySWR4IH0sXG4gICAgICAgICAgY2VsbHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW5kZXJSb3dIZWFkZXJSb3cnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclJvd0hlYWRlclJvdyhwaXZvdFNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIC8vIFJlbmRlciBqdXN0IHRoZSBhdHRyaWJ1dGUgbmFtZXMgb2YgdGhlIHJvd3MgKHRoZSBhY3R1YWwgYXR0cmlidXRlIHZhbHVlc1xuICAgICAgICAvLyB3aWxsIHNob3cgdXAgaW4gdGhlIGluZGl2aWR1YWwgcm93cykuXG5cbiAgICAgICAgdmFyIHJvd0F0dHJzID0gcGl2b3RTZXR0aW5ncy5yb3dBdHRycyxcbiAgICAgICAgICAgIGNvbEF0dHJzID0gcGl2b3RTZXR0aW5ncy5jb2xBdHRycyxcbiAgICAgICAgICAgIHJvd0tleXMgPSBwaXZvdFNldHRpbmdzLnJvd0tleXMsXG4gICAgICAgICAgICBhcnJvd0NvbGxhcHNlZCA9IHBpdm90U2V0dGluZ3MuYXJyb3dDb2xsYXBzZWQsXG4gICAgICAgICAgICBhcnJvd0V4cGFuZGVkID0gcGl2b3RTZXR0aW5ncy5hcnJvd0V4cGFuZGVkLFxuICAgICAgICAgICAgcm93U3VidG90YWxEaXNwbGF5ID0gcGl2b3RTZXR0aW5ncy5yb3dTdWJ0b3RhbERpc3BsYXksXG4gICAgICAgICAgICBtYXhSb3dWaXNpYmxlID0gcGl2b3RTZXR0aW5ncy5tYXhSb3dWaXNpYmxlLFxuICAgICAgICAgICAgcGl2b3REYXRhID0gcGl2b3RTZXR0aW5ncy5waXZvdERhdGEsXG4gICAgICAgICAgICBuYW1lc01hcHBpbmcgPSBwaXZvdFNldHRpbmdzLm5hbWVzTWFwcGluZztcblxuICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RyJyxcbiAgICAgICAgICB7IGtleTogJ3Jvd0hkcicgfSxcbiAgICAgICAgICByb3dBdHRycy5tYXAoZnVuY3Rpb24gKHIsIGkpIHtcbiAgICAgICAgICAgIHZhciBuZWVkTGFiZWxUb2dnbGUgPSBvcHRzLnN1YnRvdGFscyAmJiByb3dTdWJ0b3RhbERpc3BsYXkuZW5hYmxlZCAmJiBpICE9PSByb3dBdHRycy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIGFycm93Q2xpY2tIYW5kbGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHN1YkFycm93ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChuZWVkTGFiZWxUb2dnbGUpIHtcbiAgICAgICAgICAgICAgYXJyb3dDbGlja0hhbmRsZSA9IGkgKyAxIDwgbWF4Um93VmlzaWJsZSA/IF90aGlzNy5jb2xsYXBzZUF0dHIodHJ1ZSwgaSwgcm93S2V5cykgOiBfdGhpczcuZXhwYW5kQXR0cih0cnVlLCBpLCByb3dLZXlzKTtcbiAgICAgICAgICAgICAgc3ViQXJyb3cgPSBpICsgMSA8IG1heFJvd1Zpc2libGUgPyBhcnJvd0V4cGFuZGVkIDogYXJyb3dDb2xsYXBzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICd0aCcsXG4gICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiAncHZ0QXhpc0xhYmVsJywga2V5OiAncm93QXR0ci0nICsgaSB9LFxuICAgICAgICAgICAgICBkaXNwbGF5SGVhZGVyQ2VsbChuZWVkTGFiZWxUb2dnbGUsIHN1YkFycm93LCBhcnJvd0NsaWNrSGFuZGxlLCByLCBuYW1lc01hcHBpbmcpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3RoJyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAncHZ0VG90YWxMYWJlbCcsXG4gICAgICAgICAgICAgIGtleTogJ3BhZGRpbmcnLFxuICAgICAgICAgICAgICBvbkNsaWNrOiB0aGlzLmNsaWNrSGVhZGVySGFuZGxlcihwaXZvdERhdGEsIFtdLCB0aGlzLnByb3BzLnJvd3MsIDAsIHRoaXMucHJvcHMudGFibGVPcHRpb25zLmNsaWNrUm93SGVhZGVyQ2FsbGJhY2ssIGZhbHNlLCB0cnVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbEF0dHJzLmxlbmd0aCA9PT0gMCA/ICdUb3RhbCAoJyArIHRoaXMucHJvcHMuYWdncmVnYXRvck5hbWUgKyAnKScgOiBudWxsXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbmRlclRhYmxlUm93JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUYWJsZVJvdyhyb3dLZXksIHJvd0lkeCwgcGl2b3RTZXR0aW5ncykge1xuICAgICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgICAvLyBSZW5kZXIgYSBzaW5nbGUgcm93IGluIHRoZSBwaXZvdCB0YWJsZS5cblxuICAgICAgICB2YXIgcm93QXR0cnMgPSBwaXZvdFNldHRpbmdzLnJvd0F0dHJzLFxuICAgICAgICAgICAgY29sQXR0cnMgPSBwaXZvdFNldHRpbmdzLmNvbEF0dHJzLFxuICAgICAgICAgICAgcm93QXR0clNwYW5zID0gcGl2b3RTZXR0aW5ncy5yb3dBdHRyU3BhbnMsXG4gICAgICAgICAgICB2aXNpYmxlQ29sS2V5cyA9IHBpdm90U2V0dGluZ3MudmlzaWJsZUNvbEtleXMsXG4gICAgICAgICAgICBwaXZvdERhdGEgPSBwaXZvdFNldHRpbmdzLnBpdm90RGF0YSxcbiAgICAgICAgICAgIHJvd1RvdGFscyA9IHBpdm90U2V0dGluZ3Mucm93VG90YWxzLFxuICAgICAgICAgICAgcm93U3VidG90YWxEaXNwbGF5ID0gcGl2b3RTZXR0aW5ncy5yb3dTdWJ0b3RhbERpc3BsYXksXG4gICAgICAgICAgICB2YWx1ZUNlbGxDb2xvcnMgPSBwaXZvdFNldHRpbmdzLnZhbHVlQ2VsbENvbG9ycyxcbiAgICAgICAgICAgIGNlbGxTdHlsZSA9IHBpdm90U2V0dGluZ3MuY2VsbFN0eWxlLFxuICAgICAgICAgICAgdmFsdWVDZWxsQmFyID0gcGl2b3RTZXR0aW5ncy52YWx1ZUNlbGxCYXIsXG4gICAgICAgICAgICBhcnJvd0V4cGFuZGVkID0gcGl2b3RTZXR0aW5ncy5hcnJvd0V4cGFuZGVkLFxuICAgICAgICAgICAgYXJyb3dDb2xsYXBzZWQgPSBwaXZvdFNldHRpbmdzLmFycm93Q29sbGFwc2VkLFxuICAgICAgICAgICAgY2VsbENhbGxiYWNrcyA9IHBpdm90U2V0dGluZ3MuY2VsbENhbGxiYWNrcyxcbiAgICAgICAgICAgIHJvd1RvdGFsQ2FsbGJhY2tzID0gcGl2b3RTZXR0aW5ncy5yb3dUb3RhbENhbGxiYWNrcyxcbiAgICAgICAgICAgIG5hbWVzTWFwcGluZyA9IHBpdm90U2V0dGluZ3MubmFtZXNNYXBwaW5nO1xuICAgICAgICB2YXIgX3Byb3BzJHRhYmxlT3B0aW9uczIgPSB0aGlzLnByb3BzLnRhYmxlT3B0aW9ucyxcbiAgICAgICAgICAgIGhpZ2hsaWdodEhlYWRlckNlbGxzT25Ib3ZlciA9IF9wcm9wcyR0YWJsZU9wdGlvbnMyLmhpZ2hsaWdodEhlYWRlckNlbGxzT25Ib3ZlcixcbiAgICAgICAgICAgIF9wcm9wcyR0YWJsZU9wdGlvbnMyJCA9IF9wcm9wcyR0YWJsZU9wdGlvbnMyLm9taXR0ZWRIaWdobGlnaHRIZWFkZXJHcm91cHMsXG4gICAgICAgICAgICBvbWl0dGVkSGlnaGxpZ2h0SGVhZGVyR3JvdXBzID0gX3Byb3BzJHRhYmxlT3B0aW9uczIkID09PSB1bmRlZmluZWQgPyBbXSA6IF9wcm9wcyR0YWJsZU9wdGlvbnMyJCxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkSGVhZGVyQ2VsbHMgPSBfcHJvcHMkdGFibGVPcHRpb25zMi5oaWdobGlnaHRlZEhlYWRlckNlbGxzLFxuICAgICAgICAgICAgY2VsbENvbG9yRm9ybWF0dGVycyA9IF9wcm9wcyR0YWJsZU9wdGlvbnMyLmNlbGxDb2xvckZvcm1hdHRlcnMsXG4gICAgICAgICAgICBkYXRlRm9ybWF0dGVycyA9IF9wcm9wcyR0YWJsZU9wdGlvbnMyLmRhdGVGb3JtYXR0ZXJzO1xuXG4gICAgICAgIHZhciBmbGF0Um93S2V5ID0gKDAsIF9VdGlsaXRpZXMuZmxhdEtleSkocm93S2V5KTtcblxuICAgICAgICB2YXIgY29sSW5jclNwYW4gPSBjb2xBdHRycy5sZW5ndGggIT09IDAgPyAxIDogMDtcbiAgICAgICAgdmFyIGF0dHJWYWx1ZUNlbGxzID0gcm93S2V5Lm1hcChmdW5jdGlvbiAociwgaSkge1xuICAgICAgICAgIHZhciB2YWx1ZUNlbGxDbGFzc05hbWUgPSAncHZ0Um93TGFiZWwnO1xuICAgICAgICAgIGlmIChoaWdobGlnaHRIZWFkZXJDZWxsc09uSG92ZXIgJiYgIW9taXR0ZWRIaWdobGlnaHRIZWFkZXJHcm91cHMuaW5jbHVkZXMocm93QXR0cnNbaV0pKSB7XG4gICAgICAgICAgICB2YWx1ZUNlbGxDbGFzc05hbWUgKz0gJyBob3ZlcmFibGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRIZWFkZXJDZWxscyAmJiBBcnJheS5pc0FycmF5KGhpZ2hsaWdodGVkSGVhZGVyQ2VsbHNbcm93QXR0cnNbaV1dKSAmJiBoaWdobGlnaHRlZEhlYWRlckNlbGxzW3Jvd0F0dHJzW2ldXS5pbmNsdWRlcyhyKSkge1xuICAgICAgICAgICAgdmFsdWVDZWxsQ2xhc3NOYW1lICs9ICcgYWN0aXZlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJvd1NwYW4gPSByb3dBdHRyU3BhbnNbcm93SWR4XVtpXTtcbiAgICAgICAgICBpZiAocm93U3BhbiA+IDApIHtcbiAgICAgICAgICAgIHZhciBfZmxhdFJvd0tleSA9ICgwLCBfVXRpbGl0aWVzLmZsYXRLZXkpKHJvd0tleS5zbGljZSgwLCBpICsgMSkpO1xuICAgICAgICAgICAgdmFyIGNvbFNwYW4gPSAxICsgKGkgPT09IHJvd0F0dHJzLmxlbmd0aCAtIDEgPyBjb2xJbmNyU3BhbiA6IDApO1xuICAgICAgICAgICAgdmFyIG5lZWRSb3dUb2dnbGUgPSBvcHRzLnN1YnRvdGFscyAmJiByb3dTdWJ0b3RhbERpc3BsYXkuZW5hYmxlZCAmJiBpICE9PSByb3dBdHRycy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIG9uQXJyb3dDbGljayA9IG5lZWRSb3dUb2dnbGUgPyBfdGhpczgudG9nZ2xlUm93S2V5KF9mbGF0Um93S2V5KSA6IG51bGw7XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJDZWxsRm9ybWF0dGVkVmFsdWUgPSBkYXRlRm9ybWF0dGVycyAmJiBkYXRlRm9ybWF0dGVyc1tyb3dBdHRyc1tpXV0gPyBkYXRlRm9ybWF0dGVyc1tyb3dBdHRyc1tpXV0ocikgOiByO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAndGgnLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5OiAncm93S2V5TGFiZWwtJyArIGksXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB2YWx1ZUNlbGxDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgcm93U3Bhbjogcm93U3BhbixcbiAgICAgICAgICAgICAgICBjb2xTcGFuOiBjb2xTcGFuLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IF90aGlzOC5jbGlja0hlYWRlckhhbmRsZXIocGl2b3REYXRhLCByb3dLZXksIF90aGlzOC5wcm9wcy5yb3dzLCBpLCBfdGhpczgucHJvcHMudGFibGVPcHRpb25zLmNsaWNrUm93SGVhZGVyQ2FsbGJhY2spXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRpc3BsYXlIZWFkZXJDZWxsKG5lZWRSb3dUb2dnbGUsIF90aGlzOC5zdGF0ZS5jb2xsYXBzZWRSb3dzW19mbGF0Um93S2V5XSA/IGFycm93Q29sbGFwc2VkIDogYXJyb3dFeHBhbmRlZCwgb25BcnJvd0NsaWNrLCBoZWFkZXJDZWxsRm9ybWF0dGVkVmFsdWUsIG5hbWVzTWFwcGluZylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgYXR0clZhbHVlUGFkZGluZ0NlbGwgPSByb3dLZXkubGVuZ3RoIDwgcm93QXR0cnMubGVuZ3RoID8gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RoJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdwdnRSb3dMYWJlbCBwdnRTdWJ0b3RhbExhYmVsJyxcbiAgICAgICAgICAgIGtleTogJ3Jvd0tleUJ1ZmZlcicsXG4gICAgICAgICAgICBjb2xTcGFuOiByb3dBdHRycy5sZW5ndGggLSByb3dLZXkubGVuZ3RoICsgY29sSW5jclNwYW4sXG4gICAgICAgICAgICByb3dTcGFuOiAxLFxuICAgICAgICAgICAgb25DbGljazogdGhpcy5jbGlja0hlYWRlckhhbmRsZXIocGl2b3REYXRhLCByb3dLZXksIHRoaXMucHJvcHMucm93cywgcm93S2V5Lmxlbmd0aCwgdGhpcy5wcm9wcy50YWJsZU9wdGlvbnMuY2xpY2tSb3dIZWFkZXJDYWxsYmFjaywgdHJ1ZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgICdTdWJ0b3RhbCdcbiAgICAgICAgKSA6IG51bGw7XG5cbiAgICAgICAgdmFyIHJvd0NsaWNrSGFuZGxlcnMgPSBjZWxsQ2FsbGJhY2tzW2ZsYXRSb3dLZXldIHx8IHt9O1xuICAgICAgICB2YXIgdmFsdWVDZWxscyA9IHZpc2libGVDb2xLZXlzLm1hcChmdW5jdGlvbiAoY29sS2V5KSB7XG4gICAgICAgICAgdmFyIGZsYXRDb2xLZXkgPSAoMCwgX1V0aWxpdGllcy5mbGF0S2V5KShjb2xLZXkpO1xuICAgICAgICAgIHZhciBhZ2cgPSBwaXZvdERhdGEuZ2V0QWdncmVnYXRvcihyb3dLZXksIGNvbEtleSk7XG4gICAgICAgICAgdmFyIGFnZ1ZhbHVlID0gYWdnLnZhbHVlKCk7XG4gICAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvciA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIga2V5cyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocm93S2V5KSwgX3RvQ29uc3VtYWJsZUFycmF5KGNvbEtleSkpO1xuICAgICAgICAgIGlmIChjZWxsQ29sb3JGb3JtYXR0ZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKGNlbGxDb2xvckZvcm1hdHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGNlbGxDb2xvckZvcm1hdHRlcikge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjZWxsQ29sb3JGb3JtYXR0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3Aoa2V5KSB7XG4gICAgICAgICAgICAgICAgICBjZWxsQ29sb3JGb3JtYXR0ZXIuZmlsdGVyKGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5jb2x1bW4gPT09IGtleTtcbiAgICAgICAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdHRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVyUmVzdWx0ID0gZm9ybWF0dGVyLmdldENvbG9yRnJvbVZhbHVlKGFnZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlclJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IGZvcm1hdHRlclJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYnJlYWsnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSBrZXlzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmV0ID09PSAnYnJlYWsnKSBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjUgPSBlcnI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgJiYgX2l0ZXJhdG9yNS5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I1LnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBhZ2cuaXNTdWJ0b3RhbCA/IHsgZm9udFdlaWdodDogJ2JvbGQnIH0gOiB2YWx1ZUNlbGxDb2xvcnMocm93S2V5LCBjb2xLZXksIGFnZ1ZhbHVlKSwgIWFnZy5pc1N1YnRvdGFsID8geyBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvciB9IDoge30sIGNlbGxTdHlsZSk7XG5cbiAgICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAndGQnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdwdnRWYWwnLFxuICAgICAgICAgICAgICBrZXk6ICdwdnRWYWwtJyArIGZsYXRDb2xLZXksXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IHJvd0NsaWNrSGFuZGxlcnNbZmxhdENvbEtleV0sXG4gICAgICAgICAgICAgIHN0eWxlOiBzdHlsZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFnZy5pc1N1YnRvdGFsID8gYWdnLmZvcm1hdChhZ2dWYWx1ZSkgOiB2YWx1ZUNlbGxCYXIocm93S2V5LCBjb2xLZXksIGFnZ1ZhbHVlLCBhZ2cuZm9ybWF0KGFnZ1ZhbHVlKSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdG90YWxDZWxsID0gbnVsbDtcbiAgICAgICAgaWYgKHJvd1RvdGFscykge1xuICAgICAgICAgIHZhciBhZ2cgPSBwaXZvdERhdGEuZ2V0QWdncmVnYXRvcihyb3dLZXksIFtdKTtcbiAgICAgICAgICB2YXIgYWdnVmFsdWUgPSBhZ2cudmFsdWUoKTtcbiAgICAgICAgICB0b3RhbENlbGwgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICd0ZCcsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtleTogJ3RvdGFsJyxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAncHZ0VG90YWwnLFxuICAgICAgICAgICAgICBvbkNsaWNrOiByb3dUb3RhbENhbGxiYWNrc1tmbGF0Um93S2V5XSxcbiAgICAgICAgICAgICAgc3R5bGU6IGNlbGxTdHlsZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFnZy5mb3JtYXQoYWdnVmFsdWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3dDZWxscyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYXR0clZhbHVlQ2VsbHMpLCBbYXR0clZhbHVlUGFkZGluZ0NlbGxdLCBfdG9Db25zdW1hYmxlQXJyYXkodmFsdWVDZWxscyksIFt0b3RhbENlbGxdKTtcblxuICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RyJyxcbiAgICAgICAgICB7IGtleTogJ2tleVJvdy0nICsgZmxhdFJvd0tleSB9LFxuICAgICAgICAgIHJvd0NlbGxzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncmVuZGVyVG90YWxzUm93JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUb3RhbHNSb3cocGl2b3RTZXR0aW5ncykge1xuICAgICAgICAvLyBSZW5kZXIgdGhlIGZpbmFsIHRvdGFscyByb3dzIHRoYXQgaGFzIHRoZSB0b3RhbHMgZm9yIGFsbCB0aGUgY29sdW1ucy5cblxuICAgICAgICB2YXIgcm93QXR0cnMgPSBwaXZvdFNldHRpbmdzLnJvd0F0dHJzLFxuICAgICAgICAgICAgY29sQXR0cnMgPSBwaXZvdFNldHRpbmdzLmNvbEF0dHJzLFxuICAgICAgICAgICAgdmlzaWJsZUNvbEtleXMgPSBwaXZvdFNldHRpbmdzLnZpc2libGVDb2xLZXlzLFxuICAgICAgICAgICAgcm93VG90YWxzID0gcGl2b3RTZXR0aW5ncy5yb3dUb3RhbHMsXG4gICAgICAgICAgICBwaXZvdERhdGEgPSBwaXZvdFNldHRpbmdzLnBpdm90RGF0YSxcbiAgICAgICAgICAgIGNlbGxTdHlsZSA9IHBpdm90U2V0dGluZ3MuY2VsbFN0eWxlLFxuICAgICAgICAgICAgY29sVG90YWxDYWxsYmFja3MgPSBwaXZvdFNldHRpbmdzLmNvbFRvdGFsQ2FsbGJhY2tzLFxuICAgICAgICAgICAgZ3JhbmRUb3RhbENhbGxiYWNrID0gcGl2b3RTZXR0aW5ncy5ncmFuZFRvdGFsQ2FsbGJhY2s7XG5cblxuICAgICAgICB2YXIgdG90YWxMYWJlbENlbGwgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAndGgnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ2xhYmVsJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3B2dFRvdGFsTGFiZWwgcHZ0Um93VG90YWxMYWJlbCcsXG4gICAgICAgICAgICBjb2xTcGFuOiByb3dBdHRycy5sZW5ndGggKyBNYXRoLm1pbihjb2xBdHRycy5sZW5ndGgsIDEpLFxuICAgICAgICAgICAgb25DbGljazogdGhpcy5jbGlja0hlYWRlckhhbmRsZXIocGl2b3REYXRhLCBbXSwgdGhpcy5wcm9wcy5yb3dzLCAwLCB0aGlzLnByb3BzLnRhYmxlT3B0aW9ucy5jbGlja1Jvd0hlYWRlckNhbGxiYWNrLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgICdUb3RhbCAoJyArIHRoaXMucHJvcHMuYWdncmVnYXRvck5hbWUgKyAnKSdcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgdG90YWxWYWx1ZVN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgY2VsbFN0eWxlLCB7XG4gICAgICAgICAgcGFkZGluZzogJzVweCdcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0b3RhbFZhbHVlQ2VsbHMgPSB2aXNpYmxlQ29sS2V5cy5tYXAoZnVuY3Rpb24gKGNvbEtleSkge1xuICAgICAgICAgIHZhciBmbGF0Q29sS2V5ID0gKDAsIF9VdGlsaXRpZXMuZmxhdEtleSkoY29sS2V5KTtcbiAgICAgICAgICB2YXIgYWdnID0gcGl2b3REYXRhLmdldEFnZ3JlZ2F0b3IoW10sIGNvbEtleSk7XG4gICAgICAgICAgdmFyIGFnZ1ZhbHVlID0gYWdnLnZhbHVlKCk7XG5cbiAgICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAndGQnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdwdnRUb3RhbCBwdnRSb3dUb3RhbCcsXG4gICAgICAgICAgICAgIGtleTogJ3RvdGFsLScgKyBmbGF0Q29sS2V5LFxuICAgICAgICAgICAgICBvbkNsaWNrOiBjb2xUb3RhbENhbGxiYWNrc1tmbGF0Q29sS2V5XSxcbiAgICAgICAgICAgICAgc3R5bGU6IHRvdGFsVmFsdWVTdHlsZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFnZy5mb3JtYXQoYWdnVmFsdWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGdyYW5kVG90YWxDZWxsID0gbnVsbDtcbiAgICAgICAgaWYgKHJvd1RvdGFscykge1xuICAgICAgICAgIHZhciBhZ2cgPSBwaXZvdERhdGEuZ2V0QWdncmVnYXRvcihbXSwgW10pO1xuICAgICAgICAgIHZhciBhZ2dWYWx1ZSA9IGFnZy52YWx1ZSgpO1xuICAgICAgICAgIGdyYW5kVG90YWxDZWxsID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAndGQnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBrZXk6ICd0b3RhbCcsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3B2dEdyYW5kVG90YWwgcHZ0Um93VG90YWwnLFxuICAgICAgICAgICAgICBvbkNsaWNrOiBncmFuZFRvdGFsQ2FsbGJhY2tcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZ2cuZm9ybWF0KGFnZ1ZhbHVlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxDZWxscyA9IFt0b3RhbExhYmVsQ2VsbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0b3RhbFZhbHVlQ2VsbHMpLCBbZ3JhbmRUb3RhbENlbGxdKTtcblxuICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RyJyxcbiAgICAgICAgICB7IGtleTogJ3RvdGFsJywgY2xhc3NOYW1lOiAncHZ0Um93VG90YWxzJyB9LFxuICAgICAgICAgIHRvdGFsQ2VsbHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICd2aXNpYmxlS2V5cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmlzaWJsZUtleXMoa2V5cywgY29sbGFwc2VkLCBudW1BdHRycywgc3VidG90YWxEaXNwbGF5KSB7XG4gICAgICAgIHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIElzIHRoZSBrZXkgaGlkZGVuIGJ5IG9uZSBvZiBpdHMgcGFyZW50cz9cbiAgICAgICAgICAgICFrZXkuc29tZShmdW5jdGlvbiAoaywgaikge1xuICAgICAgICAgICAgICByZXR1cm4gY29sbGFwc2VkWygwLCBfVXRpbGl0aWVzLmZsYXRLZXkpKGtleS5zbGljZSgwLCBqKSldO1xuICAgICAgICAgICAgfSkgJiYgKFxuICAgICAgICAgICAgLy8gTGVhZiBrZXkuXG4gICAgICAgICAgICBrZXkubGVuZ3RoID09PSBudW1BdHRycyB8fFxuICAgICAgICAgICAgLy8gQ2hpbGRyZW4gaGlkZGVuLiBNdXN0IHNob3cgdG90YWwuXG4gICAgICAgICAgICAoMCwgX1V0aWxpdGllcy5mbGF0S2V5KShrZXkpIGluIGNvbGxhcHNlZCB8fFxuICAgICAgICAgICAgLy8gRG9uJ3QgaGlkZSB0b3RhbHMuXG4gICAgICAgICAgICAhc3VidG90YWxEaXNwbGF5LmhpZGVPbkV4cGFuZClcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkUHJvcHMgIT09IHRoaXMucHJvcHMpIHtcbiAgICAgICAgICB0aGlzLmNhY2hlZFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgICB0aGlzLmNhY2hlZEJhc2VQaXZvdFNldHRpbmdzID0gdGhpcy5nZXRCYXNlUGl2b3RTZXR0aW5ncygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfY2FjaGVkQmFzZVBpdm90U2V0dGkgPSB0aGlzLmNhY2hlZEJhc2VQaXZvdFNldHRpbmdzLFxuICAgICAgICAgICAgY29sQXR0cnMgPSBfY2FjaGVkQmFzZVBpdm90U2V0dGkuY29sQXR0cnMsXG4gICAgICAgICAgICByb3dBdHRycyA9IF9jYWNoZWRCYXNlUGl2b3RTZXR0aS5yb3dBdHRycyxcbiAgICAgICAgICAgIHJvd0tleXMgPSBfY2FjaGVkQmFzZVBpdm90U2V0dGkucm93S2V5cyxcbiAgICAgICAgICAgIGNvbEtleXMgPSBfY2FjaGVkQmFzZVBpdm90U2V0dGkuY29sS2V5cyxcbiAgICAgICAgICAgIGNvbFRvdGFscyA9IF9jYWNoZWRCYXNlUGl2b3RTZXR0aS5jb2xUb3RhbHMsXG4gICAgICAgICAgICByb3dTdWJ0b3RhbERpc3BsYXkgPSBfY2FjaGVkQmFzZVBpdm90U2V0dGkucm93U3VidG90YWxEaXNwbGF5LFxuICAgICAgICAgICAgY29sU3VidG90YWxEaXNwbGF5ID0gX2NhY2hlZEJhc2VQaXZvdFNldHRpLmNvbFN1YnRvdGFsRGlzcGxheTtcblxuICAgICAgICAvLyBOZWVkIHRvIGFjY291bnQgZm9yIGV4Y2x1c2lvbnMgdG8gY29tcHV0ZSB0aGUgZWZmZWN0aXZlIHJvd1xuICAgICAgICAvLyBhbmQgY29sdW1uIGtleXMuXG5cbiAgICAgICAgdmFyIHZpc2libGVSb3dLZXlzID0gb3B0cy5zdWJ0b3RhbHMgPyB0aGlzLnZpc2libGVLZXlzKHJvd0tleXMsIHRoaXMuc3RhdGUuY29sbGFwc2VkUm93cywgcm93QXR0cnMubGVuZ3RoLCByb3dTdWJ0b3RhbERpc3BsYXkpIDogcm93S2V5cztcbiAgICAgICAgdmFyIHZpc2libGVDb2xLZXlzID0gb3B0cy5zdWJ0b3RhbHMgPyB0aGlzLnZpc2libGVLZXlzKGNvbEtleXMsIHRoaXMuc3RhdGUuY29sbGFwc2VkQ29scywgY29sQXR0cnMubGVuZ3RoLCBjb2xTdWJ0b3RhbERpc3BsYXkpIDogY29sS2V5cztcblxuICAgICAgICB2YXIgcGl2b3RTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHZpc2libGVSb3dLZXlzOiB2aXNpYmxlUm93S2V5cyxcbiAgICAgICAgICBtYXhSb3dWaXNpYmxlOiBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkodmlzaWJsZVJvd0tleXMubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gay5sZW5ndGg7XG4gICAgICAgICAgfSkpKSxcbiAgICAgICAgICB2aXNpYmxlQ29sS2V5czogdmlzaWJsZUNvbEtleXMsXG4gICAgICAgICAgbWF4Q29sVmlzaWJsZTogTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHZpc2libGVDb2xLZXlzLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsubGVuZ3RoO1xuICAgICAgICAgIH0pKSksXG4gICAgICAgICAgcm93QXR0clNwYW5zOiB0aGlzLmNhbGNBdHRyU3BhbnModmlzaWJsZVJvd0tleXMsIHJvd0F0dHJzLmxlbmd0aCksXG4gICAgICAgICAgY29sQXR0clNwYW5zOiB0aGlzLmNhbGNBdHRyU3BhbnModmlzaWJsZUNvbEtleXMsIGNvbEF0dHJzLmxlbmd0aClcbiAgICAgICAgfSwgdGhpcy5jYWNoZWRCYXNlUGl2b3RTZXR0aW5ncyk7XG5cbiAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICd0YWJsZScsXG4gICAgICAgICAgeyBjbGFzc05hbWU6ICdwdnRUYWJsZScgfSxcbiAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICd0aGVhZCcsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgY29sQXR0cnMubWFwKGZ1bmN0aW9uIChjLCBqKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczkucmVuZGVyQ29sSGVhZGVyUm93KGMsIGosIHBpdm90U2V0dGluZ3MpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByb3dBdHRycy5sZW5ndGggIT09IDAgJiYgdGhpcy5yZW5kZXJSb3dIZWFkZXJSb3cocGl2b3RTZXR0aW5ncylcbiAgICAgICAgICApLFxuICAgICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ3Rib2R5JyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICB2aXNpYmxlUm93S2V5cy5tYXAoZnVuY3Rpb24gKHIsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzOS5yZW5kZXJUYWJsZVJvdyhyLCBpLCBwaXZvdFNldHRpbmdzKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY29sVG90YWxzICYmIHRoaXMucmVuZGVyVG90YWxzUm93KHBpdm90U2V0dGluZ3MpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiAnaGVhdG1hcE1hcHBlcnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhlYXRtYXBNYXBwZXJzKHBpdm90RGF0YSwgY29sb3JTY2FsZUdlbmVyYXRvciwgY29sVG90YWxzLCByb3dUb3RhbHMpIHtcbiAgICAgICAgdmFyIHZhbHVlQ2VsbENvbG9ycyA9IGZ1bmN0aW9uIHZhbHVlQ2VsbENvbG9ycygpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH07XG4gICAgICAgIHZhciByb3dUb3RhbENvbG9ycyA9IGZ1bmN0aW9uIHJvd1RvdGFsQ29sb3JzKCkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbFRvdGFsQ29sb3JzID0gZnVuY3Rpb24gY29sVG90YWxDb2xvcnMoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cy5oZWF0bWFwTW9kZSkge1xuICAgICAgICAgIGlmIChjb2xUb3RhbHMpIHtcbiAgICAgICAgICAgIHZhciBjb2xUb3RhbFZhbHVlcyA9IE9iamVjdC52YWx1ZXMocGl2b3REYXRhLmNvbFRvdGFscykubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnZhbHVlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbFRvdGFsQ29sb3JzID0gY29sb3JTY2FsZUdlbmVyYXRvcihjb2xUb3RhbFZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb3dUb3RhbHMpIHtcbiAgICAgICAgICAgIHZhciByb3dUb3RhbFZhbHVlcyA9IE9iamVjdC52YWx1ZXMocGl2b3REYXRhLnJvd1RvdGFscykubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnZhbHVlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJvd1RvdGFsQ29sb3JzID0gY29sb3JTY2FsZUdlbmVyYXRvcihyb3dUb3RhbFZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLmhlYXRtYXBNb2RlID09PSAnZnVsbCcpIHtcbiAgICAgICAgICAgIHZhciBhbGxWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMocGl2b3REYXRhLnRyZWUpLm1hcChmdW5jdGlvbiAoY2QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoY2QpLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhYS5pc1N1YnRvdGFsICYmIGFsbFZhbHVlcy5wdXNoKGEudmFsdWUoKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgY29sb3JTY2FsZSA9IGNvbG9yU2NhbGVHZW5lcmF0b3IoYWxsVmFsdWVzKTtcbiAgICAgICAgICAgIHZhbHVlQ2VsbENvbG9ycyA9IGZ1bmN0aW9uIHZhbHVlQ2VsbENvbG9ycyhyLCBjLCB2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb2xvclNjYWxlKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuaGVhdG1hcE1vZGUgPT09ICdyb3cnKSB7XG4gICAgICAgICAgICB2YXIgcm93Q29sb3JTY2FsZXMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHBpdm90RGF0YS50cmVlKS5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICAgICAgICByayA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgICAgICAgY2QgPSBfcmVmMlsxXTtcblxuICAgICAgICAgICAgICB2YXIgcm93VmFsdWVzID0gT2JqZWN0LnZhbHVlcyhjZCkubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFhLmlzU3VidG90YWwgJiYgYS52YWx1ZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcm93Q29sb3JTY2FsZXNbcmtdID0gY29sb3JTY2FsZUdlbmVyYXRvcihyb3dWYWx1ZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZUNlbGxDb2xvcnMgPSBmdW5jdGlvbiB2YWx1ZUNlbGxDb2xvcnMociwgYywgdikge1xuICAgICAgICAgICAgICByZXR1cm4gcm93Q29sb3JTY2FsZXNbKDAsIF9VdGlsaXRpZXMuZmxhdEtleSkocildKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuaGVhdG1hcE1vZGUgPT09ICdjb2wnKSB7XG4gICAgICAgICAgICB2YXIgY29sQ29sb3JTY2FsZXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBjb2xWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMocGl2b3REYXRhLnRyZWUpLm1hcChmdW5jdGlvbiAoY2QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGNkKS5tYXAoZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgICAgICAgICAgICAgICBjayA9IF9yZWY0WzBdLFxuICAgICAgICAgICAgICAgICAgICBhID0gX3JlZjRbMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIShjayBpbiBjb2xWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICBjb2xWYWx1ZXNbY2tdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYS5pc1N1YnRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xWYWx1ZXNbY2tdLnB1c2goYS52YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGNvbFZhbHVlcykge1xuICAgICAgICAgICAgICBjb2xDb2xvclNjYWxlc1trXSA9IGNvbG9yU2NhbGVHZW5lcmF0b3IoY29sVmFsdWVzW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlQ2VsbENvbG9ycyA9IGZ1bmN0aW9uIHZhbHVlQ2VsbENvbG9ycyhyLCBjLCB2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb2xDb2xvclNjYWxlc1soMCwgX1V0aWxpdGllcy5mbGF0S2V5KShjKV0odik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWx1ZUNlbGxDb2xvcnM6IHZhbHVlQ2VsbENvbG9ycywgcm93VG90YWxDb2xvcnM6IHJvd1RvdGFsQ29sb3JzLCBjb2xUb3RhbENvbG9yczogY29sVG90YWxDb2xvcnMgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdiYXJjaGFydE1hcHBlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmFyY2hhcnRNYXBwZXIocGl2b3REYXRhLCBiYXJTY2FsZUdlbmVyYXRvciwgY29sVG90YWxzLCByb3dUb3RhbHMpIHtcbiAgICAgICAgdmFyIGNlbGxTdHlsZSA9IHt9O1xuICAgICAgICB2YXIgdmFsdWVDZWxsQmFyID0gZnVuY3Rpb24gdmFsdWVDZWxsQmFyKHIsIGMsIHYsIHQpIHtcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJvd1RvdGFsQmFyID0gZnVuY3Rpb24gcm93VG90YWxCYXIodiwgdCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY29sVG90YWxCYXIgPSBmdW5jdGlvbiBjb2xUb3RhbEJhcih2LCB0KSB7XG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdHMuYmFyY2hhcnRNb2RlKSB7XG4gICAgICAgICAgY2VsbFN0eWxlID0ge1xuICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiAnNXB4JyxcbiAgICAgICAgICAgIGhlaWdodDogJzYwcHgnXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoY29sVG90YWxzKSB7XG4gICAgICAgICAgICB2YXIgY29sVG90YWxWYWx1ZXMgPSBPYmplY3QudmFsdWVzKHBpdm90RGF0YS5jb2xUb3RhbHMpLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICByZXR1cm4gIWEuaXNTdWJ0b3RhbDtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICByZXR1cm4gYS52YWx1ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xUb3RhbEJhciA9IGJhclNjYWxlR2VuZXJhdG9yKGNvbFRvdGFsVmFsdWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvd1RvdGFscykge1xuICAgICAgICAgICAgdmFyIHJvd1RvdGFsVmFsdWVzID0gT2JqZWN0LnZhbHVlcyhwaXZvdERhdGEucm93VG90YWxzKS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFhLmlzU3VidG90YWw7XG4gICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEudmFsdWUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcm93VG90YWxCYXIgPSBiYXJTY2FsZUdlbmVyYXRvcihyb3dUb3RhbFZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLmJhcmNoYXJ0TW9kZSA9PT0gJ2Z1bGwnKSB7XG4gICAgICAgICAgICB2YXIgYWxsVmFsdWVzID0gW107XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKHBpdm90RGF0YS50cmVlKS5tYXAoZnVuY3Rpb24gKGNkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGNkKS5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWEuaXNTdWJ0b3RhbCAmJiBhbGxWYWx1ZXMucHVzaChhLnZhbHVlKCkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGJhclNjYWxlcyA9IGJhclNjYWxlR2VuZXJhdG9yKGFsbFZhbHVlcyk7XG4gICAgICAgICAgICB2YWx1ZUNlbGxCYXIgPSBmdW5jdGlvbiB2YWx1ZUNlbGxCYXIociwgYywgdiwgdCkge1xuICAgICAgICAgICAgICByZXR1cm4gYmFyU2NhbGVzKHYsIHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuYmFyY2hhcnRNb2RlID09PSAncm93Jykge1xuICAgICAgICAgICAgdmFyIHJvd0JhclNjYWxlcyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMocGl2b3REYXRhLnRyZWUpLm1hcChmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDIpLFxuICAgICAgICAgICAgICAgICAgcmsgPSBfcmVmNlswXSxcbiAgICAgICAgICAgICAgICAgIGNkID0gX3JlZjZbMV07XG5cbiAgICAgICAgICAgICAgdmFyIHJvd1ZhbHVlcyA9IE9iamVjdC52YWx1ZXMoY2QpLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhYS5pc1N1YnRvdGFsICYmIGEudmFsdWUoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJvd0JhclNjYWxlc1tya10gPSBiYXJTY2FsZUdlbmVyYXRvcihyb3dWYWx1ZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZUNlbGxCYXIgPSBmdW5jdGlvbiB2YWx1ZUNlbGxCYXIociwgYywgdiwgdCkge1xuICAgICAgICAgICAgICByZXR1cm4gcm93QmFyU2NhbGVzWygwLCBfVXRpbGl0aWVzLmZsYXRLZXkpKHIpXSh2LCB0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRzLmJhcmNoYXJ0TW9kZSA9PT0gJ2NvbCcpIHtcbiAgICAgICAgICAgIHZhciBjb2xCYXJTY2FsZXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBjb2xWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMocGl2b3REYXRhLnRyZWUpLm1hcChmdW5jdGlvbiAoY2QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGNkKS5tYXAoZnVuY3Rpb24gKF9yZWY3KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDIpLFxuICAgICAgICAgICAgICAgICAgICBjayA9IF9yZWY4WzBdLFxuICAgICAgICAgICAgICAgICAgICBhID0gX3JlZjhbMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIShjayBpbiBjb2xWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICBjb2xWYWx1ZXNbY2tdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYS5pc1N1YnRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xWYWx1ZXNbY2tdLnB1c2goYS52YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGNvbFZhbHVlcykge1xuICAgICAgICAgICAgICBjb2xCYXJTY2FsZXNba10gPSBiYXJTY2FsZUdlbmVyYXRvcihjb2xWYWx1ZXNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVDZWxsQmFyID0gZnVuY3Rpb24gdmFsdWVDZWxsQmFyKHIsIGMsIHYsIHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbEJhclNjYWxlc1soMCwgX1V0aWxpdGllcy5mbGF0S2V5KShjKV0odiwgdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjZWxsU3R5bGU6IGNlbGxTdHlsZSwgdmFsdWVDZWxsQmFyOiB2YWx1ZUNlbGxCYXIsIHJvd1RvdGFsQmFyOiByb3dUb3RhbEJhciwgY29sVG90YWxCYXI6IGNvbFRvdGFsQmFyIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRhYmxlUmVuZGVyZXI7XG4gIH0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cbiAgVGFibGVSZW5kZXJlci5kZWZhdWx0UHJvcHMgPSBfVXRpbGl0aWVzLlBpdm90RGF0YS5kZWZhdWx0UHJvcHM7XG4gIFRhYmxlUmVuZGVyZXIucHJvcFR5cGVzID0gX1V0aWxpdGllcy5QaXZvdERhdGEucHJvcFR5cGVzO1xuICBUYWJsZVJlbmRlcmVyLmRlZmF1bHRQcm9wcy50YWJsZUNvbG9yU2NhbGVHZW5lcmF0b3IgPSByZWRDb2xvclNjYWxlR2VuZXJhdG9yO1xuICBUYWJsZVJlbmRlcmVyLmRlZmF1bHRQcm9wcy5iYXJTY2FsZUdlbmVyYXRvciA9IGRlZmF1bHRCYXJjaGFydFNjYWxlR2VuZXJhdG9yO1xuICBUYWJsZVJlbmRlcmVyLmRlZmF1bHRQcm9wcy50YWJsZU9wdGlvbnMgPSB7fTtcbiAgVGFibGVSZW5kZXJlci5wcm9wVHlwZXMudGFibGVDb2xvclNjYWxlR2VuZXJhdG9yID0gX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jO1xuICBUYWJsZVJlbmRlcmVyLnByb3BUeXBlcy50YWJsZU9wdGlvbnMgPSBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdDtcbiAgcmV0dXJuIFRhYmxlUmVuZGVyZXI7XG59XG5cbnZhciBUU1ZFeHBvcnRSZW5kZXJlciA9IGZ1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoVFNWRXhwb3J0UmVuZGVyZXIsIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUU1ZFeHBvcnRSZW5kZXJlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVFNWRXhwb3J0UmVuZGVyZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUU1ZFeHBvcnRSZW5kZXJlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRTVkV4cG9ydFJlbmRlcmVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVFNWRXhwb3J0UmVuZGVyZXIsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHBpdm90RGF0YSA9IG5ldyBfVXRpbGl0aWVzLlBpdm90RGF0YSh0aGlzLnByb3BzKTtcbiAgICAgIHZhciByb3dLZXlzID0gcGl2b3REYXRhLmdldFJvd0tleXMoKTtcbiAgICAgIHZhciBjb2xLZXlzID0gcGl2b3REYXRhLmdldENvbEtleXMoKTtcbiAgICAgIGlmIChyb3dLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByb3dLZXlzLnB1c2goW10pO1xuICAgICAgfVxuICAgICAgaWYgKGNvbEtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbEtleXMucHVzaChbXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBoZWFkZXJSb3cgPSBwaXZvdERhdGEucHJvcHMucm93cy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9KTtcbiAgICAgIGlmIChjb2xLZXlzLmxlbmd0aCA9PT0gMSAmJiBjb2xLZXlzWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBoZWFkZXJSb3cucHVzaCh0aGlzLnByb3BzLmFnZ3JlZ2F0b3JOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbEtleXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgcmV0dXJuIGhlYWRlclJvdy5wdXNoKGMuam9pbignLScpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSByb3dLZXlzLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgICB2YXIgcm93ID0gci5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbEtleXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgdmFyIHYgPSBwaXZvdERhdGEuZ2V0QWdncmVnYXRvcihyLCBjKS52YWx1ZSgpO1xuICAgICAgICAgIHJvdy5wdXNoKHYgPyB2IDogJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHQudW5zaGlmdChoZWFkZXJSb3cpO1xuXG4gICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJywge1xuICAgICAgICB2YWx1ZTogcmVzdWx0Lm1hcChmdW5jdGlvbiAocikge1xuICAgICAgICAgIHJldHVybiByLmpvaW4oJ1xcdCcpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgc3R5bGU6IHsgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoIC8gMiwgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIH0sXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVFNWRXhwb3J0UmVuZGVyZXI7XG59KF9yZWFjdDIuZGVmYXVsdC5QdXJlQ29tcG9uZW50KTtcblxuVFNWRXhwb3J0UmVuZGVyZXIuZGVmYXVsdFByb3BzID0gX1V0aWxpdGllcy5QaXZvdERhdGEuZGVmYXVsdFByb3BzO1xuVFNWRXhwb3J0UmVuZGVyZXIucHJvcFR5cGVzID0gX1V0aWxpdGllcy5QaXZvdERhdGEucHJvcFR5cGVzO1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIFRhYmxlOiBtYWtlUmVuZGVyZXIoKSxcbiAgJ1RhYmxlIEhlYXRtYXAnOiBtYWtlUmVuZGVyZXIoeyBoZWF0bWFwTW9kZTogJ2Z1bGwnIH0pLFxuICAnVGFibGUgQ29sIEhlYXRtYXAnOiBtYWtlUmVuZGVyZXIoeyBoZWF0bWFwTW9kZTogJ2NvbCcgfSksXG4gICdUYWJsZSBSb3cgSGVhdG1hcCc6IG1ha2VSZW5kZXJlcih7IGhlYXRtYXBNb2RlOiAncm93JyB9KSxcbiAgJ1RhYmxlIEJhcmNoYXJ0JzogbWFrZVJlbmRlcmVyKHsgYmFyY2hhcnRNb2RlOiAnZnVsbCcgfSksXG4gICdUYWJsZSBDb2wgQmFyY2hhcnQnOiBtYWtlUmVuZGVyZXIoeyBiYXJjaGFydE1vZGU6ICdjb2wnIH0pLFxuICAnVGFibGUgUm93IEJhcmNoYXJ0JzogbWFrZVJlbmRlcmVyKHsgYmFyY2hhcnRNb2RlOiAncm93JyB9KSxcbiAgJ1RhYmxlIFdpdGggU3VidG90YWwnOiBtYWtlUmVuZGVyZXIoeyBzdWJ0b3RhbHM6IHRydWUgfSksXG4gICdUYWJsZSBXaXRoIFN1YnRvdGFsIEhlYXRtYXAnOiBtYWtlUmVuZGVyZXIoe1xuICAgIGhlYXRtYXBNb2RlOiAnZnVsbCcsXG4gICAgc3VidG90YWxzOiB0cnVlXG4gIH0pLFxuICAnVGFibGUgV2l0aCBTdWJ0b3RhbCBDb2wgSGVhdG1hcCc6IG1ha2VSZW5kZXJlcih7XG4gICAgaGVhdG1hcE1vZGU6ICdjb2wnLFxuICAgIHN1YnRvdGFsczogdHJ1ZVxuICB9KSxcbiAgJ1RhYmxlIFdpdGggU3VidG90YWwgUm93IEhlYXRtYXAnOiBtYWtlUmVuZGVyZXIoe1xuICAgIGhlYXRtYXBNb2RlOiAncm93JyxcbiAgICBzdWJ0b3RhbHM6IHRydWVcbiAgfSksXG4gICdUYWJsZSBXaXRoIFN1YnRvdGFsIEJhcmNoYXJ0JzogbWFrZVJlbmRlcmVyKHtcbiAgICBiYXJjaGFydE1vZGU6ICdmdWxsJyxcbiAgICBzdWJ0b3RhbHM6IHRydWVcbiAgfSksXG4gICdUYWJsZSBXaXRoIFN1YnRvdGFsIENvbCBCYXJjaGFydCc6IG1ha2VSZW5kZXJlcih7XG4gICAgYmFyY2hhcnRNb2RlOiAnY29sJyxcbiAgICBzdWJ0b3RhbHM6IHRydWVcbiAgfSksXG4gICdUYWJsZSBXaXRoIFN1YnRvdGFsIFJvdyBCYXJjaGFydCc6IG1ha2VSZW5kZXJlcih7XG4gICAgYmFyY2hhcnRNb2RlOiAncm93JyxcbiAgICBzdWJ0b3RhbHM6IHRydWVcbiAgfSksXG4gICdFeHBvcnRhYmxlIFRTVic6IFRTVkV4cG9ydFJlbmRlcmVyXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWJsZVJlbmRlcmVycy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/TableRenderers.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/Utilities.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/Utilities.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PivotData = exports.flatKey = exports.sortAs = exports.getSort = exports.numberFormat = exports.naturalSort = exports.locales = exports.derivers = exports.aggregators = exports.aggregatorTemplates = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS104: Avoid inline assignments\n * DS201: Simplify complex destructure assignments\n * DS203: Remove `|| {}` from converted for-own loops\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n\nvar addSeparators = function addSeparators(nStr, thousandsSep, decimalSep) {\n  var x = String(nStr).split('.');\n  var x1 = x[0];\n  var x2 = x.length > 1 ? decimalSep + x[1] : '';\n  var rgx = /(\\d+)(\\d{3})/;\n  while (rgx.test(x1)) {\n    x1 = x1.replace(rgx, '$1' + thousandsSep + '$2');\n  }\n  return x1 + x2;\n};\n\nvar numberFormat = function numberFormat(opts_in) {\n  var defaults = {\n    digitsAfterDecimal: 2,\n    scaler: 1,\n    thousandsSep: ',',\n    decimalSep: '.',\n    prefix: '',\n    suffix: ''\n  };\n  var opts = Object.assign({}, defaults, opts_in);\n  return function (x) {\n    if (isNaN(x) || !isFinite(x)) {\n      return '';\n    }\n    var result = addSeparators((opts.scaler * x).toFixed(opts.digitsAfterDecimal), opts.thousandsSep, opts.decimalSep);\n    return '' + opts.prefix + result + opts.suffix;\n  };\n};\n\nvar rx = /(\\d+)|(\\D+)/g;\nvar rd = /\\d/;\nvar rz = /^0/;\nvar naturalSort = function naturalSort(as, bs) {\n  // nulls first\n  if (bs !== null && as === null) {\n    return -1;\n  }\n  if (as !== null && bs === null) {\n    return 1;\n  }\n\n  // then raw NaNs\n  if (typeof as === 'number' && isNaN(as)) {\n    return -1;\n  }\n  if (typeof bs === 'number' && isNaN(bs)) {\n    return 1;\n  }\n\n  // numbers and numbery strings group together\n  var nas = Number(as);\n  var nbs = Number(bs);\n  if (nas < nbs) {\n    return -1;\n  }\n  if (nas > nbs) {\n    return 1;\n  }\n\n  // within that, true numbers before numbery strings\n  if (typeof as === 'number' && typeof bs !== 'number') {\n    return -1;\n  }\n  if (typeof bs === 'number' && typeof as !== 'number') {\n    return 1;\n  }\n  if (typeof as === 'number' && typeof bs === 'number') {\n    return 0;\n  }\n\n  // 'Infinity' is a textual number, so less than 'A'\n  if (isNaN(nbs) && !isNaN(nas)) {\n    return -1;\n  }\n  if (isNaN(nas) && !isNaN(nbs)) {\n    return 1;\n  }\n\n  // finally, \"smart\" string sorting per http://stackoverflow.com/a/4373421/112871\n  var a = String(as);\n  var b = String(bs);\n  if (a === b) {\n    return 0;\n  }\n  if (!rd.test(a) || !rd.test(b)) {\n    return a > b ? 1 : -1;\n  }\n\n  // special treatment for strings containing digits\n  a = a.match(rx);\n  b = b.match(rx);\n  while (a.length && b.length) {\n    var a1 = a.shift();\n    var b1 = b.shift();\n    if (a1 !== b1) {\n      if (rd.test(a1) && rd.test(b1)) {\n        return a1.replace(rz, '.0') - b1.replace(rz, '.0');\n      }\n      return a1 > b1 ? 1 : -1;\n    }\n  }\n  return a.length - b.length;\n};\n\nvar sortAs = function sortAs(order) {\n  var mapping = {};\n\n  // sort lowercased keys similarly\n  var l_mapping = {};\n  for (var i in order) {\n    var x = order[i];\n    mapping[x] = i;\n    if (typeof x === 'string') {\n      l_mapping[x.toLowerCase()] = i;\n    }\n  }\n  return function (a, b) {\n    if (a in mapping && b in mapping) {\n      return mapping[a] - mapping[b];\n    } else if (a in mapping) {\n      return -1;\n    } else if (b in mapping) {\n      return 1;\n    } else if (a in l_mapping && b in l_mapping) {\n      return l_mapping[a] - l_mapping[b];\n    } else if (a in l_mapping) {\n      return -1;\n    } else if (b in l_mapping) {\n      return 1;\n    }\n    return naturalSort(a, b);\n  };\n};\n\nvar getSort = function getSort(sorters, attr) {\n  if (sorters) {\n    if (typeof sorters === 'function') {\n      var sort = sorters(attr);\n      if (typeof sort === 'function') {\n        return sort;\n      }\n    } else if (attr in sorters) {\n      return sorters[attr];\n    }\n  }\n  return naturalSort;\n};\n\n// aggregator templates default to US number formatting but this is overrideable\nvar usFmt = numberFormat();\nvar usFmtInt = numberFormat({ digitsAfterDecimal: 0 });\nvar usFmtPct = numberFormat({\n  digitsAfterDecimal: 1,\n  scaler: 100,\n  suffix: '%'\n});\n\nvar aggregatorTemplates = {\n  count: function count() {\n    var formatter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : usFmtInt;\n\n    return function () {\n      return function () {\n        return {\n          count: 0,\n          push: function push() {\n            this.count++;\n          },\n          value: function value() {\n            return this.count;\n          },\n\n          format: formatter\n        };\n      };\n    };\n  },\n  uniques: function uniques(fn) {\n    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : usFmtInt;\n\n    return function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          attr = _ref2[0];\n\n      return function () {\n        return {\n          uniq: [],\n          push: function push(record) {\n            if (!Array.from(this.uniq).includes(record[attr])) {\n              this.uniq.push(record[attr]);\n            }\n          },\n          value: function value() {\n            return fn(this.uniq);\n          },\n\n          format: formatter,\n          numInputs: typeof attr !== 'undefined' ? 0 : 1\n        };\n      };\n    };\n  },\n  sum: function sum() {\n    var formatter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : usFmt;\n\n    return function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          attr = _ref4[0];\n\n      return function () {\n        return {\n          sum: 0,\n          push: function push(record) {\n            if (!isNaN(parseFloat(record[attr]))) {\n              this.sum += parseFloat(record[attr]);\n            }\n          },\n          value: function value() {\n            return this.sum;\n          },\n\n          format: formatter,\n          numInputs: typeof attr !== 'undefined' ? 0 : 1\n        };\n      };\n    };\n  },\n  extremes: function extremes(mode) {\n    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : usFmt;\n\n    return function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 1),\n          attr = _ref6[0];\n\n      return function (data) {\n        return {\n          val: null,\n          sorter: getSort(typeof data !== 'undefined' ? data.sorters : null, attr),\n          push: function push(record) {\n            var x = record[attr];\n            if (['min', 'max'].includes(mode)) {\n              x = parseFloat(x);\n              if (!isNaN(x)) {\n                this.val = Math[mode](x, this.val !== null ? this.val : x);\n              }\n            }\n            if (mode === 'first' && this.sorter(x, this.val !== null ? this.val : x) <= 0) {\n              this.val = x;\n            }\n            if (mode === 'last' && this.sorter(x, this.val !== null ? this.val : x) >= 0) {\n              this.val = x;\n            }\n          },\n          value: function value() {\n            return this.val;\n          },\n          format: function format(x) {\n            if (isNaN(x)) {\n              return x;\n            }\n            return formatter(x);\n          },\n\n          numInputs: typeof attr !== 'undefined' ? 0 : 1\n        };\n      };\n    };\n  },\n  quantile: function quantile(q) {\n    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : usFmt;\n\n    return function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 1),\n          attr = _ref8[0];\n\n      return function () {\n        return {\n          vals: [],\n          push: function push(record) {\n            var x = parseFloat(record[attr]);\n            if (!isNaN(x)) {\n              this.vals.push(x);\n            }\n          },\n          value: function value() {\n            if (this.vals.length === 0) {\n              return null;\n            }\n            this.vals.sort(function (a, b) {\n              return a - b;\n            });\n            var i = (this.vals.length - 1) * q;\n            return (this.vals[Math.floor(i)] + this.vals[Math.ceil(i)]) / 2.0;\n          },\n\n          format: formatter,\n          numInputs: typeof attr !== 'undefined' ? 0 : 1\n        };\n      };\n    };\n  },\n  runningStat: function runningStat() {\n    var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'mean';\n    var ddof = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var formatter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : usFmt;\n\n    return function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 1),\n          attr = _ref10[0];\n\n      return function () {\n        return {\n          n: 0.0,\n          m: 0.0,\n          s: 0.0,\n          push: function push(record) {\n            var x = parseFloat(record[attr]);\n            if (isNaN(x)) {\n              return;\n            }\n            this.n += 1.0;\n            if (this.n === 1.0) {\n              this.m = x;\n            }\n            var m_new = this.m + (x - this.m) / this.n;\n            this.s = this.s + (x - this.m) * (x - m_new);\n            this.m = m_new;\n          },\n          value: function value() {\n            if (mode === 'mean') {\n              if (this.n === 0) {\n                return 0 / 0;\n              }\n              return this.m;\n            }\n            if (this.n <= ddof) {\n              return 0;\n            }\n            switch (mode) {\n              case 'var':\n                return this.s / (this.n - ddof);\n              case 'stdev':\n                return Math.sqrt(this.s / (this.n - ddof));\n              default:\n                throw new Error('unknown mode for runningStat');\n            }\n          },\n\n          format: formatter,\n          numInputs: typeof attr !== 'undefined' ? 0 : 1\n        };\n      };\n    };\n  },\n  sumOverSum: function sumOverSum() {\n    var formatter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : usFmt;\n\n    return function (_ref11) {\n      var _ref12 = _slicedToArray(_ref11, 2),\n          num = _ref12[0],\n          denom = _ref12[1];\n\n      return function () {\n        return {\n          sumNum: 0,\n          sumDenom: 0,\n          push: function push(record) {\n            if (!isNaN(parseFloat(record[num]))) {\n              this.sumNum += parseFloat(record[num]);\n            }\n            if (!isNaN(parseFloat(record[denom]))) {\n              this.sumDenom += parseFloat(record[denom]);\n            }\n          },\n          value: function value() {\n            return this.sumNum / this.sumDenom;\n          },\n\n          format: formatter,\n          numInputs: typeof num !== 'undefined' && typeof denom !== 'undefined' ? 0 : 2\n        };\n      };\n    };\n  },\n  fractionOf: function fractionOf(wrapped) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'total';\n    var formatter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : usFmtPct;\n\n    return function () {\n      for (var _len = arguments.length, x = Array(_len), _key = 0; _key < _len; _key++) {\n        x[_key] = arguments[_key];\n      }\n\n      return function (data, rowKey, colKey) {\n        return {\n          selector: { total: [[], []], row: [rowKey, []], col: [[], colKey] }[type],\n          inner: wrapped.apply(undefined, _toConsumableArray(Array.from(x || [])))(data, rowKey, colKey),\n          push: function push(record) {\n            this.inner.push(record);\n          },\n\n          format: formatter,\n          value: function value() {\n            return this.inner.value() / data.getAggregator.apply(data, _toConsumableArray(Array.from(this.selector || []))).inner.value();\n          },\n\n          numInputs: wrapped.apply(undefined, _toConsumableArray(Array.from(x || [])))().numInputs\n        };\n      };\n    };\n  }\n};\n\naggregatorTemplates.countUnique = function (f) {\n  return aggregatorTemplates.uniques(function (x) {\n    return x.length;\n  }, f);\n};\naggregatorTemplates.listUnique = function (s, f) {\n  return aggregatorTemplates.uniques(function (x) {\n    return x.join(s);\n  }, f || function (x) {\n    return x;\n  });\n};\naggregatorTemplates.max = function (f) {\n  return aggregatorTemplates.extremes('max', f);\n};\naggregatorTemplates.min = function (f) {\n  return aggregatorTemplates.extremes('min', f);\n};\naggregatorTemplates.first = function (f) {\n  return aggregatorTemplates.extremes('first', f);\n};\naggregatorTemplates.last = function (f) {\n  return aggregatorTemplates.extremes('last', f);\n};\naggregatorTemplates.median = function (f) {\n  return aggregatorTemplates.quantile(0.5, f);\n};\naggregatorTemplates.average = function (f) {\n  return aggregatorTemplates.runningStat('mean', 1, f);\n};\naggregatorTemplates.var = function (ddof, f) {\n  return aggregatorTemplates.runningStat('var', ddof, f);\n};\naggregatorTemplates.stdev = function (ddof, f) {\n  return aggregatorTemplates.runningStat('stdev', ddof, f);\n};\n\n// default aggregators & renderers use US naming and number formatting\nvar aggregators = function (tpl) {\n  return {\n    Count: tpl.count(usFmtInt),\n    'Count Unique Values': tpl.countUnique(usFmtInt),\n    'List Unique Values': tpl.listUnique(', '),\n    Sum: tpl.sum(usFmt),\n    'Integer Sum': tpl.sum(usFmtInt),\n    Average: tpl.average(usFmt),\n    Median: tpl.median(usFmt),\n    'Sample Variance': tpl.var(1, usFmt),\n    'Sample Standard Deviation': tpl.stdev(1, usFmt),\n    Minimum: tpl.min(usFmt),\n    Maximum: tpl.max(usFmt),\n    First: tpl.first(usFmt),\n    Last: tpl.last(usFmt),\n    'Sum over Sum': tpl.sumOverSum(usFmt),\n    'Sum as Fraction of Total': tpl.fractionOf(tpl.sum(), 'total', usFmtPct),\n    'Sum as Fraction of Rows': tpl.fractionOf(tpl.sum(), 'row', usFmtPct),\n    'Sum as Fraction of Columns': tpl.fractionOf(tpl.sum(), 'col', usFmtPct),\n    'Count as Fraction of Total': tpl.fractionOf(tpl.count(), 'total', usFmtPct),\n    'Count as Fraction of Rows': tpl.fractionOf(tpl.count(), 'row', usFmtPct),\n    'Count as Fraction of Columns': tpl.fractionOf(tpl.count(), 'col', usFmtPct)\n  };\n}(aggregatorTemplates);\n\nvar locales = {\n  en: {\n    aggregators: aggregators,\n    localeStrings: {\n      renderError: 'An error occurred rendering the PivotTable results.',\n      computeError: 'An error occurred computing the PivotTable results.',\n      uiRenderError: 'An error occurred rendering the PivotTable UI.',\n      selectAll: 'Select All',\n      selectNone: 'Select None',\n      tooMany: '(too many to list)',\n      filterResults: 'Filter values',\n      apply: 'Apply',\n      cancel: 'Cancel',\n      totals: 'Totals',\n      vs: 'vs',\n      by: 'by'\n    }\n  }\n};\n\n// dateFormat deriver l10n requires month and day names to be passed in directly\nvar mthNamesEn = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\nvar dayNamesEn = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\nvar zeroPad = function zeroPad(number) {\n  return ('0' + number).substr(-2, 2);\n}; // eslint-disable-line no-magic-numbers\n\nvar derivers = {\n  bin: function bin(col, binWidth) {\n    return function (record) {\n      return record[col] - record[col] % binWidth;\n    };\n  },\n  dateFormat: function dateFormat(col, formatString) {\n    var utcOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var mthNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : mthNamesEn;\n    var dayNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : dayNamesEn;\n\n    var utc = utcOutput ? 'UTC' : '';\n    return function (record) {\n      var date = new Date(Date.parse(record[col]));\n      if (isNaN(date)) {\n        return '';\n      }\n      return formatString.replace(/%(.)/g, function (m, p) {\n        switch (p) {\n          case 'y':\n            return date['get' + utc + 'FullYear']();\n          case 'm':\n            return zeroPad(date['get' + utc + 'Month']() + 1);\n          case 'n':\n            return mthNames[date['get' + utc + 'Month']()];\n          case 'd':\n            return zeroPad(date['get' + utc + 'Date']());\n          case 'w':\n            return dayNames[date['get' + utc + 'Day']()];\n          case 'x':\n            return date['get' + utc + 'Day']();\n          case 'H':\n            return zeroPad(date['get' + utc + 'Hours']());\n          case 'M':\n            return zeroPad(date['get' + utc + 'Minutes']());\n          case 'S':\n            return zeroPad(date['get' + utc + 'Seconds']());\n          default:\n            return '%' + p;\n        }\n      });\n    };\n  }\n};\n\n// Given an array of attribute values, convert to a key that\n// can be used in objects.\nvar flatKey = function flatKey(attrVals) {\n  return attrVals.join(String.fromCharCode(0));\n};\n\n/*\nData Model class\n*/\n\nvar PivotData = function () {\n  function PivotData() {\n    var _this = this;\n\n    var inputProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var subtotals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, PivotData);\n\n    this.props = Object.assign({}, PivotData.defaultProps, inputProps);\n    _propTypes2.default.checkPropTypes(PivotData.propTypes, this.props, 'prop', 'PivotData');\n\n    this.aggregator = this.props.aggregatorsFactory(this.props.defaultFormatter)[this.props.aggregatorName](this.props.vals);\n    this.formattedAggregators = this.props.customFormatters && Object.entries(this.props.customFormatters).reduce(function (acc, _ref13) {\n      var _ref14 = _slicedToArray(_ref13, 2),\n          key = _ref14[0],\n          columnFormatter = _ref14[1];\n\n      acc[key] = {};\n      Object.entries(columnFormatter).forEach(function (_ref15) {\n        var _ref16 = _slicedToArray(_ref15, 2),\n            column = _ref16[0],\n            formatter = _ref16[1];\n\n        acc[key][column] = _this.props.aggregatorsFactory(formatter)[_this.props.aggregatorName](_this.props.vals);\n      });\n      return acc;\n    }, {});\n    this.tree = {};\n    this.rowKeys = [];\n    this.colKeys = [];\n    this.rowTotals = {};\n    this.colTotals = {};\n    this.allTotal = this.aggregator(this, [], []);\n    this.subtotals = subtotals;\n    this.sorted = false;\n\n    // iterate through input, accumulating data for cells\n    PivotData.forEachRecord(this.props.data, this.props.derivedAttributes, function (record) {\n      if (_this.filter(record)) {\n        _this.processRecord(record);\n      }\n    });\n  }\n\n  _createClass(PivotData, [{\n    key: 'filter',\n    value: function filter(record) {\n      for (var k in this.props.valueFilter) {\n        if (record[k] in this.props.valueFilter[k]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'getFormattedAggregator',\n    value: function getFormattedAggregator(record, totalsKeys) {\n      var _this2 = this;\n\n      if (!this.formattedAggregators) {\n        return this.aggregator;\n      }\n\n      var _ref17 = Object.entries(record).find(function (_ref19) {\n        var _ref20 = _slicedToArray(_ref19, 2),\n            name = _ref20[0],\n            value = _ref20[1];\n\n        return _this2.formattedAggregators[name] && _this2.formattedAggregators[name][value];\n      }) || [],\n          _ref18 = _slicedToArray(_ref17, 2),\n          groupName = _ref18[0],\n          groupValue = _ref18[1];\n\n      if (!groupName || !groupValue || totalsKeys && !totalsKeys.includes(groupValue)) {\n        return this.aggregator;\n      }\n      return this.formattedAggregators[groupName][groupValue] || this.aggregator;\n    }\n  }, {\n    key: 'forEachMatchingRecord',\n    value: function forEachMatchingRecord(criteria, callback) {\n      var _this3 = this;\n\n      return PivotData.forEachRecord(this.props.data, this.props.derivedAttributes, function (record) {\n        if (!_this3.filter(record)) {\n          return;\n        }\n        for (var k in criteria) {\n          var v = criteria[k];\n          if (v !== (k in record ? record[k] : 'null')) {\n            return;\n          }\n        }\n        callback(record);\n      });\n    }\n  }, {\n    key: 'arrSort',\n    value: function arrSort(attrs, partialOnTop) {\n      var _this4 = this;\n\n      var reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var sortersArr = attrs.map(function (a) {\n        return getSort(_this4.props.sorters, a);\n      });\n      return function (a, b) {\n        var limit = Math.min(a.length, b.length);\n        for (var i = 0; i < limit; i++) {\n          var sorter = sortersArr[i];\n          var comparison = reverse ? sorter(b[i], a[i]) : sorter(a[i], b[i]);\n          if (comparison !== 0) {\n            return comparison;\n          }\n        }\n        return partialOnTop ? a.length - b.length : b.length - a.length;\n      };\n    }\n  }, {\n    key: 'sortKeys',\n    value: function sortKeys() {\n      var _this5 = this;\n\n      if (!this.sorted) {\n        this.sorted = true;\n        var v = function v(r, c) {\n          return _this5.getAggregator(r, c).value();\n        };\n        switch (this.props.rowOrder) {\n          case 'key_z_to_a':\n            this.rowKeys.sort(this.arrSort(this.props.rows, this.subtotals.rowPartialOnTop, true));\n            break;\n          case 'value_a_to_z':\n            this.rowKeys.sort(function (a, b) {\n              return naturalSort(v(a, []), v(b, []));\n            });\n            break;\n          case 'value_z_to_a':\n            this.rowKeys.sort(function (a, b) {\n              return -naturalSort(v(a, []), v(b, []));\n            });\n            break;\n          default:\n            this.rowKeys.sort(this.arrSort(this.props.rows, this.subtotals.rowPartialOnTop));\n        }\n        switch (this.props.colOrder) {\n          case 'key_z_to_a':\n            this.colKeys.sort(this.arrSort(this.props.cols, this.subtotals.colPartialOnTop, true));\n            break;\n          case 'value_a_to_z':\n            this.colKeys.sort(function (a, b) {\n              return naturalSort(v([], a), v([], b));\n            });\n            break;\n          case 'value_z_to_a':\n            this.colKeys.sort(function (a, b) {\n              return -naturalSort(v([], a), v([], b));\n            });\n            break;\n          default:\n            this.colKeys.sort(this.arrSort(this.props.cols, this.subtotals.colPartialOnTop));\n        }\n      }\n    }\n  }, {\n    key: 'getColKeys',\n    value: function getColKeys() {\n      this.sortKeys();\n      return this.colKeys;\n    }\n  }, {\n    key: 'getRowKeys',\n    value: function getRowKeys() {\n      this.sortKeys();\n      return this.rowKeys;\n    }\n  }, {\n    key: 'processRecord',\n    value: function processRecord(record) {\n      // this code is called in a tight loop\n      var colKey = [];\n      var rowKey = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.props.cols[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var x = _step.value;\n\n          colKey.push(x in record ? record[x] : 'null');\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.props.rows[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _x18 = _step2.value;\n\n          rowKey.push(_x18 in record ? record[_x18] : 'null');\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.allTotal.push(record);\n\n      var rowStart = this.subtotals.rowEnabled ? 1 : Math.max(1, rowKey.length);\n      var colStart = this.subtotals.colEnabled ? 1 : Math.max(1, colKey.length);\n\n      var isRowSubtotal = void 0,\n          isColSubtotal = void 0;\n      for (var ri = rowStart; ri <= rowKey.length; ri++) {\n        isRowSubtotal = ri < rowKey.length;\n        var fRowKey = rowKey.slice(0, ri);\n        var flatRowKey = flatKey(fRowKey);\n        if (!this.rowTotals[flatRowKey]) {\n          this.rowKeys.push(fRowKey);\n          this.rowTotals[flatRowKey] = this.getFormattedAggregator(record, rowKey)(this, fRowKey, []);\n        }\n        this.rowTotals[flatRowKey].push(record);\n        this.rowTotals[flatRowKey].isSubtotal = isRowSubtotal;\n      }\n\n      for (var ci = colStart; ci <= colKey.length; ci++) {\n        isColSubtotal = ci < colKey.length;\n        var fColKey = colKey.slice(0, ci);\n        var flatColKey = flatKey(fColKey);\n        if (!this.colTotals[flatColKey]) {\n          this.colKeys.push(fColKey);\n          this.colTotals[flatColKey] = this.getFormattedAggregator(record, colKey)(this, [], fColKey);\n        }\n        this.colTotals[flatColKey].push(record);\n        this.colTotals[flatColKey].isSubtotal = isColSubtotal;\n      }\n\n      // And now fill in for all the sub-cells.\n      for (var _ri = rowStart; _ri <= rowKey.length; _ri++) {\n        isRowSubtotal = _ri < rowKey.length;\n        var _fRowKey = rowKey.slice(0, _ri);\n        var _flatRowKey = flatKey(_fRowKey);\n        if (!this.tree[_flatRowKey]) {\n          this.tree[_flatRowKey] = {};\n        }\n        for (var _ci = colStart; _ci <= colKey.length; _ci++) {\n          isColSubtotal = _ci < colKey.length;\n          var _fColKey = colKey.slice(0, _ci);\n          var _flatColKey = flatKey(_fColKey);\n          if (!this.tree[_flatRowKey][_flatColKey]) {\n            this.tree[_flatRowKey][_flatColKey] = this.getFormattedAggregator(record)(this, _fRowKey, _fColKey);\n          }\n          this.tree[_flatRowKey][_flatColKey].push(record);\n\n          this.tree[_flatRowKey][_flatColKey].isRowSubtotal = isRowSubtotal;\n          this.tree[_flatRowKey][_flatColKey].isColSubtotal = isColSubtotal;\n          this.tree[_flatRowKey][_flatColKey].isSubtotal = isRowSubtotal || isColSubtotal;\n        }\n      }\n    }\n  }, {\n    key: 'getAggregator',\n    value: function getAggregator(rowKey, colKey) {\n      var agg = void 0;\n      var flatRowKey = flatKey(rowKey);\n      var flatColKey = flatKey(colKey);\n      if (rowKey.length === 0 && colKey.length === 0) {\n        agg = this.allTotal;\n      } else if (rowKey.length === 0) {\n        agg = this.colTotals[flatColKey];\n      } else if (colKey.length === 0) {\n        agg = this.rowTotals[flatRowKey];\n      } else {\n        agg = this.tree[flatRowKey][flatColKey];\n      }\n      return agg || {\n        value: function value() {\n          return null;\n        },\n        format: function format() {\n          return '';\n        }\n      };\n    }\n  }]);\n\n  return PivotData;\n}();\n\n// can handle arrays or jQuery selections of tables\n\n\nPivotData.forEachRecord = function (input, derivedAttributes, f) {\n  var addRecord = void 0,\n      record = void 0;\n  if (Object.getOwnPropertyNames(derivedAttributes).length === 0) {\n    addRecord = f;\n  } else {\n    addRecord = function addRecord(record) {\n      for (var k in derivedAttributes) {\n        var derived = derivedAttributes[k](record);\n        if (derived !== null) {\n          record[k] = derived;\n        }\n      }\n      return f(record);\n    };\n  }\n\n  // if it's a function, have it call us back\n  if (typeof input === 'function') {\n    return input(addRecord);\n  } else if (Array.isArray(input)) {\n    if (Array.isArray(input[0])) {\n      // array of arrays\n      return function () {\n        var result = [];\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = Object.keys(input || {})[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var i = _step3.value;\n\n            var compactRecord = input[i];\n            if (i > 0) {\n              record = {};\n              var _iteratorNormalCompletion4 = true;\n              var _didIteratorError4 = false;\n              var _iteratorError4 = undefined;\n\n              try {\n                for (var _iterator4 = Object.keys(input[0] || {})[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                  var j = _step4.value;\n\n                  var k = input[0][j];\n                  record[k] = compactRecord[j];\n                }\n              } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                    _iterator4.return();\n                  }\n                } finally {\n                  if (_didIteratorError4) {\n                    throw _iteratorError4;\n                  }\n                }\n              }\n\n              result.push(addRecord(record));\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        return result;\n      }();\n    }\n\n    // array of objects\n    return function () {\n      var result1 = [];\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = Array.from(input)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          record = _step5.value;\n\n          result1.push(addRecord(record));\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return result1;\n    }();\n  }\n  throw new Error('unknown input format');\n};\n\nPivotData.defaultProps = {\n  aggregators: aggregators,\n  cols: [],\n  rows: [],\n  vals: [],\n  aggregatorName: 'Count',\n  sorters: {},\n  valueFilter: {},\n  rowOrder: 'key_a_to_z',\n  colOrder: 'key_a_to_z',\n  derivedAttributes: {}\n};\n\nPivotData.propTypes = {\n  data: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.object, _propTypes2.default.func]).isRequired,\n  aggregatorName: _propTypes2.default.string,\n  cols: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  rows: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  vals: _propTypes2.default.arrayOf(_propTypes2.default.string),\n  valueFilter: _propTypes2.default.objectOf(_propTypes2.default.objectOf(_propTypes2.default.bool)),\n  sorters: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.objectOf(_propTypes2.default.func)]),\n  derivedAttributes: _propTypes2.default.objectOf(_propTypes2.default.func),\n  rowOrder: _propTypes2.default.oneOf(['key_a_to_z', 'key_z_to_a', 'value_a_to_z', 'value_z_to_a']),\n  colOrder: _propTypes2.default.oneOf(['key_a_to_z', 'key_z_to_a', 'value_a_to_z', 'value_z_to_a'])\n};\n\nexports.aggregatorTemplates = aggregatorTemplates;\nexports.aggregators = aggregators;\nexports.derivers = derivers;\nexports.locales = locales;\nexports.naturalSort = naturalSort;\nexports.numberFormat = numberFormat;\nexports.getSort = getSort;\nexports.sortAs = sortAs;\nexports.flatKey = flatKey;\nexports.PivotData = PivotData;\n//# sourceMappingURL=Utilities.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3JlYWN0LXBpdm90dGFibGUvVXRpbGl0aWVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcnNldC11aS9wbHVnaW4tY2hhcnQtcGl2b3QtdGFibGUvbm9kZV9tb2R1bGVzL0BzdXBlcnNldC11aS9yZWFjdC1waXZvdHRhYmxlL1V0aWxpdGllcy5qcz8zZWYzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUGl2b3REYXRhID0gZXhwb3J0cy5mbGF0S2V5ID0gZXhwb3J0cy5zb3J0QXMgPSBleHBvcnRzLmdldFNvcnQgPSBleHBvcnRzLm51bWJlckZvcm1hdCA9IGV4cG9ydHMubmF0dXJhbFNvcnQgPSBleHBvcnRzLmxvY2FsZXMgPSBleHBvcnRzLmRlcml2ZXJzID0gZXhwb3J0cy5hZ2dyZWdhdG9ycyA9IGV4cG9ydHMuYWdncmVnYXRvclRlbXBsYXRlcyA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbi8qXG4gKiBkZWNhZmZlaW5hdGUgc3VnZ2VzdGlvbnM6XG4gKiBEUzEwMTogUmVtb3ZlIHVubmVjZXNzYXJ5IHVzZSBvZiBBcnJheS5mcm9tXG4gKiBEUzEwMjogUmVtb3ZlIHVubmVjZXNzYXJ5IGNvZGUgY3JlYXRlZCBiZWNhdXNlIG9mIGltcGxpY2l0IHJldHVybnNcbiAqIERTMTA0OiBBdm9pZCBpbmxpbmUgYXNzaWdubWVudHNcbiAqIERTMjAxOiBTaW1wbGlmeSBjb21wbGV4IGRlc3RydWN0dXJlIGFzc2lnbm1lbnRzXG4gKiBEUzIwMzogUmVtb3ZlIGB8fCB7fWAgZnJvbSBjb252ZXJ0ZWQgZm9yLW93biBsb29wc1xuICogRFMyMDU6IENvbnNpZGVyIHJld29ya2luZyBjb2RlIHRvIGF2b2lkIHVzZSBvZiBJSUZFc1xuICogRFMyMDc6IENvbnNpZGVyIHNob3J0ZXIgdmFyaWF0aW9ucyBvZiBudWxsIGNoZWNrc1xuICogRnVsbCBkb2NzOiBodHRwczovL2dpdGh1Yi5jb20vZGVjYWZmZWluYXRlL2RlY2FmZmVpbmF0ZS9ibG9iL21hc3Rlci9kb2NzL3N1Z2dlc3Rpb25zLm1kXG4gKi9cblxudmFyIGFkZFNlcGFyYXRvcnMgPSBmdW5jdGlvbiBhZGRTZXBhcmF0b3JzKG5TdHIsIHRob3VzYW5kc1NlcCwgZGVjaW1hbFNlcCkge1xuICB2YXIgeCA9IFN0cmluZyhuU3RyKS5zcGxpdCgnLicpO1xuICB2YXIgeDEgPSB4WzBdO1xuICB2YXIgeDIgPSB4Lmxlbmd0aCA+IDEgPyBkZWNpbWFsU2VwICsgeFsxXSA6ICcnO1xuICB2YXIgcmd4ID0gLyhcXGQrKShcXGR7M30pLztcbiAgd2hpbGUgKHJneC50ZXN0KHgxKSkge1xuICAgIHgxID0geDEucmVwbGFjZShyZ3gsICckMScgKyB0aG91c2FuZHNTZXAgKyAnJDInKTtcbiAgfVxuICByZXR1cm4geDEgKyB4Mjtcbn07XG5cbnZhciBudW1iZXJGb3JtYXQgPSBmdW5jdGlvbiBudW1iZXJGb3JtYXQob3B0c19pbikge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZGlnaXRzQWZ0ZXJEZWNpbWFsOiAyLFxuICAgIHNjYWxlcjogMSxcbiAgICB0aG91c2FuZHNTZXA6ICcsJyxcbiAgICBkZWNpbWFsU2VwOiAnLicsXG4gICAgcHJlZml4OiAnJyxcbiAgICBzdWZmaXg6ICcnXG4gIH07XG4gIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdHNfaW4pO1xuICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICBpZiAoaXNOYU4oeCkgfHwgIWlzRmluaXRlKHgpKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBhZGRTZXBhcmF0b3JzKChvcHRzLnNjYWxlciAqIHgpLnRvRml4ZWQob3B0cy5kaWdpdHNBZnRlckRlY2ltYWwpLCBvcHRzLnRob3VzYW5kc1NlcCwgb3B0cy5kZWNpbWFsU2VwKTtcbiAgICByZXR1cm4gJycgKyBvcHRzLnByZWZpeCArIHJlc3VsdCArIG9wdHMuc3VmZml4O1xuICB9O1xufTtcblxudmFyIHJ4ID0gLyhcXGQrKXwoXFxEKykvZztcbnZhciByZCA9IC9cXGQvO1xudmFyIHJ6ID0gL14wLztcbnZhciBuYXR1cmFsU29ydCA9IGZ1bmN0aW9uIG5hdHVyYWxTb3J0KGFzLCBicykge1xuICAvLyBudWxscyBmaXJzdFxuICBpZiAoYnMgIT09IG51bGwgJiYgYXMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGFzICE9PSBudWxsICYmIGJzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvLyB0aGVuIHJhdyBOYU5zXG4gIGlmICh0eXBlb2YgYXMgPT09ICdudW1iZXInICYmIGlzTmFOKGFzKSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAodHlwZW9mIGJzID09PSAnbnVtYmVyJyAmJiBpc05hTihicykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8vIG51bWJlcnMgYW5kIG51bWJlcnkgc3RyaW5ncyBncm91cCB0b2dldGhlclxuICB2YXIgbmFzID0gTnVtYmVyKGFzKTtcbiAgdmFyIG5icyA9IE51bWJlcihicyk7XG4gIGlmIChuYXMgPCBuYnMpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKG5hcyA+IG5icykge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gd2l0aGluIHRoYXQsIHRydWUgbnVtYmVycyBiZWZvcmUgbnVtYmVyeSBzdHJpbmdzXG4gIGlmICh0eXBlb2YgYXMgPT09ICdudW1iZXInICYmIHR5cGVvZiBicyAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHR5cGVvZiBicyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFzICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGlmICh0eXBlb2YgYXMgPT09ICdudW1iZXInICYmIHR5cGVvZiBicyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vICdJbmZpbml0eScgaXMgYSB0ZXh0dWFsIG51bWJlciwgc28gbGVzcyB0aGFuICdBJ1xuICBpZiAoaXNOYU4obmJzKSAmJiAhaXNOYU4obmFzKSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoaXNOYU4obmFzKSAmJiAhaXNOYU4obmJzKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gZmluYWxseSwgXCJzbWFydFwiIHN0cmluZyBzb3J0aW5nIHBlciBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MzczNDIxLzExMjg3MVxuICB2YXIgYSA9IFN0cmluZyhhcyk7XG4gIHZhciBiID0gU3RyaW5nKGJzKTtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoIXJkLnRlc3QoYSkgfHwgIXJkLnRlc3QoYikpIHtcbiAgICByZXR1cm4gYSA+IGIgPyAxIDogLTE7XG4gIH1cblxuICAvLyBzcGVjaWFsIHRyZWF0bWVudCBmb3Igc3RyaW5ncyBjb250YWluaW5nIGRpZ2l0c1xuICBhID0gYS5tYXRjaChyeCk7XG4gIGIgPSBiLm1hdGNoKHJ4KTtcbiAgd2hpbGUgKGEubGVuZ3RoICYmIGIubGVuZ3RoKSB7XG4gICAgdmFyIGExID0gYS5zaGlmdCgpO1xuICAgIHZhciBiMSA9IGIuc2hpZnQoKTtcbiAgICBpZiAoYTEgIT09IGIxKSB7XG4gICAgICBpZiAocmQudGVzdChhMSkgJiYgcmQudGVzdChiMSkpIHtcbiAgICAgICAgcmV0dXJuIGExLnJlcGxhY2UocnosICcuMCcpIC0gYjEucmVwbGFjZShyeiwgJy4wJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTEgPiBiMSA/IDEgOiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG59O1xuXG52YXIgc29ydEFzID0gZnVuY3Rpb24gc29ydEFzKG9yZGVyKSB7XG4gIHZhciBtYXBwaW5nID0ge307XG5cbiAgLy8gc29ydCBsb3dlcmNhc2VkIGtleXMgc2ltaWxhcmx5XG4gIHZhciBsX21hcHBpbmcgPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvcmRlcikge1xuICAgIHZhciB4ID0gb3JkZXJbaV07XG4gICAgbWFwcGluZ1t4XSA9IGk7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgICAgbF9tYXBwaW5nW3gudG9Mb3dlckNhc2UoKV0gPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYSBpbiBtYXBwaW5nICYmIGIgaW4gbWFwcGluZykge1xuICAgICAgcmV0dXJuIG1hcHBpbmdbYV0gLSBtYXBwaW5nW2JdO1xuICAgIH0gZWxzZSBpZiAoYSBpbiBtYXBwaW5nKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChiIGluIG1hcHBpbmcpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoYSBpbiBsX21hcHBpbmcgJiYgYiBpbiBsX21hcHBpbmcpIHtcbiAgICAgIHJldHVybiBsX21hcHBpbmdbYV0gLSBsX21hcHBpbmdbYl07XG4gICAgfSBlbHNlIGlmIChhIGluIGxfbWFwcGluZykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoYiBpbiBsX21hcHBpbmcpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gbmF0dXJhbFNvcnQoYSwgYik7XG4gIH07XG59O1xuXG52YXIgZ2V0U29ydCA9IGZ1bmN0aW9uIGdldFNvcnQoc29ydGVycywgYXR0cikge1xuICBpZiAoc29ydGVycykge1xuICAgIGlmICh0eXBlb2Ygc29ydGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHNvcnQgPSBzb3J0ZXJzKGF0dHIpO1xuICAgICAgaWYgKHR5cGVvZiBzb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBzb3J0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXR0ciBpbiBzb3J0ZXJzKSB7XG4gICAgICByZXR1cm4gc29ydGVyc1thdHRyXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5hdHVyYWxTb3J0O1xufTtcblxuLy8gYWdncmVnYXRvciB0ZW1wbGF0ZXMgZGVmYXVsdCB0byBVUyBudW1iZXIgZm9ybWF0dGluZyBidXQgdGhpcyBpcyBvdmVycmlkZWFibGVcbnZhciB1c0ZtdCA9IG51bWJlckZvcm1hdCgpO1xudmFyIHVzRm10SW50ID0gbnVtYmVyRm9ybWF0KHsgZGlnaXRzQWZ0ZXJEZWNpbWFsOiAwIH0pO1xudmFyIHVzRm10UGN0ID0gbnVtYmVyRm9ybWF0KHtcbiAgZGlnaXRzQWZ0ZXJEZWNpbWFsOiAxLFxuICBzY2FsZXI6IDEwMCxcbiAgc3VmZml4OiAnJSdcbn0pO1xuXG52YXIgYWdncmVnYXRvclRlbXBsYXRlcyA9IHtcbiAgY291bnQ6IGZ1bmN0aW9uIGNvdW50KCkge1xuICAgIHZhciBmb3JtYXR0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHVzRm10SW50O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgcHVzaDogZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBmb3JtYXQ6IGZvcm1hdHRlclxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICB1bmlxdWVzOiBmdW5jdGlvbiB1bmlxdWVzKGZuKSB7XG4gICAgdmFyIGZvcm1hdHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdXNGbXRJbnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpLFxuICAgICAgICAgIGF0dHIgPSBfcmVmMlswXTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bmlxOiBbXSxcbiAgICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5mcm9tKHRoaXMudW5pcSkuaW5jbHVkZXMocmVjb3JkW2F0dHJdKSkge1xuICAgICAgICAgICAgICB0aGlzLnVuaXEucHVzaChyZWNvcmRbYXR0cl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMudW5pcSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGZvcm1hdDogZm9ybWF0dGVyLFxuICAgICAgICAgIG51bUlucHV0czogdHlwZW9mIGF0dHIgIT09ICd1bmRlZmluZWQnID8gMCA6IDFcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgc3VtOiBmdW5jdGlvbiBzdW0oKSB7XG4gICAgdmFyIGZvcm1hdHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdXNGbXQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMSksXG4gICAgICAgICAgYXR0ciA9IF9yZWY0WzBdO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1bTogMCxcbiAgICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZUZsb2F0KHJlY29yZFthdHRyXSkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3VtICs9IHBhcnNlRmxvYXQocmVjb3JkW2F0dHJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1bTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZm9ybWF0OiBmb3JtYXR0ZXIsXG4gICAgICAgICAgbnVtSW5wdXRzOiB0eXBlb2YgYXR0ciAhPT0gJ3VuZGVmaW5lZCcgPyAwIDogMVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBleHRyZW1lczogZnVuY3Rpb24gZXh0cmVtZXMobW9kZSkge1xuICAgIHZhciBmb3JtYXR0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHVzRm10O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDEpLFxuICAgICAgICAgIGF0dHIgPSBfcmVmNlswXTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsOiBudWxsLFxuICAgICAgICAgIHNvcnRlcjogZ2V0U29ydCh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhLnNvcnRlcnMgOiBudWxsLCBhdHRyKSxcbiAgICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIHggPSByZWNvcmRbYXR0cl07XG4gICAgICAgICAgICBpZiAoWydtaW4nLCAnbWF4J10uaW5jbHVkZXMobW9kZSkpIHtcbiAgICAgICAgICAgICAgeCA9IHBhcnNlRmxvYXQoeCk7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4oeCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbCA9IE1hdGhbbW9kZV0oeCwgdGhpcy52YWwgIT09IG51bGwgPyB0aGlzLnZhbCA6IHgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ2ZpcnN0JyAmJiB0aGlzLnNvcnRlcih4LCB0aGlzLnZhbCAhPT0gbnVsbCA/IHRoaXMudmFsIDogeCkgPD0gMCkge1xuICAgICAgICAgICAgICB0aGlzLnZhbCA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ2xhc3QnICYmIHRoaXMuc29ydGVyKHgsIHRoaXMudmFsICE9PSBudWxsID8gdGhpcy52YWwgOiB4KSA+PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMudmFsID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHgpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih4KSkge1xuICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIoeCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIG51bUlucHV0czogdHlwZW9mIGF0dHIgIT09ICd1bmRlZmluZWQnID8gMCA6IDFcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgcXVhbnRpbGU6IGZ1bmN0aW9uIHF1YW50aWxlKHEpIHtcbiAgICB2YXIgZm9ybWF0dGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB1c0ZtdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoX3JlZjcpIHtcbiAgICAgIHZhciBfcmVmOCA9IF9zbGljZWRUb0FycmF5KF9yZWY3LCAxKSxcbiAgICAgICAgICBhdHRyID0gX3JlZjhbMF07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsczogW10sXG4gICAgICAgICAgcHVzaDogZnVuY3Rpb24gcHVzaChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChyZWNvcmRbYXR0cl0pO1xuICAgICAgICAgICAgaWYgKCFpc05hTih4KSkge1xuICAgICAgICAgICAgICB0aGlzLnZhbHMucHVzaCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWxzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaSA9ICh0aGlzLnZhbHMubGVuZ3RoIC0gMSkgKiBxO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhbHNbTWF0aC5mbG9vcihpKV0gKyB0aGlzLnZhbHNbTWF0aC5jZWlsKGkpXSkgLyAyLjA7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGZvcm1hdDogZm9ybWF0dGVyLFxuICAgICAgICAgIG51bUlucHV0czogdHlwZW9mIGF0dHIgIT09ICd1bmRlZmluZWQnID8gMCA6IDFcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgcnVubmluZ1N0YXQ6IGZ1bmN0aW9uIHJ1bm5pbmdTdGF0KCkge1xuICAgIHZhciBtb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnbWVhbic7XG4gICAgdmFyIGRkb2YgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgdmFyIGZvcm1hdHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdXNGbXQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF9yZWY5KSB7XG4gICAgICB2YXIgX3JlZjEwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjksIDEpLFxuICAgICAgICAgIGF0dHIgPSBfcmVmMTBbMF07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbjogMC4wLFxuICAgICAgICAgIG06IDAuMCxcbiAgICAgICAgICBzOiAwLjAsXG4gICAgICAgICAgcHVzaDogZnVuY3Rpb24gcHVzaChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChyZWNvcmRbYXR0cl0pO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubiArPSAxLjA7XG4gICAgICAgICAgICBpZiAodGhpcy5uID09PSAxLjApIHtcbiAgICAgICAgICAgICAgdGhpcy5tID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtX25ldyA9IHRoaXMubSArICh4IC0gdGhpcy5tKSAvIHRoaXMubjtcbiAgICAgICAgICAgIHRoaXMucyA9IHRoaXMucyArICh4IC0gdGhpcy5tKSAqICh4IC0gbV9uZXcpO1xuICAgICAgICAgICAgdGhpcy5tID0gbV9uZXc7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ21lYW4nKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm4gPD0gZGRvZikge1xuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICBjYXNlICd2YXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnMgLyAodGhpcy5uIC0gZGRvZik7XG4gICAgICAgICAgICAgIGNhc2UgJ3N0ZGV2JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMucyAvICh0aGlzLm4gLSBkZG9mKSk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIG1vZGUgZm9yIHJ1bm5pbmdTdGF0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGZvcm1hdDogZm9ybWF0dGVyLFxuICAgICAgICAgIG51bUlucHV0czogdHlwZW9mIGF0dHIgIT09ICd1bmRlZmluZWQnID8gMCA6IDFcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgc3VtT3ZlclN1bTogZnVuY3Rpb24gc3VtT3ZlclN1bSgpIHtcbiAgICB2YXIgZm9ybWF0dGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB1c0ZtdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoX3JlZjExKSB7XG4gICAgICB2YXIgX3JlZjEyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjExLCAyKSxcbiAgICAgICAgICBudW0gPSBfcmVmMTJbMF0sXG4gICAgICAgICAgZGVub20gPSBfcmVmMTJbMV07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VtTnVtOiAwLFxuICAgICAgICAgIHN1bURlbm9tOiAwLFxuICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2gocmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlRmxvYXQocmVjb3JkW251bV0pKSkge1xuICAgICAgICAgICAgICB0aGlzLnN1bU51bSArPSBwYXJzZUZsb2F0KHJlY29yZFtudW1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VGbG9hdChyZWNvcmRbZGVub21dKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdW1EZW5vbSArPSBwYXJzZUZsb2F0KHJlY29yZFtkZW5vbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VtTnVtIC8gdGhpcy5zdW1EZW5vbTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZm9ybWF0OiBmb3JtYXR0ZXIsXG4gICAgICAgICAgbnVtSW5wdXRzOiB0eXBlb2YgbnVtICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVub20gIT09ICd1bmRlZmluZWQnID8gMCA6IDJcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgZnJhY3Rpb25PZjogZnVuY3Rpb24gZnJhY3Rpb25PZih3cmFwcGVkKSB7XG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd0b3RhbCc7XG4gICAgdmFyIGZvcm1hdHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdXNGbXRQY3Q7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHggPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgeFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCByb3dLZXksIGNvbEtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNlbGVjdG9yOiB7IHRvdGFsOiBbW10sIFtdXSwgcm93OiBbcm93S2V5LCBbXV0sIGNvbDogW1tdLCBjb2xLZXldIH1bdHlwZV0sXG4gICAgICAgICAgaW5uZXI6IHdyYXBwZWQuYXBwbHkodW5kZWZpbmVkLCBfdG9Db25zdW1hYmxlQXJyYXkoQXJyYXkuZnJvbSh4IHx8IFtdKSkpKGRhdGEsIHJvd0tleSwgY29sS2V5KSxcbiAgICAgICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKHJlY29yZCkge1xuICAgICAgICAgICAgdGhpcy5pbm5lci5wdXNoKHJlY29yZCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGZvcm1hdDogZm9ybWF0dGVyLFxuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlubmVyLnZhbHVlKCkgLyBkYXRhLmdldEFnZ3JlZ2F0b3IuYXBwbHkoZGF0YSwgX3RvQ29uc3VtYWJsZUFycmF5KEFycmF5LmZyb20odGhpcy5zZWxlY3RvciB8fCBbXSkpKS5pbm5lci52YWx1ZSgpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBudW1JbnB1dHM6IHdyYXBwZWQuYXBwbHkodW5kZWZpbmVkLCBfdG9Db25zdW1hYmxlQXJyYXkoQXJyYXkuZnJvbSh4IHx8IFtdKSkpKCkubnVtSW5wdXRzXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn07XG5cbmFnZ3JlZ2F0b3JUZW1wbGF0ZXMuY291bnRVbmlxdWUgPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gYWdncmVnYXRvclRlbXBsYXRlcy51bmlxdWVzKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHgubGVuZ3RoO1xuICB9LCBmKTtcbn07XG5hZ2dyZWdhdG9yVGVtcGxhdGVzLmxpc3RVbmlxdWUgPSBmdW5jdGlvbiAocywgZikge1xuICByZXR1cm4gYWdncmVnYXRvclRlbXBsYXRlcy51bmlxdWVzKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHguam9pbihzKTtcbiAgfSwgZiB8fCBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4O1xuICB9KTtcbn07XG5hZ2dyZWdhdG9yVGVtcGxhdGVzLm1heCA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBhZ2dyZWdhdG9yVGVtcGxhdGVzLmV4dHJlbWVzKCdtYXgnLCBmKTtcbn07XG5hZ2dyZWdhdG9yVGVtcGxhdGVzLm1pbiA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBhZ2dyZWdhdG9yVGVtcGxhdGVzLmV4dHJlbWVzKCdtaW4nLCBmKTtcbn07XG5hZ2dyZWdhdG9yVGVtcGxhdGVzLmZpcnN0ID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuZXh0cmVtZXMoJ2ZpcnN0JywgZik7XG59O1xuYWdncmVnYXRvclRlbXBsYXRlcy5sYXN0ID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIGFnZ3JlZ2F0b3JUZW1wbGF0ZXMuZXh0cmVtZXMoJ2xhc3QnLCBmKTtcbn07XG5hZ2dyZWdhdG9yVGVtcGxhdGVzLm1lZGlhbiA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiBhZ2dyZWdhdG9yVGVtcGxhdGVzLnF1YW50aWxlKDAuNSwgZik7XG59O1xuYWdncmVnYXRvclRlbXBsYXRlcy5hdmVyYWdlID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIGFnZ3JlZ2F0b3JUZW1wbGF0ZXMucnVubmluZ1N0YXQoJ21lYW4nLCAxLCBmKTtcbn07XG5hZ2dyZWdhdG9yVGVtcGxhdGVzLnZhciA9IGZ1bmN0aW9uIChkZG9mLCBmKSB7XG4gIHJldHVybiBhZ2dyZWdhdG9yVGVtcGxhdGVzLnJ1bm5pbmdTdGF0KCd2YXInLCBkZG9mLCBmKTtcbn07XG5hZ2dyZWdhdG9yVGVtcGxhdGVzLnN0ZGV2ID0gZnVuY3Rpb24gKGRkb2YsIGYpIHtcbiAgcmV0dXJuIGFnZ3JlZ2F0b3JUZW1wbGF0ZXMucnVubmluZ1N0YXQoJ3N0ZGV2JywgZGRvZiwgZik7XG59O1xuXG4vLyBkZWZhdWx0IGFnZ3JlZ2F0b3JzICYgcmVuZGVyZXJzIHVzZSBVUyBuYW1pbmcgYW5kIG51bWJlciBmb3JtYXR0aW5nXG52YXIgYWdncmVnYXRvcnMgPSBmdW5jdGlvbiAodHBsKSB7XG4gIHJldHVybiB7XG4gICAgQ291bnQ6IHRwbC5jb3VudCh1c0ZtdEludCksXG4gICAgJ0NvdW50IFVuaXF1ZSBWYWx1ZXMnOiB0cGwuY291bnRVbmlxdWUodXNGbXRJbnQpLFxuICAgICdMaXN0IFVuaXF1ZSBWYWx1ZXMnOiB0cGwubGlzdFVuaXF1ZSgnLCAnKSxcbiAgICBTdW06IHRwbC5zdW0odXNGbXQpLFxuICAgICdJbnRlZ2VyIFN1bSc6IHRwbC5zdW0odXNGbXRJbnQpLFxuICAgIEF2ZXJhZ2U6IHRwbC5hdmVyYWdlKHVzRm10KSxcbiAgICBNZWRpYW46IHRwbC5tZWRpYW4odXNGbXQpLFxuICAgICdTYW1wbGUgVmFyaWFuY2UnOiB0cGwudmFyKDEsIHVzRm10KSxcbiAgICAnU2FtcGxlIFN0YW5kYXJkIERldmlhdGlvbic6IHRwbC5zdGRldigxLCB1c0ZtdCksXG4gICAgTWluaW11bTogdHBsLm1pbih1c0ZtdCksXG4gICAgTWF4aW11bTogdHBsLm1heCh1c0ZtdCksXG4gICAgRmlyc3Q6IHRwbC5maXJzdCh1c0ZtdCksXG4gICAgTGFzdDogdHBsLmxhc3QodXNGbXQpLFxuICAgICdTdW0gb3ZlciBTdW0nOiB0cGwuc3VtT3ZlclN1bSh1c0ZtdCksXG4gICAgJ1N1bSBhcyBGcmFjdGlvbiBvZiBUb3RhbCc6IHRwbC5mcmFjdGlvbk9mKHRwbC5zdW0oKSwgJ3RvdGFsJywgdXNGbXRQY3QpLFxuICAgICdTdW0gYXMgRnJhY3Rpb24gb2YgUm93cyc6IHRwbC5mcmFjdGlvbk9mKHRwbC5zdW0oKSwgJ3JvdycsIHVzRm10UGN0KSxcbiAgICAnU3VtIGFzIEZyYWN0aW9uIG9mIENvbHVtbnMnOiB0cGwuZnJhY3Rpb25PZih0cGwuc3VtKCksICdjb2wnLCB1c0ZtdFBjdCksXG4gICAgJ0NvdW50IGFzIEZyYWN0aW9uIG9mIFRvdGFsJzogdHBsLmZyYWN0aW9uT2YodHBsLmNvdW50KCksICd0b3RhbCcsIHVzRm10UGN0KSxcbiAgICAnQ291bnQgYXMgRnJhY3Rpb24gb2YgUm93cyc6IHRwbC5mcmFjdGlvbk9mKHRwbC5jb3VudCgpLCAncm93JywgdXNGbXRQY3QpLFxuICAgICdDb3VudCBhcyBGcmFjdGlvbiBvZiBDb2x1bW5zJzogdHBsLmZyYWN0aW9uT2YodHBsLmNvdW50KCksICdjb2wnLCB1c0ZtdFBjdClcbiAgfTtcbn0oYWdncmVnYXRvclRlbXBsYXRlcyk7XG5cbnZhciBsb2NhbGVzID0ge1xuICBlbjoge1xuICAgIGFnZ3JlZ2F0b3JzOiBhZ2dyZWdhdG9ycyxcbiAgICBsb2NhbGVTdHJpbmdzOiB7XG4gICAgICByZW5kZXJFcnJvcjogJ0FuIGVycm9yIG9jY3VycmVkIHJlbmRlcmluZyB0aGUgUGl2b3RUYWJsZSByZXN1bHRzLicsXG4gICAgICBjb21wdXRlRXJyb3I6ICdBbiBlcnJvciBvY2N1cnJlZCBjb21wdXRpbmcgdGhlIFBpdm90VGFibGUgcmVzdWx0cy4nLFxuICAgICAgdWlSZW5kZXJFcnJvcjogJ0FuIGVycm9yIG9jY3VycmVkIHJlbmRlcmluZyB0aGUgUGl2b3RUYWJsZSBVSS4nLFxuICAgICAgc2VsZWN0QWxsOiAnU2VsZWN0IEFsbCcsXG4gICAgICBzZWxlY3ROb25lOiAnU2VsZWN0IE5vbmUnLFxuICAgICAgdG9vTWFueTogJyh0b28gbWFueSB0byBsaXN0KScsXG4gICAgICBmaWx0ZXJSZXN1bHRzOiAnRmlsdGVyIHZhbHVlcycsXG4gICAgICBhcHBseTogJ0FwcGx5JyxcbiAgICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgICB0b3RhbHM6ICdUb3RhbHMnLFxuICAgICAgdnM6ICd2cycsXG4gICAgICBieTogJ2J5J1xuICAgIH1cbiAgfVxufTtcblxuLy8gZGF0ZUZvcm1hdCBkZXJpdmVyIGwxMG4gcmVxdWlyZXMgbW9udGggYW5kIGRheSBuYW1lcyB0byBiZSBwYXNzZWQgaW4gZGlyZWN0bHlcbnZhciBtdGhOYW1lc0VuID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xudmFyIGRheU5hbWVzRW4gPSBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddO1xudmFyIHplcm9QYWQgPSBmdW5jdGlvbiB6ZXJvUGFkKG51bWJlcikge1xuICByZXR1cm4gKCcwJyArIG51bWJlcikuc3Vic3RyKC0yLCAyKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuXG52YXIgZGVyaXZlcnMgPSB7XG4gIGJpbjogZnVuY3Rpb24gYmluKGNvbCwgYmluV2lkdGgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgcmV0dXJuIHJlY29yZFtjb2xdIC0gcmVjb3JkW2NvbF0gJSBiaW5XaWR0aDtcbiAgICB9O1xuICB9LFxuICBkYXRlRm9ybWF0OiBmdW5jdGlvbiBkYXRlRm9ybWF0KGNvbCwgZm9ybWF0U3RyaW5nKSB7XG4gICAgdmFyIHV0Y091dHB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdmFyIG10aE5hbWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBtdGhOYW1lc0VuO1xuICAgIHZhciBkYXlOYW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZGF5TmFtZXNFbjtcblxuICAgIHZhciB1dGMgPSB1dGNPdXRwdXQgPyAnVVRDJyA6ICcnO1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUucGFyc2UocmVjb3JkW2NvbF0pKTtcbiAgICAgIGlmIChpc05hTihkYXRlKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9ybWF0U3RyaW5nLnJlcGxhY2UoLyUoLikvZywgZnVuY3Rpb24gKG0sIHApIHtcbiAgICAgICAgc3dpdGNoIChwKSB7XG4gICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVsnZ2V0JyArIHV0YyArICdGdWxsWWVhciddKCk7XG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZChkYXRlWydnZXQnICsgdXRjICsgJ01vbnRoJ10oKSArIDEpO1xuICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgcmV0dXJuIG10aE5hbWVzW2RhdGVbJ2dldCcgKyB1dGMgKyAnTW9udGgnXSgpXTtcbiAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIHJldHVybiB6ZXJvUGFkKGRhdGVbJ2dldCcgKyB1dGMgKyAnRGF0ZSddKCkpO1xuICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgcmV0dXJuIGRheU5hbWVzW2RhdGVbJ2dldCcgKyB1dGMgKyAnRGF5J10oKV07XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVsnZ2V0JyArIHV0YyArICdEYXknXSgpO1xuICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWQoZGF0ZVsnZ2V0JyArIHV0YyArICdIb3VycyddKCkpO1xuICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWQoZGF0ZVsnZ2V0JyArIHV0YyArICdNaW51dGVzJ10oKSk7XG4gICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICByZXR1cm4gemVyb1BhZChkYXRlWydnZXQnICsgdXRjICsgJ1NlY29uZHMnXSgpKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICclJyArIHA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn07XG5cbi8vIEdpdmVuIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSB2YWx1ZXMsIGNvbnZlcnQgdG8gYSBrZXkgdGhhdFxuLy8gY2FuIGJlIHVzZWQgaW4gb2JqZWN0cy5cbnZhciBmbGF0S2V5ID0gZnVuY3Rpb24gZmxhdEtleShhdHRyVmFscykge1xuICByZXR1cm4gYXR0clZhbHMuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKDApKTtcbn07XG5cbi8qXG5EYXRhIE1vZGVsIGNsYXNzXG4qL1xuXG52YXIgUGl2b3REYXRhID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQaXZvdERhdGEoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBpbnB1dFByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgc3VidG90YWxzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQaXZvdERhdGEpO1xuXG4gICAgdGhpcy5wcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIFBpdm90RGF0YS5kZWZhdWx0UHJvcHMsIGlucHV0UHJvcHMpO1xuICAgIF9wcm9wVHlwZXMyLmRlZmF1bHQuY2hlY2tQcm9wVHlwZXMoUGl2b3REYXRhLnByb3BUeXBlcywgdGhpcy5wcm9wcywgJ3Byb3AnLCAnUGl2b3REYXRhJyk7XG5cbiAgICB0aGlzLmFnZ3JlZ2F0b3IgPSB0aGlzLnByb3BzLmFnZ3JlZ2F0b3JzRmFjdG9yeSh0aGlzLnByb3BzLmRlZmF1bHRGb3JtYXR0ZXIpW3RoaXMucHJvcHMuYWdncmVnYXRvck5hbWVdKHRoaXMucHJvcHMudmFscyk7XG4gICAgdGhpcy5mb3JtYXR0ZWRBZ2dyZWdhdG9ycyA9IHRoaXMucHJvcHMuY3VzdG9tRm9ybWF0dGVycyAmJiBPYmplY3QuZW50cmllcyh0aGlzLnByb3BzLmN1c3RvbUZvcm1hdHRlcnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfcmVmMTMpIHtcbiAgICAgIHZhciBfcmVmMTQgPSBfc2xpY2VkVG9BcnJheShfcmVmMTMsIDIpLFxuICAgICAgICAgIGtleSA9IF9yZWYxNFswXSxcbiAgICAgICAgICBjb2x1bW5Gb3JtYXR0ZXIgPSBfcmVmMTRbMV07XG5cbiAgICAgIGFjY1trZXldID0ge307XG4gICAgICBPYmplY3QuZW50cmllcyhjb2x1bW5Gb3JtYXR0ZXIpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYxNSkge1xuICAgICAgICB2YXIgX3JlZjE2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LCAyKSxcbiAgICAgICAgICAgIGNvbHVtbiA9IF9yZWYxNlswXSxcbiAgICAgICAgICAgIGZvcm1hdHRlciA9IF9yZWYxNlsxXTtcblxuICAgICAgICBhY2Nba2V5XVtjb2x1bW5dID0gX3RoaXMucHJvcHMuYWdncmVnYXRvcnNGYWN0b3J5KGZvcm1hdHRlcilbX3RoaXMucHJvcHMuYWdncmVnYXRvck5hbWVdKF90aGlzLnByb3BzLnZhbHMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICB0aGlzLnRyZWUgPSB7fTtcbiAgICB0aGlzLnJvd0tleXMgPSBbXTtcbiAgICB0aGlzLmNvbEtleXMgPSBbXTtcbiAgICB0aGlzLnJvd1RvdGFscyA9IHt9O1xuICAgIHRoaXMuY29sVG90YWxzID0ge307XG4gICAgdGhpcy5hbGxUb3RhbCA9IHRoaXMuYWdncmVnYXRvcih0aGlzLCBbXSwgW10pO1xuICAgIHRoaXMuc3VidG90YWxzID0gc3VidG90YWxzO1xuICAgIHRoaXMuc29ydGVkID0gZmFsc2U7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggaW5wdXQsIGFjY3VtdWxhdGluZyBkYXRhIGZvciBjZWxsc1xuICAgIFBpdm90RGF0YS5mb3JFYWNoUmVjb3JkKHRoaXMucHJvcHMuZGF0YSwgdGhpcy5wcm9wcy5kZXJpdmVkQXR0cmlidXRlcywgZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgaWYgKF90aGlzLmZpbHRlcihyZWNvcmQpKSB7XG4gICAgICAgIF90aGlzLnByb2Nlc3NSZWNvcmQocmVjb3JkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQaXZvdERhdGEsIFt7XG4gICAga2V5OiAnZmlsdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyKHJlY29yZCkge1xuICAgICAgZm9yICh2YXIgayBpbiB0aGlzLnByb3BzLnZhbHVlRmlsdGVyKSB7XG4gICAgICAgIGlmIChyZWNvcmRba10gaW4gdGhpcy5wcm9wcy52YWx1ZUZpbHRlcltrXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Rm9ybWF0dGVkQWdncmVnYXRvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvcm1hdHRlZEFnZ3JlZ2F0b3IocmVjb3JkLCB0b3RhbHNLZXlzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmZvcm1hdHRlZEFnZ3JlZ2F0b3JzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFnZ3JlZ2F0b3I7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcmVmMTcgPSBPYmplY3QuZW50cmllcyhyZWNvcmQpLmZpbmQoZnVuY3Rpb24gKF9yZWYxOSkge1xuICAgICAgICB2YXIgX3JlZjIwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE5LCAyKSxcbiAgICAgICAgICAgIG5hbWUgPSBfcmVmMjBbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IF9yZWYyMFsxXTtcblxuICAgICAgICByZXR1cm4gX3RoaXMyLmZvcm1hdHRlZEFnZ3JlZ2F0b3JzW25hbWVdICYmIF90aGlzMi5mb3JtYXR0ZWRBZ2dyZWdhdG9yc1tuYW1lXVt2YWx1ZV07XG4gICAgICB9KSB8fCBbXSxcbiAgICAgICAgICBfcmVmMTggPSBfc2xpY2VkVG9BcnJheShfcmVmMTcsIDIpLFxuICAgICAgICAgIGdyb3VwTmFtZSA9IF9yZWYxOFswXSxcbiAgICAgICAgICBncm91cFZhbHVlID0gX3JlZjE4WzFdO1xuXG4gICAgICBpZiAoIWdyb3VwTmFtZSB8fCAhZ3JvdXBWYWx1ZSB8fCB0b3RhbHNLZXlzICYmICF0b3RhbHNLZXlzLmluY2x1ZGVzKGdyb3VwVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFnZ3JlZ2F0b3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZWRBZ2dyZWdhdG9yc1tncm91cE5hbWVdW2dyb3VwVmFsdWVdIHx8IHRoaXMuYWdncmVnYXRvcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JFYWNoTWF0Y2hpbmdSZWNvcmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoTWF0Y2hpbmdSZWNvcmQoY3JpdGVyaWEsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgcmV0dXJuIFBpdm90RGF0YS5mb3JFYWNoUmVjb3JkKHRoaXMucHJvcHMuZGF0YSwgdGhpcy5wcm9wcy5kZXJpdmVkQXR0cmlidXRlcywgZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICBpZiAoIV90aGlzMy5maWx0ZXIocmVjb3JkKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrIGluIGNyaXRlcmlhKSB7XG4gICAgICAgICAgdmFyIHYgPSBjcml0ZXJpYVtrXTtcbiAgICAgICAgICBpZiAodiAhPT0gKGsgaW4gcmVjb3JkID8gcmVjb3JkW2tdIDogJ251bGwnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhyZWNvcmQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXJyU29ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFyclNvcnQoYXR0cnMsIHBhcnRpYWxPblRvcCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciByZXZlcnNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgdmFyIHNvcnRlcnNBcnIgPSBhdHRycy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGdldFNvcnQoX3RoaXM0LnByb3BzLnNvcnRlcnMsIGEpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGxpbWl0ID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNvcnRlciA9IHNvcnRlcnNBcnJbaV07XG4gICAgICAgICAgdmFyIGNvbXBhcmlzb24gPSByZXZlcnNlID8gc29ydGVyKGJbaV0sIGFbaV0pIDogc29ydGVyKGFbaV0sIGJbaV0pO1xuICAgICAgICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRpYWxPblRvcCA/IGEubGVuZ3RoIC0gYi5sZW5ndGggOiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzb3J0S2V5cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnRLZXlzKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5zb3J0ZWQpIHtcbiAgICAgICAgdGhpcy5zb3J0ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdiA9IGZ1bmN0aW9uIHYociwgYykge1xuICAgICAgICAgIHJldHVybiBfdGhpczUuZ2V0QWdncmVnYXRvcihyLCBjKS52YWx1ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKHRoaXMucHJvcHMucm93T3JkZXIpIHtcbiAgICAgICAgICBjYXNlICdrZXlfel90b19hJzpcbiAgICAgICAgICAgIHRoaXMucm93S2V5cy5zb3J0KHRoaXMuYXJyU29ydCh0aGlzLnByb3BzLnJvd3MsIHRoaXMuc3VidG90YWxzLnJvd1BhcnRpYWxPblRvcCwgdHJ1ZSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmFsdWVfYV90b196JzpcbiAgICAgICAgICAgIHRoaXMucm93S2V5cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuYXR1cmFsU29ydCh2KGEsIFtdKSwgdihiLCBbXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd2YWx1ZV96X3RvX2EnOlxuICAgICAgICAgICAgdGhpcy5yb3dLZXlzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC1uYXR1cmFsU29ydCh2KGEsIFtdKSwgdihiLCBbXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5yb3dLZXlzLnNvcnQodGhpcy5hcnJTb3J0KHRoaXMucHJvcHMucm93cywgdGhpcy5zdWJ0b3RhbHMucm93UGFydGlhbE9uVG9wKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BzLmNvbE9yZGVyKSB7XG4gICAgICAgICAgY2FzZSAna2V5X3pfdG9fYSc6XG4gICAgICAgICAgICB0aGlzLmNvbEtleXMuc29ydCh0aGlzLmFyclNvcnQodGhpcy5wcm9wcy5jb2xzLCB0aGlzLnN1YnRvdGFscy5jb2xQYXJ0aWFsT25Ub3AsIHRydWUpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ZhbHVlX2FfdG9feic6XG4gICAgICAgICAgICB0aGlzLmNvbEtleXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gbmF0dXJhbFNvcnQodihbXSwgYSksIHYoW10sIGIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmFsdWVfel90b19hJzpcbiAgICAgICAgICAgIHRoaXMuY29sS2V5cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtbmF0dXJhbFNvcnQodihbXSwgYSksIHYoW10sIGIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuY29sS2V5cy5zb3J0KHRoaXMuYXJyU29ydCh0aGlzLnByb3BzLmNvbHMsIHRoaXMuc3VidG90YWxzLmNvbFBhcnRpYWxPblRvcCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Q29sS2V5cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbEtleXMoKSB7XG4gICAgICB0aGlzLnNvcnRLZXlzKCk7XG4gICAgICByZXR1cm4gdGhpcy5jb2xLZXlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFJvd0tleXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSb3dLZXlzKCkge1xuICAgICAgdGhpcy5zb3J0S2V5cygpO1xuICAgICAgcmV0dXJuIHRoaXMucm93S2V5cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzUmVjb3JkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1JlY29yZChyZWNvcmQpIHtcbiAgICAgIC8vIHRoaXMgY29kZSBpcyBjYWxsZWQgaW4gYSB0aWdodCBsb29wXG4gICAgICB2YXIgY29sS2V5ID0gW107XG4gICAgICB2YXIgcm93S2V5ID0gW107XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5wcm9wcy5jb2xzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciB4ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBjb2xLZXkucHVzaCh4IGluIHJlY29yZCA/IHJlY29yZFt4XSA6ICdudWxsJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRoaXMucHJvcHMucm93c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfeDE4ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgcm93S2V5LnB1c2goX3gxOCBpbiByZWNvcmQgPyByZWNvcmRbX3gxOF0gOiAnbnVsbCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWxsVG90YWwucHVzaChyZWNvcmQpO1xuXG4gICAgICB2YXIgcm93U3RhcnQgPSB0aGlzLnN1YnRvdGFscy5yb3dFbmFibGVkID8gMSA6IE1hdGgubWF4KDEsIHJvd0tleS5sZW5ndGgpO1xuICAgICAgdmFyIGNvbFN0YXJ0ID0gdGhpcy5zdWJ0b3RhbHMuY29sRW5hYmxlZCA/IDEgOiBNYXRoLm1heCgxLCBjb2xLZXkubGVuZ3RoKTtcblxuICAgICAgdmFyIGlzUm93U3VidG90YWwgPSB2b2lkIDAsXG4gICAgICAgICAgaXNDb2xTdWJ0b3RhbCA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIHJpID0gcm93U3RhcnQ7IHJpIDw9IHJvd0tleS5sZW5ndGg7IHJpKyspIHtcbiAgICAgICAgaXNSb3dTdWJ0b3RhbCA9IHJpIDwgcm93S2V5Lmxlbmd0aDtcbiAgICAgICAgdmFyIGZSb3dLZXkgPSByb3dLZXkuc2xpY2UoMCwgcmkpO1xuICAgICAgICB2YXIgZmxhdFJvd0tleSA9IGZsYXRLZXkoZlJvd0tleSk7XG4gICAgICAgIGlmICghdGhpcy5yb3dUb3RhbHNbZmxhdFJvd0tleV0pIHtcbiAgICAgICAgICB0aGlzLnJvd0tleXMucHVzaChmUm93S2V5KTtcbiAgICAgICAgICB0aGlzLnJvd1RvdGFsc1tmbGF0Um93S2V5XSA9IHRoaXMuZ2V0Rm9ybWF0dGVkQWdncmVnYXRvcihyZWNvcmQsIHJvd0tleSkodGhpcywgZlJvd0tleSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93VG90YWxzW2ZsYXRSb3dLZXldLnB1c2gocmVjb3JkKTtcbiAgICAgICAgdGhpcy5yb3dUb3RhbHNbZmxhdFJvd0tleV0uaXNTdWJ0b3RhbCA9IGlzUm93U3VidG90YWw7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGNpID0gY29sU3RhcnQ7IGNpIDw9IGNvbEtleS5sZW5ndGg7IGNpKyspIHtcbiAgICAgICAgaXNDb2xTdWJ0b3RhbCA9IGNpIDwgY29sS2V5Lmxlbmd0aDtcbiAgICAgICAgdmFyIGZDb2xLZXkgPSBjb2xLZXkuc2xpY2UoMCwgY2kpO1xuICAgICAgICB2YXIgZmxhdENvbEtleSA9IGZsYXRLZXkoZkNvbEtleSk7XG4gICAgICAgIGlmICghdGhpcy5jb2xUb3RhbHNbZmxhdENvbEtleV0pIHtcbiAgICAgICAgICB0aGlzLmNvbEtleXMucHVzaChmQ29sS2V5KTtcbiAgICAgICAgICB0aGlzLmNvbFRvdGFsc1tmbGF0Q29sS2V5XSA9IHRoaXMuZ2V0Rm9ybWF0dGVkQWdncmVnYXRvcihyZWNvcmQsIGNvbEtleSkodGhpcywgW10sIGZDb2xLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sVG90YWxzW2ZsYXRDb2xLZXldLnB1c2gocmVjb3JkKTtcbiAgICAgICAgdGhpcy5jb2xUb3RhbHNbZmxhdENvbEtleV0uaXNTdWJ0b3RhbCA9IGlzQ29sU3VidG90YWw7XG4gICAgICB9XG5cbiAgICAgIC8vIEFuZCBub3cgZmlsbCBpbiBmb3IgYWxsIHRoZSBzdWItY2VsbHMuXG4gICAgICBmb3IgKHZhciBfcmkgPSByb3dTdGFydDsgX3JpIDw9IHJvd0tleS5sZW5ndGg7IF9yaSsrKSB7XG4gICAgICAgIGlzUm93U3VidG90YWwgPSBfcmkgPCByb3dLZXkubGVuZ3RoO1xuICAgICAgICB2YXIgX2ZSb3dLZXkgPSByb3dLZXkuc2xpY2UoMCwgX3JpKTtcbiAgICAgICAgdmFyIF9mbGF0Um93S2V5ID0gZmxhdEtleShfZlJvd0tleSk7XG4gICAgICAgIGlmICghdGhpcy50cmVlW19mbGF0Um93S2V5XSkge1xuICAgICAgICAgIHRoaXMudHJlZVtfZmxhdFJvd0tleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfY2kgPSBjb2xTdGFydDsgX2NpIDw9IGNvbEtleS5sZW5ndGg7IF9jaSsrKSB7XG4gICAgICAgICAgaXNDb2xTdWJ0b3RhbCA9IF9jaSA8IGNvbEtleS5sZW5ndGg7XG4gICAgICAgICAgdmFyIF9mQ29sS2V5ID0gY29sS2V5LnNsaWNlKDAsIF9jaSk7XG4gICAgICAgICAgdmFyIF9mbGF0Q29sS2V5ID0gZmxhdEtleShfZkNvbEtleSk7XG4gICAgICAgICAgaWYgKCF0aGlzLnRyZWVbX2ZsYXRSb3dLZXldW19mbGF0Q29sS2V5XSkge1xuICAgICAgICAgICAgdGhpcy50cmVlW19mbGF0Um93S2V5XVtfZmxhdENvbEtleV0gPSB0aGlzLmdldEZvcm1hdHRlZEFnZ3JlZ2F0b3IocmVjb3JkKSh0aGlzLCBfZlJvd0tleSwgX2ZDb2xLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRyZWVbX2ZsYXRSb3dLZXldW19mbGF0Q29sS2V5XS5wdXNoKHJlY29yZCk7XG5cbiAgICAgICAgICB0aGlzLnRyZWVbX2ZsYXRSb3dLZXldW19mbGF0Q29sS2V5XS5pc1Jvd1N1YnRvdGFsID0gaXNSb3dTdWJ0b3RhbDtcbiAgICAgICAgICB0aGlzLnRyZWVbX2ZsYXRSb3dLZXldW19mbGF0Q29sS2V5XS5pc0NvbFN1YnRvdGFsID0gaXNDb2xTdWJ0b3RhbDtcbiAgICAgICAgICB0aGlzLnRyZWVbX2ZsYXRSb3dLZXldW19mbGF0Q29sS2V5XS5pc1N1YnRvdGFsID0gaXNSb3dTdWJ0b3RhbCB8fCBpc0NvbFN1YnRvdGFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0QWdncmVnYXRvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFnZ3JlZ2F0b3Iocm93S2V5LCBjb2xLZXkpIHtcbiAgICAgIHZhciBhZ2cgPSB2b2lkIDA7XG4gICAgICB2YXIgZmxhdFJvd0tleSA9IGZsYXRLZXkocm93S2V5KTtcbiAgICAgIHZhciBmbGF0Q29sS2V5ID0gZmxhdEtleShjb2xLZXkpO1xuICAgICAgaWYgKHJvd0tleS5sZW5ndGggPT09IDAgJiYgY29sS2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhZ2cgPSB0aGlzLmFsbFRvdGFsO1xuICAgICAgfSBlbHNlIGlmIChyb3dLZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFnZyA9IHRoaXMuY29sVG90YWxzW2ZsYXRDb2xLZXldO1xuICAgICAgfSBlbHNlIGlmIChjb2xLZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFnZyA9IHRoaXMucm93VG90YWxzW2ZsYXRSb3dLZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWdnID0gdGhpcy50cmVlW2ZsYXRSb3dLZXldW2ZsYXRDb2xLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFnZyB8fCB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQaXZvdERhdGE7XG59KCk7XG5cbi8vIGNhbiBoYW5kbGUgYXJyYXlzIG9yIGpRdWVyeSBzZWxlY3Rpb25zIG9mIHRhYmxlc1xuXG5cblBpdm90RGF0YS5mb3JFYWNoUmVjb3JkID0gZnVuY3Rpb24gKGlucHV0LCBkZXJpdmVkQXR0cmlidXRlcywgZikge1xuICB2YXIgYWRkUmVjb3JkID0gdm9pZCAwLFxuICAgICAgcmVjb3JkID0gdm9pZCAwO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVyaXZlZEF0dHJpYnV0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgIGFkZFJlY29yZCA9IGY7XG4gIH0gZWxzZSB7XG4gICAgYWRkUmVjb3JkID0gZnVuY3Rpb24gYWRkUmVjb3JkKHJlY29yZCkge1xuICAgICAgZm9yICh2YXIgayBpbiBkZXJpdmVkQXR0cmlidXRlcykge1xuICAgICAgICB2YXIgZGVyaXZlZCA9IGRlcml2ZWRBdHRyaWJ1dGVzW2tdKHJlY29yZCk7XG4gICAgICAgIGlmIChkZXJpdmVkICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVjb3JkW2tdID0gZGVyaXZlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGYocmVjb3JkKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uLCBoYXZlIGl0IGNhbGwgdXMgYmFja1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGlucHV0KGFkZFJlY29yZCk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dFswXSkpIHtcbiAgICAgIC8vIGFycmF5IG9mIGFycmF5c1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gT2JqZWN0LmtleXMoaW5wdXQgfHwge30pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgaSA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgICAgdmFyIGNvbXBhY3RSZWNvcmQgPSBpbnB1dFtpXTtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICByZWNvcmQgPSB7fTtcbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IE9iamVjdC5rZXlzKGlucHV0WzBdIHx8IHt9KVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGogPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBrID0gaW5wdXRbMF1bal07XG4gICAgICAgICAgICAgICAgICByZWNvcmRba10gPSBjb21wYWN0UmVjb3JkW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBlcnI7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgJiYgX2l0ZXJhdG9yNC5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkUmVjb3JkKHJlY29yZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0oKTtcbiAgICB9XG5cbiAgICAvLyBhcnJheSBvZiBvYmplY3RzXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXN1bHQxID0gW107XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IEFycmF5LmZyb20oaW5wdXQpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7XG4gICAgICAgICAgcmVjb3JkID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgICAgcmVzdWx0MS5wdXNoKGFkZFJlY29yZChyZWNvcmQpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yNSA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNS5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0MTtcbiAgICB9KCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGlucHV0IGZvcm1hdCcpO1xufTtcblxuUGl2b3REYXRhLmRlZmF1bHRQcm9wcyA9IHtcbiAgYWdncmVnYXRvcnM6IGFnZ3JlZ2F0b3JzLFxuICBjb2xzOiBbXSxcbiAgcm93czogW10sXG4gIHZhbHM6IFtdLFxuICBhZ2dyZWdhdG9yTmFtZTogJ0NvdW50JyxcbiAgc29ydGVyczoge30sXG4gIHZhbHVlRmlsdGVyOiB7fSxcbiAgcm93T3JkZXI6ICdrZXlfYV90b196JyxcbiAgY29sT3JkZXI6ICdrZXlfYV90b196JyxcbiAgZGVyaXZlZEF0dHJpYnV0ZXM6IHt9XG59O1xuXG5QaXZvdERhdGEucHJvcFR5cGVzID0ge1xuICBkYXRhOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5hcnJheSwgX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsIF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuY10pLmlzUmVxdWlyZWQsXG4gIGFnZ3JlZ2F0b3JOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgY29sczogX3Byb3BUeXBlczIuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nKSxcbiAgcm93czogX3Byb3BUeXBlczIuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nKSxcbiAgdmFsczogX3Byb3BUeXBlczIuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nKSxcbiAgdmFsdWVGaWx0ZXI6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0T2YoX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3RPZihfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wpKSxcbiAgc29ydGVyczogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYywgX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3RPZihfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMpXSksXG4gIGRlcml2ZWRBdHRyaWJ1dGVzOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdE9mKF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyksXG4gIHJvd09yZGVyOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mKFsna2V5X2FfdG9feicsICdrZXlfel90b19hJywgJ3ZhbHVlX2FfdG9feicsICd2YWx1ZV96X3RvX2EnXSksXG4gIGNvbE9yZGVyOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mKFsna2V5X2FfdG9feicsICdrZXlfel90b19hJywgJ3ZhbHVlX2FfdG9feicsICd2YWx1ZV96X3RvX2EnXSlcbn07XG5cbmV4cG9ydHMuYWdncmVnYXRvclRlbXBsYXRlcyA9IGFnZ3JlZ2F0b3JUZW1wbGF0ZXM7XG5leHBvcnRzLmFnZ3JlZ2F0b3JzID0gYWdncmVnYXRvcnM7XG5leHBvcnRzLmRlcml2ZXJzID0gZGVyaXZlcnM7XG5leHBvcnRzLmxvY2FsZXMgPSBsb2NhbGVzO1xuZXhwb3J0cy5uYXR1cmFsU29ydCA9IG5hdHVyYWxTb3J0O1xuZXhwb3J0cy5udW1iZXJGb3JtYXQgPSBudW1iZXJGb3JtYXQ7XG5leHBvcnRzLmdldFNvcnQgPSBnZXRTb3J0O1xuZXhwb3J0cy5zb3J0QXMgPSBzb3J0QXM7XG5leHBvcnRzLmZsYXRLZXkgPSBmbGF0S2V5O1xuZXhwb3J0cy5QaXZvdERhdGEgPSBQaXZvdERhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VdGlsaXRpZXMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/Utilities.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/pivottable.css":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/pivottable.css ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../../../css-loader??ref--7-1!./pivottable.css */ \"./node_modules/css-loader/index.js?!./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/pivottable.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3JlYWN0LXBpdm90dGFibGUvcGl2b3R0YWJsZS5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3JlYWN0LXBpdm90dGFibGUvcGl2b3R0YWJsZS5jc3M/ZDQxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS03LTEhLi9waXZvdHRhYmxlLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/pivottable.css\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js?!./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/pivottable.css":
/*!**********************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--7-1!./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/pivottable.css ***!
  \**********************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../../../css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \".pvtUi {\\n  color: #2a3f5f;\\n  font-family: 'Inter', Helvetica, Arial, sans-serif;\\n  border-collapse: collapse;\\n}\\n.pvtUi select {\\n  user-select: none;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -khtml-user-select: none;\\n  -ms-user-select: none;\\n}\\n\\n.pvtUi td.pvtOutput {\\n  vertical-align: top;\\n}\\n\\ntable.pvtTable {\\n  position: relative;\\n  font-size: 12px;\\n  text-align: left;\\n  margin-top: 3px;\\n  margin-left: 3px;\\n  border-collapse: separate;\\n  font-family: 'Inter', Helvetica, Arial, sans-serif;\\n  line-height: 1.4;\\n}\\n\\ntable thead {\\n  position: sticky;\\n  top: 0;\\n}\\n\\ntable.pvtTable thead tr th,\\ntable.pvtTable tbody tr th {\\n  background-color: #fff;\\n  border-top: 1px solid #e0e0e0;\\n  border-left: 1px solid #e0e0e0;\\n  font-size: 12px;\\n  padding: 5px;\\n  font-weight: normal;\\n}\\n\\ntable.pvtTable tbody tr.pvtRowTotals{\\n  position: sticky;\\n  bottom: 0;\\n}\\n\\ntable.pvtTable thead tr:last-child th,\\ntable.pvtTable thead tr:first-child th.pvtTotalLabel,\\ntable.pvtTable thead tr:nth-last-child(2) th.pvtColLabel,\\ntable.pvtTable thead th.pvtSubtotalLabel,\\ntable.pvtTable tbody tr:last-child th,\\ntable.pvtTable tbody tr:last-child td {\\n  border-bottom: 1px solid #e0e0e0;\\n}\\n\\ntable.pvtTable thead tr:last-child:not(:only-child) th.pvtAxisLabel ~ th.pvtColLabel,\\ntable.pvtTable tbody tr:first-child th,\\ntable.pvtTable tbody tr:first-child td{\\n  border-top: none;\\n}\\n\\ntable.pvtTable tbody tr td:last-child,\\ntable.pvtTable thead tr th:last-child:not(.pvtSubtotalLabel) {\\n  border-right: 1px solid #e0e0e0;\\n}\\n\\ntable.pvtTable thead tr:last-child:not(:only-child) th.pvtAxisLabel + .pvtTotalLabel {\\n  border-right: none;\\n}\\n\\ntable.pvtTable tr th.active {\\n  background-color: #d9dbe4;\\n}\\n\\ntable.pvtTable .pvtTotalLabel {\\n  text-align: right;\\n  font-weight: bold;\\n}\\n\\ntable.pvtTable .pvtSubtotalLabel {\\n  font-weight: bold;\\n}\\n\\ntable.pvtTable tbody tr td {\\n  color: #2a3f5f;\\n  padding: 5px;\\n  background-color: #fff;\\n  border-top: 1px solid #e0e0e0;\\n  border-left: 1px solid #e0e0e0;\\n  vertical-align: top;\\n  text-align: right;\\n}\\n\\ntable.pvtTable tbody tr th.pvtRowLabel {\\n  vertical-align: baseline;\\n}\\n\\n.pvtTotal,\\n.pvtGrandTotal {\\n  font-weight: bold;\\n}\\n\\ntable.pvtTable tbody tr td.pvtRowTotal {\\n  vertical-align: middle;\\n}\\n\\n.pvtRowOrder,\\n.pvtColOrder {\\n  cursor: pointer;\\n  width: 15px;\\n  margin-left: 5px;\\n  display: inline-block;\\n  user-select: none;\\n  text-decoration: none !important;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -khtml-user-select: none;\\n  -ms-user-select: none;\\n}\\n\\n.pvtAxisContainer,\\n.pvtVals {\\n  border: 1px solid #a2b1c6;\\n  background: #f2f5fa;\\n  padding: 5px;\\n  min-width: 20px;\\n  min-height: 20px;\\n}\\n\\n.pvtRenderers {\\n  padding-left: 5px;\\n  user-select: none;\\n}\\n\\n.pvtDropdown {\\n  display: inline-block;\\n  position: relative;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -khtml-user-select: none;\\n  -ms-user-select: none;\\n  margin: 3px;\\n}\\n\\n.pvtDropdownIcon {\\n  float: right;\\n  color: #a2b1c6;\\n}\\n.pvtDropdownCurrent {\\n  text-align: left;\\n  border: 1px solid #a2b1c6;\\n  border-radius: 4px;\\n  display: inline-block;\\n  position: relative;\\n  width: 210px;\\n  box-sizing: border-box;\\n  background: white;\\n}\\n\\n.pvtDropdownCurrentOpen {\\n  border-radius: 4px 4px 0 0;\\n}\\n\\n.pvtDropdownMenu {\\n  background: white;\\n  position: absolute;\\n  width: 100%;\\n  margin-top: -1px;\\n  border-radius: 0 0 4px 4px;\\n  border: 1px solid #a2b1c6;\\n  border-top: 1px solid #dfe8f3;\\n  box-sizing: border-box;\\n}\\n\\n.pvtDropdownValue {\\n  padding: 2px 5px;\\n  font-size: 12px;\\n  text-align: left;\\n}\\n.pvtDropdownActiveValue {\\n  background: #ebf0f8;\\n}\\n\\n.pvtVals {\\n  text-align: center;\\n  white-space: nowrap;\\n  vertical-align: top;\\n  padding-bottom: 12px;\\n}\\n\\n.pvtRows {\\n  height: 35px;\\n}\\n\\n.pvtTriangle {\\n  cursor: pointer;\\n  color: #506784;\\n}\\n\\n.pvtHorizList li {\\n  display: inline-block;\\n}\\n.pvtVertList {\\n  vertical-align: top;\\n}\\n\\n.pvtFilteredAttribute {\\n  font-style: italic;\\n}\\n\\n.sortable-chosen .pvtFilterBox {\\n  display: none !important;\\n}\\n\\n.pvtCloseX {\\n  position: absolute;\\n  right: 5px;\\n  top: 5px;\\n  font-size: 18px;\\n  cursor: pointer;\\n  text-decoration: none !important;\\n}\\n\\n.pvtDragHandle {\\n  position: absolute;\\n  left: 5px;\\n  top: 5px;\\n  font-size: 18px;\\n  cursor: move;\\n  color: #a2b1c6;\\n}\\n\\n.pvtButton {\\n  color: #506784;\\n  border-radius: 5px;\\n  padding: 3px 6px;\\n  background: #f2f5fa;\\n  border: 1px solid;\\n  border-color: #c8d4e3;\\n  font-size: 14px;\\n  margin: 3px;\\n  transition: 0.34s all cubic-bezier(0.19, 1, 0.22, 1);\\n  text-decoration: none !important;\\n}\\n\\n.pvtButton:hover {\\n  background: #e2e8f0;\\n  border-color: #a2b1c6;\\n}\\n\\n.pvtButton:active {\\n  background: #d1dae6;\\n}\\n\\n.pvtFilterBox input {\\n  border: 1px solid #c8d4e3;\\n  border-radius: 5px;\\n  color: #506784;\\n  padding: 0 3px;\\n  font-size: 14px;\\n}\\n\\n.pvtFilterBox input:focus {\\n  border-color: #119dff;\\n  outline: none;\\n}\\n\\n.pvtFilterBox {\\n  z-index: 100;\\n  width: 300px;\\n  border: 1px solid #506784;\\n  background-color: #fff;\\n  position: absolute;\\n  text-align: center;\\n  user-select: none;\\n  min-height: 100px;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -khtml-user-select: none;\\n  -ms-user-select: none;\\n}\\n\\n.pvtFilterBox h4 {\\n  margin: 15px;\\n}\\n.pvtFilterBox p {\\n  margin: 10px auto;\\n}\\n.pvtFilterBox button {\\n  color: #2a3f5f;\\n}\\n.pvtFilterBox input[type='text'] {\\n  width: 230px;\\n  color: #2a3f5f;\\n  margin-bottom: 5px;\\n}\\n\\n.pvtCheckContainer {\\n  text-align: left;\\n  font-size: 14px;\\n  white-space: nowrap;\\n  overflow-y: scroll;\\n  width: 100%;\\n  max-height: 30vh;\\n  border-top: 1px solid #dfe8f3;\\n}\\n\\n.pvtCheckContainer p {\\n  margin: 0;\\n  margin-bottom: 1px;\\n  padding: 3px;\\n  cursor: default;\\n}\\n\\n.pvtCheckContainer p.selected {\\n  background: #ebf0f8;\\n}\\n\\n.pvtOnly {\\n  display: none;\\n  width: 35px;\\n  float: left;\\n  font-size: 12px;\\n  padding-left: 5px;\\n  cursor: pointer;\\n}\\n\\n.pvtOnlySpacer {\\n  display: block;\\n  width: 35px;\\n  float: left;\\n}\\n\\n.pvtCheckContainer p:hover .pvtOnly {\\n  display: block;\\n}\\n.pvtCheckContainer p:hover .pvtOnlySpacer {\\n  display: none;\\n}\\n\\n.pvtRendererArea {\\n  padding: 5px;\\n}\\n\\n.toggle-wrapper {\\n  white-space: nowrap;\\n}\\n\\n.toggle-wrapper > .toggle-val {\\n  white-space: normal;\\n}\\n\\n.toggle {\\n  padding-right: 4px;\\n  cursor: pointer;\\n}\\n\\n.hoverable:hover {\\n  background-color: #eceef2;\\n  cursor: pointer;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"/app/superset-frontend/node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/pivottable.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,eAAe;EACf,mDAAmD;EACnD,0BAA0B;CAC3B;AACD;EACE,kBAAkB;EAClB,0BAA0B;EAC1B,uBAAuB;EACvB,yBAAyB;EACzB,sBAAsB;CACvB;;AAED;EACE,oBAAoB;CACrB;;AAED;EACE,mBAAmB;EACnB,gBAAgB;EAChB,iBAAiB;EACjB,gBAAgB;EAChB,iBAAiB;EACjB,0BAA0B;EAC1B,mDAAmD;EACnD,iBAAiB;CAClB;;AAED;EACE,iBAAiB;EACjB,OAAO;CACR;;AAED;;EAEE,uBAAuB;EACvB,8BAA8B;EAC9B,+BAA+B;EAC/B,gBAAgB;EAChB,aAAa;EACb,oBAAoB;CACrB;;AAED;EACE,iBAAiB;EACjB,UAAU;CACX;;AAED;;;;;;EAME,iCAAiC;CAClC;;AAED;;;EAGE,iBAAiB;CAClB;;AAED;;EAEE,gCAAgC;CACjC;;AAED;EACE,mBAAmB;CACpB;;AAED;EACE,0BAA0B;CAC3B;;AAED;EACE,kBAAkB;EAClB,kBAAkB;CACnB;;AAED;EACE,kBAAkB;CACnB;;AAED;EACE,eAAe;EACf,aAAa;EACb,uBAAuB;EACvB,8BAA8B;EAC9B,+BAA+B;EAC/B,oBAAoB;EACpB,kBAAkB;CACnB;;AAED;EACE,yBAAyB;CAC1B;;AAED;;EAEE,kBAAkB;CACnB;;AAED;EACE,uBAAuB;CACxB;;AAED;;EAEE,gBAAgB;EAChB,YAAY;EACZ,iBAAiB;EACjB,sBAAsB;EACtB,kBAAkB;EAClB,iCAAiC;EACjC,0BAA0B;EAC1B,uBAAuB;EACvB,yBAAyB;EACzB,sBAAsB;CACvB;;AAED;;EAEE,0BAA0B;EAC1B,oBAAoB;EACpB,aAAa;EACb,gBAAgB;EAChB,iBAAiB;CAClB;;AAED;EACE,kBAAkB;EAClB,kBAAkB;CACnB;;AAED;EACE,sBAAsB;EACtB,mBAAmB;EACnB,0BAA0B;EAC1B,uBAAuB;EACvB,yBAAyB;EACzB,sBAAsB;EACtB,YAAY;CACb;;AAED;EACE,aAAa;EACb,eAAe;CAChB;AACD;EACE,iBAAiB;EACjB,0BAA0B;EAC1B,mBAAmB;EACnB,sBAAsB;EACtB,mBAAmB;EACnB,aAAa;EACb,uBAAuB;EACvB,kBAAkB;CACnB;;AAED;EACE,2BAA2B;CAC5B;;AAED;EACE,kBAAkB;EAClB,mBAAmB;EACnB,YAAY;EACZ,iBAAiB;EACjB,2BAA2B;EAC3B,0BAA0B;EAC1B,8BAA8B;EAC9B,uBAAuB;CACxB;;AAED;EACE,iBAAiB;EACjB,gBAAgB;EAChB,iBAAiB;CAClB;AACD;EACE,oBAAoB;CACrB;;AAED;EACE,mBAAmB;EACnB,oBAAoB;EACpB,oBAAoB;EACpB,qBAAqB;CACtB;;AAED;EACE,aAAa;CACd;;AAED;EACE,gBAAgB;EAChB,eAAe;CAChB;;AAED;EACE,sBAAsB;CACvB;AACD;EACE,oBAAoB;CACrB;;AAED;EACE,mBAAmB;CACpB;;AAED;EACE,yBAAyB;CAC1B;;AAED;EACE,mBAAmB;EACnB,WAAW;EACX,SAAS;EACT,gBAAgB;EAChB,gBAAgB;EAChB,iCAAiC;CAClC;;AAED;EACE,mBAAmB;EACnB,UAAU;EACV,SAAS;EACT,gBAAgB;EAChB,aAAa;EACb,eAAe;CAChB;;AAED;EACE,eAAe;EACf,mBAAmB;EACnB,iBAAiB;EACjB,oBAAoB;EACpB,kBAAkB;EAClB,sBAAsB;EACtB,gBAAgB;EAChB,YAAY;EACZ,qDAAqD;EACrD,iCAAiC;CAClC;;AAED;EACE,oBAAoB;EACpB,sBAAsB;CACvB;;AAED;EACE,oBAAoB;CACrB;;AAED;EACE,0BAA0B;EAC1B,mBAAmB;EACnB,eAAe;EACf,eAAe;EACf,gBAAgB;CACjB;;AAED;EACE,sBAAsB;EACtB,cAAc;CACf;;AAED;EACE,aAAa;EACb,aAAa;EACb,0BAA0B;EAC1B,uBAAuB;EACvB,mBAAmB;EACnB,mBAAmB;EACnB,kBAAkB;EAClB,kBAAkB;EAClB,0BAA0B;EAC1B,uBAAuB;EACvB,yBAAyB;EACzB,sBAAsB;CACvB;;AAED;EACE,aAAa;CACd;AACD;EACE,kBAAkB;CACnB;AACD;EACE,eAAe;CAChB;AACD;EACE,aAAa;EACb,eAAe;EACf,mBAAmB;CACpB;;AAED;EACE,iBAAiB;EACjB,gBAAgB;EAChB,oBAAoB;EACpB,mBAAmB;EACnB,YAAY;EACZ,iBAAiB;EACjB,8BAA8B;CAC/B;;AAED;EACE,UAAU;EACV,mBAAmB;EACnB,aAAa;EACb,gBAAgB;CACjB;;AAED;EACE,oBAAoB;CACrB;;AAED;EACE,cAAc;EACd,YAAY;EACZ,YAAY;EACZ,gBAAgB;EAChB,kBAAkB;EAClB,gBAAgB;CACjB;;AAED;EACE,eAAe;EACf,YAAY;EACZ,YAAY;CACb;;AAED;EACE,eAAe;CAChB;AACD;EACE,cAAc;CACf;;AAED;EACE,aAAa;CACd;;AAED;EACE,oBAAoB;CACrB;;AAED;EACE,oBAAoB;CACrB;;AAED;EACE,mBAAmB;EACnB,gBAAgB;CACjB;;AAED;EACE,0BAA0B;EAC1B,gBAAgB;CACjB\",\"file\":\"pivottable.css\",\"sourcesContent\":[\".pvtUi {\\n  color: #2a3f5f;\\n  font-family: 'Inter', Helvetica, Arial, sans-serif;\\n  border-collapse: collapse;\\n}\\n.pvtUi select {\\n  user-select: none;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -khtml-user-select: none;\\n  -ms-user-select: none;\\n}\\n\\n.pvtUi td.pvtOutput {\\n  vertical-align: top;\\n}\\n\\ntable.pvtTable {\\n  position: relative;\\n  font-size: 12px;\\n  text-align: left;\\n  margin-top: 3px;\\n  margin-left: 3px;\\n  border-collapse: separate;\\n  font-family: 'Inter', Helvetica, Arial, sans-serif;\\n  line-height: 1.4;\\n}\\n\\ntable thead {\\n  position: sticky;\\n  top: 0;\\n}\\n\\ntable.pvtTable thead tr th,\\ntable.pvtTable tbody tr th {\\n  background-color: #fff;\\n  border-top: 1px solid #e0e0e0;\\n  border-left: 1px solid #e0e0e0;\\n  font-size: 12px;\\n  padding: 5px;\\n  font-weight: normal;\\n}\\n\\ntable.pvtTable tbody tr.pvtRowTotals{\\n  position: sticky;\\n  bottom: 0;\\n}\\n\\ntable.pvtTable thead tr:last-child th,\\ntable.pvtTable thead tr:first-child th.pvtTotalLabel,\\ntable.pvtTable thead tr:nth-last-child(2) th.pvtColLabel,\\ntable.pvtTable thead th.pvtSubtotalLabel,\\ntable.pvtTable tbody tr:last-child th,\\ntable.pvtTable tbody tr:last-child td {\\n  border-bottom: 1px solid #e0e0e0;\\n}\\n\\ntable.pvtTable thead tr:last-child:not(:only-child) th.pvtAxisLabel ~ th.pvtColLabel,\\ntable.pvtTable tbody tr:first-child th,\\ntable.pvtTable tbody tr:first-child td{\\n  border-top: none;\\n}\\n\\ntable.pvtTable tbody tr td:last-child,\\ntable.pvtTable thead tr th:last-child:not(.pvtSubtotalLabel) {\\n  border-right: 1px solid #e0e0e0;\\n}\\n\\ntable.pvtTable thead tr:last-child:not(:only-child) th.pvtAxisLabel + .pvtTotalLabel {\\n  border-right: none;\\n}\\n\\ntable.pvtTable tr th.active {\\n  background-color: #d9dbe4;\\n}\\n\\ntable.pvtTable .pvtTotalLabel {\\n  text-align: right;\\n  font-weight: bold;\\n}\\n\\ntable.pvtTable .pvtSubtotalLabel {\\n  font-weight: bold;\\n}\\n\\ntable.pvtTable tbody tr td {\\n  color: #2a3f5f;\\n  padding: 5px;\\n  background-color: #fff;\\n  border-top: 1px solid #e0e0e0;\\n  border-left: 1px solid #e0e0e0;\\n  vertical-align: top;\\n  text-align: right;\\n}\\n\\ntable.pvtTable tbody tr th.pvtRowLabel {\\n  vertical-align: baseline;\\n}\\n\\n.pvtTotal,\\n.pvtGrandTotal {\\n  font-weight: bold;\\n}\\n\\ntable.pvtTable tbody tr td.pvtRowTotal {\\n  vertical-align: middle;\\n}\\n\\n.pvtRowOrder,\\n.pvtColOrder {\\n  cursor: pointer;\\n  width: 15px;\\n  margin-left: 5px;\\n  display: inline-block;\\n  user-select: none;\\n  text-decoration: none !important;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -khtml-user-select: none;\\n  -ms-user-select: none;\\n}\\n\\n.pvtAxisContainer,\\n.pvtVals {\\n  border: 1px solid #a2b1c6;\\n  background: #f2f5fa;\\n  padding: 5px;\\n  min-width: 20px;\\n  min-height: 20px;\\n}\\n\\n.pvtRenderers {\\n  padding-left: 5px;\\n  user-select: none;\\n}\\n\\n.pvtDropdown {\\n  display: inline-block;\\n  position: relative;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -khtml-user-select: none;\\n  -ms-user-select: none;\\n  margin: 3px;\\n}\\n\\n.pvtDropdownIcon {\\n  float: right;\\n  color: #a2b1c6;\\n}\\n.pvtDropdownCurrent {\\n  text-align: left;\\n  border: 1px solid #a2b1c6;\\n  border-radius: 4px;\\n  display: inline-block;\\n  position: relative;\\n  width: 210px;\\n  box-sizing: border-box;\\n  background: white;\\n}\\n\\n.pvtDropdownCurrentOpen {\\n  border-radius: 4px 4px 0 0;\\n}\\n\\n.pvtDropdownMenu {\\n  background: white;\\n  position: absolute;\\n  width: 100%;\\n  margin-top: -1px;\\n  border-radius: 0 0 4px 4px;\\n  border: 1px solid #a2b1c6;\\n  border-top: 1px solid #dfe8f3;\\n  box-sizing: border-box;\\n}\\n\\n.pvtDropdownValue {\\n  padding: 2px 5px;\\n  font-size: 12px;\\n  text-align: left;\\n}\\n.pvtDropdownActiveValue {\\n  background: #ebf0f8;\\n}\\n\\n.pvtVals {\\n  text-align: center;\\n  white-space: nowrap;\\n  vertical-align: top;\\n  padding-bottom: 12px;\\n}\\n\\n.pvtRows {\\n  height: 35px;\\n}\\n\\n.pvtTriangle {\\n  cursor: pointer;\\n  color: #506784;\\n}\\n\\n.pvtHorizList li {\\n  display: inline-block;\\n}\\n.pvtVertList {\\n  vertical-align: top;\\n}\\n\\n.pvtFilteredAttribute {\\n  font-style: italic;\\n}\\n\\n.sortable-chosen .pvtFilterBox {\\n  display: none !important;\\n}\\n\\n.pvtCloseX {\\n  position: absolute;\\n  right: 5px;\\n  top: 5px;\\n  font-size: 18px;\\n  cursor: pointer;\\n  text-decoration: none !important;\\n}\\n\\n.pvtDragHandle {\\n  position: absolute;\\n  left: 5px;\\n  top: 5px;\\n  font-size: 18px;\\n  cursor: move;\\n  color: #a2b1c6;\\n}\\n\\n.pvtButton {\\n  color: #506784;\\n  border-radius: 5px;\\n  padding: 3px 6px;\\n  background: #f2f5fa;\\n  border: 1px solid;\\n  border-color: #c8d4e3;\\n  font-size: 14px;\\n  margin: 3px;\\n  transition: 0.34s all cubic-bezier(0.19, 1, 0.22, 1);\\n  text-decoration: none !important;\\n}\\n\\n.pvtButton:hover {\\n  background: #e2e8f0;\\n  border-color: #a2b1c6;\\n}\\n\\n.pvtButton:active {\\n  background: #d1dae6;\\n}\\n\\n.pvtFilterBox input {\\n  border: 1px solid #c8d4e3;\\n  border-radius: 5px;\\n  color: #506784;\\n  padding: 0 3px;\\n  font-size: 14px;\\n}\\n\\n.pvtFilterBox input:focus {\\n  border-color: #119dff;\\n  outline: none;\\n}\\n\\n.pvtFilterBox {\\n  z-index: 100;\\n  width: 300px;\\n  border: 1px solid #506784;\\n  background-color: #fff;\\n  position: absolute;\\n  text-align: center;\\n  user-select: none;\\n  min-height: 100px;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -khtml-user-select: none;\\n  -ms-user-select: none;\\n}\\n\\n.pvtFilterBox h4 {\\n  margin: 15px;\\n}\\n.pvtFilterBox p {\\n  margin: 10px auto;\\n}\\n.pvtFilterBox button {\\n  color: #2a3f5f;\\n}\\n.pvtFilterBox input[type='text'] {\\n  width: 230px;\\n  color: #2a3f5f;\\n  margin-bottom: 5px;\\n}\\n\\n.pvtCheckContainer {\\n  text-align: left;\\n  font-size: 14px;\\n  white-space: nowrap;\\n  overflow-y: scroll;\\n  width: 100%;\\n  max-height: 30vh;\\n  border-top: 1px solid #dfe8f3;\\n}\\n\\n.pvtCheckContainer p {\\n  margin: 0;\\n  margin-bottom: 1px;\\n  padding: 3px;\\n  cursor: default;\\n}\\n\\n.pvtCheckContainer p.selected {\\n  background: #ebf0f8;\\n}\\n\\n.pvtOnly {\\n  display: none;\\n  width: 35px;\\n  float: left;\\n  font-size: 12px;\\n  padding-left: 5px;\\n  cursor: pointer;\\n}\\n\\n.pvtOnlySpacer {\\n  display: block;\\n  width: 35px;\\n  float: left;\\n}\\n\\n.pvtCheckContainer p:hover .pvtOnly {\\n  display: block;\\n}\\n.pvtCheckContainer p:hover .pvtOnlySpacer {\\n  display: none;\\n}\\n\\n.pvtRendererArea {\\n  padding: 5px;\\n}\\n\\n.toggle-wrapper {\\n  white-space: nowrap;\\n}\\n\\n.toggle-wrapper > .toggle-val {\\n  white-space: normal;\\n}\\n\\n.toggle {\\n  padding-right: 4px;\\n  cursor: pointer;\\n}\\n\\n.hoverable:hover {\\n  background-color: #eceef2;\\n  cursor: pointer;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8hLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3JlYWN0LXBpdm90dGFibGUvcGl2b3R0YWJsZS5jc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3JlYWN0LXBpdm90dGFibGUvcGl2b3R0YWJsZS5jc3M/YzA5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIucHZ0VWkge1xcbiAgY29sb3I6ICMyYTNmNWY7XFxuICBmb250LWZhbWlseTogJ0ludGVyJywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbi5wdnRVaSBzZWxlY3Qge1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuLnB2dFVpIHRkLnB2dE91dHB1dCB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcbn1cXG5cXG50YWJsZS5wdnRUYWJsZSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBmb250LXNpemU6IDEycHg7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgbWFyZ2luLXRvcDogM3B4O1xcbiAgbWFyZ2luLWxlZnQ6IDNweDtcXG4gIGJvcmRlci1jb2xsYXBzZTogc2VwYXJhdGU7XFxuICBmb250LWZhbWlseTogJ0ludGVyJywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gIGxpbmUtaGVpZ2h0OiAxLjQ7XFxufVxcblxcbnRhYmxlIHRoZWFkIHtcXG4gIHBvc2l0aW9uOiBzdGlja3k7XFxuICB0b3A6IDA7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIHRoZWFkIHRyIHRoLFxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyIHRoIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2UwZTBlMDtcXG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2UwZTBlMDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyLnB2dFJvd1RvdGFsc3tcXG4gIHBvc2l0aW9uOiBzdGlja3k7XFxuICBib3R0b206IDA7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIHRoZWFkIHRyOmxhc3QtY2hpbGQgdGgsXFxudGFibGUucHZ0VGFibGUgdGhlYWQgdHI6Zmlyc3QtY2hpbGQgdGgucHZ0VG90YWxMYWJlbCxcXG50YWJsZS5wdnRUYWJsZSB0aGVhZCB0cjpudGgtbGFzdC1jaGlsZCgyKSB0aC5wdnRDb2xMYWJlbCxcXG50YWJsZS5wdnRUYWJsZSB0aGVhZCB0aC5wdnRTdWJ0b3RhbExhYmVsLFxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyOmxhc3QtY2hpbGQgdGgsXFxudGFibGUucHZ0VGFibGUgdGJvZHkgdHI6bGFzdC1jaGlsZCB0ZCB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2UwZTBlMDtcXG59XFxuXFxudGFibGUucHZ0VGFibGUgdGhlYWQgdHI6bGFzdC1jaGlsZDpub3QoOm9ubHktY2hpbGQpIHRoLnB2dEF4aXNMYWJlbCB+IHRoLnB2dENvbExhYmVsLFxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyOmZpcnN0LWNoaWxkIHRoLFxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyOmZpcnN0LWNoaWxkIHRke1xcbiAgYm9yZGVyLXRvcDogbm9uZTtcXG59XFxuXFxudGFibGUucHZ0VGFibGUgdGJvZHkgdHIgdGQ6bGFzdC1jaGlsZCxcXG50YWJsZS5wdnRUYWJsZSB0aGVhZCB0ciB0aDpsYXN0LWNoaWxkOm5vdCgucHZ0U3VidG90YWxMYWJlbCkge1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2UwZTBlMDtcXG59XFxuXFxudGFibGUucHZ0VGFibGUgdGhlYWQgdHI6bGFzdC1jaGlsZDpub3QoOm9ubHktY2hpbGQpIHRoLnB2dEF4aXNMYWJlbCArIC5wdnRUb3RhbExhYmVsIHtcXG4gIGJvcmRlci1yaWdodDogbm9uZTtcXG59XFxuXFxudGFibGUucHZ0VGFibGUgdHIgdGguYWN0aXZlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNkOWRiZTQ7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIC5wdnRUb3RhbExhYmVsIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIC5wdnRTdWJ0b3RhbExhYmVsIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5cXG50YWJsZS5wdnRUYWJsZSB0Ym9keSB0ciB0ZCB7XFxuICBjb2xvcjogIzJhM2Y1ZjtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2UwZTBlMDtcXG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2UwZTBlMDtcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxuXFxudGFibGUucHZ0VGFibGUgdGJvZHkgdHIgdGgucHZ0Um93TGFiZWwge1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG4ucHZ0VG90YWwsXFxuLnB2dEdyYW5kVG90YWwge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyIHRkLnB2dFJvd1RvdGFsIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcblxcbi5wdnRSb3dPcmRlcixcXG4ucHZ0Q29sT3JkZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgd2lkdGg6IDE1cHg7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmUgIWltcG9ydGFudDtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG4ucHZ0QXhpc0NvbnRhaW5lcixcXG4ucHZ0VmFscyB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjYTJiMWM2O1xcbiAgYmFja2dyb3VuZDogI2YyZjVmYTtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIG1pbi13aWR0aDogMjBweDtcXG4gIG1pbi1oZWlnaHQ6IDIwcHg7XFxufVxcblxcbi5wdnRSZW5kZXJlcnMge1xcbiAgcGFkZGluZy1sZWZ0OiA1cHg7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuLnB2dERyb3Bkb3duIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgbWFyZ2luOiAzcHg7XFxufVxcblxcbi5wdnREcm9wZG93bkljb24ge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgY29sb3I6ICNhMmIxYzY7XFxufVxcbi5wdnREcm9wZG93bkN1cnJlbnQge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNhMmIxYzY7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogMjEwcHg7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxufVxcblxcbi5wdnREcm9wZG93bkN1cnJlbnRPcGVuIHtcXG4gIGJvcmRlci1yYWRpdXM6IDRweCA0cHggMCAwO1xcbn1cXG5cXG4ucHZ0RHJvcGRvd25NZW51IHtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgYm9yZGVyLXJhZGl1czogMCAwIDRweCA0cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjYTJiMWM2O1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNkZmU4ZjM7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5cXG4ucHZ0RHJvcGRvd25WYWx1ZSB7XFxuICBwYWRkaW5nOiAycHggNXB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuLnB2dERyb3Bkb3duQWN0aXZlVmFsdWUge1xcbiAgYmFja2dyb3VuZDogI2ViZjBmODtcXG59XFxuXFxuLnB2dFZhbHMge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICBwYWRkaW5nLWJvdHRvbTogMTJweDtcXG59XFxuXFxuLnB2dFJvd3Mge1xcbiAgaGVpZ2h0OiAzNXB4O1xcbn1cXG5cXG4ucHZ0VHJpYW5nbGUge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY29sb3I6ICM1MDY3ODQ7XFxufVxcblxcbi5wdnRIb3Jpekxpc3QgbGkge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4ucHZ0VmVydExpc3Qge1xcbiAgdmVydGljYWwtYWxpZ246IHRvcDtcXG59XFxuXFxuLnB2dEZpbHRlcmVkQXR0cmlidXRlIHtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG59XFxuXFxuLnNvcnRhYmxlLWNob3NlbiAucHZ0RmlsdGVyQm94IHtcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuLnB2dENsb3NlWCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogNXB4O1xcbiAgdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuLnB2dERyYWdIYW5kbGUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogNXB4O1xcbiAgdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBjdXJzb3I6IG1vdmU7XFxuICBjb2xvcjogI2EyYjFjNjtcXG59XFxuXFxuLnB2dEJ1dHRvbiB7XFxuICBjb2xvcjogIzUwNjc4NDtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIHBhZGRpbmc6IDNweCA2cHg7XFxuICBiYWNrZ3JvdW5kOiAjZjJmNWZhO1xcbiAgYm9yZGVyOiAxcHggc29saWQ7XFxuICBib3JkZXItY29sb3I6ICNjOGQ0ZTM7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBtYXJnaW46IDNweDtcXG4gIHRyYW5zaXRpb246IDAuMzRzIGFsbCBjdWJpYy1iZXppZXIoMC4xOSwgMSwgMC4yMiwgMSk7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuLnB2dEJ1dHRvbjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiAjZTJlOGYwO1xcbiAgYm9yZGVyLWNvbG9yOiAjYTJiMWM2O1xcbn1cXG5cXG4ucHZ0QnV0dG9uOmFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kOiAjZDFkYWU2O1xcbn1cXG5cXG4ucHZ0RmlsdGVyQm94IGlucHV0IHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjOGQ0ZTM7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBjb2xvcjogIzUwNjc4NDtcXG4gIHBhZGRpbmc6IDAgM3B4O1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG5cXG4ucHZ0RmlsdGVyQm94IGlucHV0OmZvY3VzIHtcXG4gIGJvcmRlci1jb2xvcjogIzExOWRmZjtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcblxcbi5wdnRGaWx0ZXJCb3gge1xcbiAgei1pbmRleDogMTAwO1xcbiAgd2lkdGg6IDMwMHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzUwNjc4NDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIG1pbi1oZWlnaHQ6IDEwMHB4O1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcblxcbi5wdnRGaWx0ZXJCb3ggaDQge1xcbiAgbWFyZ2luOiAxNXB4O1xcbn1cXG4ucHZ0RmlsdGVyQm94IHAge1xcbiAgbWFyZ2luOiAxMHB4IGF1dG87XFxufVxcbi5wdnRGaWx0ZXJCb3ggYnV0dG9uIHtcXG4gIGNvbG9yOiAjMmEzZjVmO1xcbn1cXG4ucHZ0RmlsdGVyQm94IGlucHV0W3R5cGU9J3RleHQnXSB7XFxuICB3aWR0aDogMjMwcHg7XFxuICBjb2xvcjogIzJhM2Y1ZjtcXG4gIG1hcmdpbi1ib3R0b206IDVweDtcXG59XFxuXFxuLnB2dENoZWNrQ29udGFpbmVyIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXgtaGVpZ2h0OiAzMHZoO1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNkZmU4ZjM7XFxufVxcblxcbi5wdnRDaGVja0NvbnRhaW5lciBwIHtcXG4gIG1hcmdpbjogMDtcXG4gIG1hcmdpbi1ib3R0b206IDFweDtcXG4gIHBhZGRpbmc6IDNweDtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuXFxuLnB2dENoZWNrQ29udGFpbmVyIHAuc2VsZWN0ZWQge1xcbiAgYmFja2dyb3VuZDogI2ViZjBmODtcXG59XFxuXFxuLnB2dE9ubHkge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHdpZHRoOiAzNXB4O1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBwYWRkaW5nLWxlZnQ6IDVweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLnB2dE9ubHlTcGFjZXIge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMzVweDtcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4ucHZ0Q2hlY2tDb250YWluZXIgcDpob3ZlciAucHZ0T25seSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLnB2dENoZWNrQ29udGFpbmVyIHA6aG92ZXIgLnB2dE9ubHlTcGFjZXIge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLnB2dFJlbmRlcmVyQXJlYSB7XFxuICBwYWRkaW5nOiA1cHg7XFxufVxcblxcbi50b2dnbGUtd3JhcHBlciB7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cXG4udG9nZ2xlLXdyYXBwZXIgPiAudG9nZ2xlLXZhbCB7XFxuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcbn1cXG5cXG4udG9nZ2xlIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDRweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmhvdmVyYWJsZTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWNlZWYyO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcC9zdXBlcnNldC1mcm9udGVuZC9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3BsdWdpbi1jaGFydC1waXZvdC10YWJsZS9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL3JlYWN0LXBpdm90dGFibGUvcGl2b3R0YWJsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxlQUFlO0VBQ2YsbURBQW1EO0VBQ25ELDBCQUEwQjtDQUMzQjtBQUNEO0VBQ0Usa0JBQWtCO0VBQ2xCLDBCQUEwQjtFQUMxQix1QkFBdUI7RUFDdkIseUJBQXlCO0VBQ3pCLHNCQUFzQjtDQUN2Qjs7QUFFRDtFQUNFLG9CQUFvQjtDQUNyQjs7QUFFRDtFQUNFLG1CQUFtQjtFQUNuQixnQkFBZ0I7RUFDaEIsaUJBQWlCO0VBQ2pCLGdCQUFnQjtFQUNoQixpQkFBaUI7RUFDakIsMEJBQTBCO0VBQzFCLG1EQUFtRDtFQUNuRCxpQkFBaUI7Q0FDbEI7O0FBRUQ7RUFDRSxpQkFBaUI7RUFDakIsT0FBTztDQUNSOztBQUVEOztFQUVFLHVCQUF1QjtFQUN2Qiw4QkFBOEI7RUFDOUIsK0JBQStCO0VBQy9CLGdCQUFnQjtFQUNoQixhQUFhO0VBQ2Isb0JBQW9CO0NBQ3JCOztBQUVEO0VBQ0UsaUJBQWlCO0VBQ2pCLFVBQVU7Q0FDWDs7QUFFRDs7Ozs7O0VBTUUsaUNBQWlDO0NBQ2xDOztBQUVEOzs7RUFHRSxpQkFBaUI7Q0FDbEI7O0FBRUQ7O0VBRUUsZ0NBQWdDO0NBQ2pDOztBQUVEO0VBQ0UsbUJBQW1CO0NBQ3BCOztBQUVEO0VBQ0UsMEJBQTBCO0NBQzNCOztBQUVEO0VBQ0Usa0JBQWtCO0VBQ2xCLGtCQUFrQjtDQUNuQjs7QUFFRDtFQUNFLGtCQUFrQjtDQUNuQjs7QUFFRDtFQUNFLGVBQWU7RUFDZixhQUFhO0VBQ2IsdUJBQXVCO0VBQ3ZCLDhCQUE4QjtFQUM5QiwrQkFBK0I7RUFDL0Isb0JBQW9CO0VBQ3BCLGtCQUFrQjtDQUNuQjs7QUFFRDtFQUNFLHlCQUF5QjtDQUMxQjs7QUFFRDs7RUFFRSxrQkFBa0I7Q0FDbkI7O0FBRUQ7RUFDRSx1QkFBdUI7Q0FDeEI7O0FBRUQ7O0VBRUUsZ0JBQWdCO0VBQ2hCLFlBQVk7RUFDWixpQkFBaUI7RUFDakIsc0JBQXNCO0VBQ3RCLGtCQUFrQjtFQUNsQixpQ0FBaUM7RUFDakMsMEJBQTBCO0VBQzFCLHVCQUF1QjtFQUN2Qix5QkFBeUI7RUFDekIsc0JBQXNCO0NBQ3ZCOztBQUVEOztFQUVFLDBCQUEwQjtFQUMxQixvQkFBb0I7RUFDcEIsYUFBYTtFQUNiLGdCQUFnQjtFQUNoQixpQkFBaUI7Q0FDbEI7O0FBRUQ7RUFDRSxrQkFBa0I7RUFDbEIsa0JBQWtCO0NBQ25COztBQUVEO0VBQ0Usc0JBQXNCO0VBQ3RCLG1CQUFtQjtFQUNuQiwwQkFBMEI7RUFDMUIsdUJBQXVCO0VBQ3ZCLHlCQUF5QjtFQUN6QixzQkFBc0I7RUFDdEIsWUFBWTtDQUNiOztBQUVEO0VBQ0UsYUFBYTtFQUNiLGVBQWU7Q0FDaEI7QUFDRDtFQUNFLGlCQUFpQjtFQUNqQiwwQkFBMEI7RUFDMUIsbUJBQW1CO0VBQ25CLHNCQUFzQjtFQUN0QixtQkFBbUI7RUFDbkIsYUFBYTtFQUNiLHVCQUF1QjtFQUN2QixrQkFBa0I7Q0FDbkI7O0FBRUQ7RUFDRSwyQkFBMkI7Q0FDNUI7O0FBRUQ7RUFDRSxrQkFBa0I7RUFDbEIsbUJBQW1CO0VBQ25CLFlBQVk7RUFDWixpQkFBaUI7RUFDakIsMkJBQTJCO0VBQzNCLDBCQUEwQjtFQUMxQiw4QkFBOEI7RUFDOUIsdUJBQXVCO0NBQ3hCOztBQUVEO0VBQ0UsaUJBQWlCO0VBQ2pCLGdCQUFnQjtFQUNoQixpQkFBaUI7Q0FDbEI7QUFDRDtFQUNFLG9CQUFvQjtDQUNyQjs7QUFFRDtFQUNFLG1CQUFtQjtFQUNuQixvQkFBb0I7RUFDcEIsb0JBQW9CO0VBQ3BCLHFCQUFxQjtDQUN0Qjs7QUFFRDtFQUNFLGFBQWE7Q0FDZDs7QUFFRDtFQUNFLGdCQUFnQjtFQUNoQixlQUFlO0NBQ2hCOztBQUVEO0VBQ0Usc0JBQXNCO0NBQ3ZCO0FBQ0Q7RUFDRSxvQkFBb0I7Q0FDckI7O0FBRUQ7RUFDRSxtQkFBbUI7Q0FDcEI7O0FBRUQ7RUFDRSx5QkFBeUI7Q0FDMUI7O0FBRUQ7RUFDRSxtQkFBbUI7RUFDbkIsV0FBVztFQUNYLFNBQVM7RUFDVCxnQkFBZ0I7RUFDaEIsZ0JBQWdCO0VBQ2hCLGlDQUFpQztDQUNsQzs7QUFFRDtFQUNFLG1CQUFtQjtFQUNuQixVQUFVO0VBQ1YsU0FBUztFQUNULGdCQUFnQjtFQUNoQixhQUFhO0VBQ2IsZUFBZTtDQUNoQjs7QUFFRDtFQUNFLGVBQWU7RUFDZixtQkFBbUI7RUFDbkIsaUJBQWlCO0VBQ2pCLG9CQUFvQjtFQUNwQixrQkFBa0I7RUFDbEIsc0JBQXNCO0VBQ3RCLGdCQUFnQjtFQUNoQixZQUFZO0VBQ1oscURBQXFEO0VBQ3JELGlDQUFpQztDQUNsQzs7QUFFRDtFQUNFLG9CQUFvQjtFQUNwQixzQkFBc0I7Q0FDdkI7O0FBRUQ7RUFDRSxvQkFBb0I7Q0FDckI7O0FBRUQ7RUFDRSwwQkFBMEI7RUFDMUIsbUJBQW1CO0VBQ25CLGVBQWU7RUFDZixlQUFlO0VBQ2YsZ0JBQWdCO0NBQ2pCOztBQUVEO0VBQ0Usc0JBQXNCO0VBQ3RCLGNBQWM7Q0FDZjs7QUFFRDtFQUNFLGFBQWE7RUFDYixhQUFhO0VBQ2IsMEJBQTBCO0VBQzFCLHVCQUF1QjtFQUN2QixtQkFBbUI7RUFDbkIsbUJBQW1CO0VBQ25CLGtCQUFrQjtFQUNsQixrQkFBa0I7RUFDbEIsMEJBQTBCO0VBQzFCLHVCQUF1QjtFQUN2Qix5QkFBeUI7RUFDekIsc0JBQXNCO0NBQ3ZCOztBQUVEO0VBQ0UsYUFBYTtDQUNkO0FBQ0Q7RUFDRSxrQkFBa0I7Q0FDbkI7QUFDRDtFQUNFLGVBQWU7Q0FDaEI7QUFDRDtFQUNFLGFBQWE7RUFDYixlQUFlO0VBQ2YsbUJBQW1CO0NBQ3BCOztBQUVEO0VBQ0UsaUJBQWlCO0VBQ2pCLGdCQUFnQjtFQUNoQixvQkFBb0I7RUFDcEIsbUJBQW1CO0VBQ25CLFlBQVk7RUFDWixpQkFBaUI7RUFDakIsOEJBQThCO0NBQy9COztBQUVEO0VBQ0UsVUFBVTtFQUNWLG1CQUFtQjtFQUNuQixhQUFhO0VBQ2IsZ0JBQWdCO0NBQ2pCOztBQUVEO0VBQ0Usb0JBQW9CO0NBQ3JCOztBQUVEO0VBQ0UsY0FBYztFQUNkLFlBQVk7RUFDWixZQUFZO0VBQ1osZ0JBQWdCO0VBQ2hCLGtCQUFrQjtFQUNsQixnQkFBZ0I7Q0FDakI7O0FBRUQ7RUFDRSxlQUFlO0VBQ2YsWUFBWTtFQUNaLFlBQVk7Q0FDYjs7QUFFRDtFQUNFLGVBQWU7Q0FDaEI7QUFDRDtFQUNFLGNBQWM7Q0FDZjs7QUFFRDtFQUNFLGFBQWE7Q0FDZDs7QUFFRDtFQUNFLG9CQUFvQjtDQUNyQjs7QUFFRDtFQUNFLG9CQUFvQjtDQUNyQjs7QUFFRDtFQUNFLG1CQUFtQjtFQUNuQixnQkFBZ0I7Q0FDakI7O0FBRUQ7RUFDRSwwQkFBMEI7RUFDMUIsZ0JBQWdCO0NBQ2pCXCIsXCJmaWxlXCI6XCJwaXZvdHRhYmxlLmNzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCIucHZ0VWkge1xcbiAgY29sb3I6ICMyYTNmNWY7XFxuICBmb250LWZhbWlseTogJ0ludGVyJywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbi5wdnRVaSBzZWxlY3Qge1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuLnB2dFVpIHRkLnB2dE91dHB1dCB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcbn1cXG5cXG50YWJsZS5wdnRUYWJsZSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBmb250LXNpemU6IDEycHg7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgbWFyZ2luLXRvcDogM3B4O1xcbiAgbWFyZ2luLWxlZnQ6IDNweDtcXG4gIGJvcmRlci1jb2xsYXBzZTogc2VwYXJhdGU7XFxuICBmb250LWZhbWlseTogJ0ludGVyJywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gIGxpbmUtaGVpZ2h0OiAxLjQ7XFxufVxcblxcbnRhYmxlIHRoZWFkIHtcXG4gIHBvc2l0aW9uOiBzdGlja3k7XFxuICB0b3A6IDA7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIHRoZWFkIHRyIHRoLFxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyIHRoIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2UwZTBlMDtcXG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2UwZTBlMDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyLnB2dFJvd1RvdGFsc3tcXG4gIHBvc2l0aW9uOiBzdGlja3k7XFxuICBib3R0b206IDA7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIHRoZWFkIHRyOmxhc3QtY2hpbGQgdGgsXFxudGFibGUucHZ0VGFibGUgdGhlYWQgdHI6Zmlyc3QtY2hpbGQgdGgucHZ0VG90YWxMYWJlbCxcXG50YWJsZS5wdnRUYWJsZSB0aGVhZCB0cjpudGgtbGFzdC1jaGlsZCgyKSB0aC5wdnRDb2xMYWJlbCxcXG50YWJsZS5wdnRUYWJsZSB0aGVhZCB0aC5wdnRTdWJ0b3RhbExhYmVsLFxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyOmxhc3QtY2hpbGQgdGgsXFxudGFibGUucHZ0VGFibGUgdGJvZHkgdHI6bGFzdC1jaGlsZCB0ZCB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2UwZTBlMDtcXG59XFxuXFxudGFibGUucHZ0VGFibGUgdGhlYWQgdHI6bGFzdC1jaGlsZDpub3QoOm9ubHktY2hpbGQpIHRoLnB2dEF4aXNMYWJlbCB+IHRoLnB2dENvbExhYmVsLFxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyOmZpcnN0LWNoaWxkIHRoLFxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyOmZpcnN0LWNoaWxkIHRke1xcbiAgYm9yZGVyLXRvcDogbm9uZTtcXG59XFxuXFxudGFibGUucHZ0VGFibGUgdGJvZHkgdHIgdGQ6bGFzdC1jaGlsZCxcXG50YWJsZS5wdnRUYWJsZSB0aGVhZCB0ciB0aDpsYXN0LWNoaWxkOm5vdCgucHZ0U3VidG90YWxMYWJlbCkge1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2UwZTBlMDtcXG59XFxuXFxudGFibGUucHZ0VGFibGUgdGhlYWQgdHI6bGFzdC1jaGlsZDpub3QoOm9ubHktY2hpbGQpIHRoLnB2dEF4aXNMYWJlbCArIC5wdnRUb3RhbExhYmVsIHtcXG4gIGJvcmRlci1yaWdodDogbm9uZTtcXG59XFxuXFxudGFibGUucHZ0VGFibGUgdHIgdGguYWN0aXZlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNkOWRiZTQ7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIC5wdnRUb3RhbExhYmVsIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIC5wdnRTdWJ0b3RhbExhYmVsIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5cXG50YWJsZS5wdnRUYWJsZSB0Ym9keSB0ciB0ZCB7XFxuICBjb2xvcjogIzJhM2Y1ZjtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2UwZTBlMDtcXG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2UwZTBlMDtcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxuXFxudGFibGUucHZ0VGFibGUgdGJvZHkgdHIgdGgucHZ0Um93TGFiZWwge1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG4ucHZ0VG90YWwsXFxuLnB2dEdyYW5kVG90YWwge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbnRhYmxlLnB2dFRhYmxlIHRib2R5IHRyIHRkLnB2dFJvd1RvdGFsIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcblxcbi5wdnRSb3dPcmRlcixcXG4ucHZ0Q29sT3JkZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgd2lkdGg6IDE1cHg7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmUgIWltcG9ydGFudDtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG4ucHZ0QXhpc0NvbnRhaW5lcixcXG4ucHZ0VmFscyB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjYTJiMWM2O1xcbiAgYmFja2dyb3VuZDogI2YyZjVmYTtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIG1pbi13aWR0aDogMjBweDtcXG4gIG1pbi1oZWlnaHQ6IDIwcHg7XFxufVxcblxcbi5wdnRSZW5kZXJlcnMge1xcbiAgcGFkZGluZy1sZWZ0OiA1cHg7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuLnB2dERyb3Bkb3duIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgbWFyZ2luOiAzcHg7XFxufVxcblxcbi5wdnREcm9wZG93bkljb24ge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgY29sb3I6ICNhMmIxYzY7XFxufVxcbi5wdnREcm9wZG93bkN1cnJlbnQge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNhMmIxYzY7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogMjEwcHg7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYmFja2dyb3VuZDogd2hpdGU7XFxufVxcblxcbi5wdnREcm9wZG93bkN1cnJlbnRPcGVuIHtcXG4gIGJvcmRlci1yYWRpdXM6IDRweCA0cHggMCAwO1xcbn1cXG5cXG4ucHZ0RHJvcGRvd25NZW51IHtcXG4gIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgYm9yZGVyLXJhZGl1czogMCAwIDRweCA0cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjYTJiMWM2O1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNkZmU4ZjM7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5cXG4ucHZ0RHJvcGRvd25WYWx1ZSB7XFxuICBwYWRkaW5nOiAycHggNXB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuLnB2dERyb3Bkb3duQWN0aXZlVmFsdWUge1xcbiAgYmFja2dyb3VuZDogI2ViZjBmODtcXG59XFxuXFxuLnB2dFZhbHMge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICBwYWRkaW5nLWJvdHRvbTogMTJweDtcXG59XFxuXFxuLnB2dFJvd3Mge1xcbiAgaGVpZ2h0OiAzNXB4O1xcbn1cXG5cXG4ucHZ0VHJpYW5nbGUge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY29sb3I6ICM1MDY3ODQ7XFxufVxcblxcbi5wdnRIb3Jpekxpc3QgbGkge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4ucHZ0VmVydExpc3Qge1xcbiAgdmVydGljYWwtYWxpZ246IHRvcDtcXG59XFxuXFxuLnB2dEZpbHRlcmVkQXR0cmlidXRlIHtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG59XFxuXFxuLnNvcnRhYmxlLWNob3NlbiAucHZ0RmlsdGVyQm94IHtcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuLnB2dENsb3NlWCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogNXB4O1xcbiAgdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuLnB2dERyYWdIYW5kbGUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogNXB4O1xcbiAgdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDE4cHg7XFxuICBjdXJzb3I6IG1vdmU7XFxuICBjb2xvcjogI2EyYjFjNjtcXG59XFxuXFxuLnB2dEJ1dHRvbiB7XFxuICBjb2xvcjogIzUwNjc4NDtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIHBhZGRpbmc6IDNweCA2cHg7XFxuICBiYWNrZ3JvdW5kOiAjZjJmNWZhO1xcbiAgYm9yZGVyOiAxcHggc29saWQ7XFxuICBib3JkZXItY29sb3I6ICNjOGQ0ZTM7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBtYXJnaW46IDNweDtcXG4gIHRyYW5zaXRpb246IDAuMzRzIGFsbCBjdWJpYy1iZXppZXIoMC4xOSwgMSwgMC4yMiwgMSk7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuLnB2dEJ1dHRvbjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiAjZTJlOGYwO1xcbiAgYm9yZGVyLWNvbG9yOiAjYTJiMWM2O1xcbn1cXG5cXG4ucHZ0QnV0dG9uOmFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kOiAjZDFkYWU2O1xcbn1cXG5cXG4ucHZ0RmlsdGVyQm94IGlucHV0IHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjOGQ0ZTM7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBjb2xvcjogIzUwNjc4NDtcXG4gIHBhZGRpbmc6IDAgM3B4O1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG5cXG4ucHZ0RmlsdGVyQm94IGlucHV0OmZvY3VzIHtcXG4gIGJvcmRlci1jb2xvcjogIzExOWRmZjtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcblxcbi5wdnRGaWx0ZXJCb3gge1xcbiAgei1pbmRleDogMTAwO1xcbiAgd2lkdGg6IDMwMHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzUwNjc4NDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIG1pbi1oZWlnaHQ6IDEwMHB4O1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcblxcbi5wdnRGaWx0ZXJCb3ggaDQge1xcbiAgbWFyZ2luOiAxNXB4O1xcbn1cXG4ucHZ0RmlsdGVyQm94IHAge1xcbiAgbWFyZ2luOiAxMHB4IGF1dG87XFxufVxcbi5wdnRGaWx0ZXJCb3ggYnV0dG9uIHtcXG4gIGNvbG9yOiAjMmEzZjVmO1xcbn1cXG4ucHZ0RmlsdGVyQm94IGlucHV0W3R5cGU9J3RleHQnXSB7XFxuICB3aWR0aDogMjMwcHg7XFxuICBjb2xvcjogIzJhM2Y1ZjtcXG4gIG1hcmdpbi1ib3R0b206IDVweDtcXG59XFxuXFxuLnB2dENoZWNrQ29udGFpbmVyIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXgtaGVpZ2h0OiAzMHZoO1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNkZmU4ZjM7XFxufVxcblxcbi5wdnRDaGVja0NvbnRhaW5lciBwIHtcXG4gIG1hcmdpbjogMDtcXG4gIG1hcmdpbi1ib3R0b206IDFweDtcXG4gIHBhZGRpbmc6IDNweDtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuXFxuLnB2dENoZWNrQ29udGFpbmVyIHAuc2VsZWN0ZWQge1xcbiAgYmFja2dyb3VuZDogI2ViZjBmODtcXG59XFxuXFxuLnB2dE9ubHkge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHdpZHRoOiAzNXB4O1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBwYWRkaW5nLWxlZnQ6IDVweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLnB2dE9ubHlTcGFjZXIge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMzVweDtcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4ucHZ0Q2hlY2tDb250YWluZXIgcDpob3ZlciAucHZ0T25seSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLnB2dENoZWNrQ29udGFpbmVyIHA6aG92ZXIgLnB2dE9ubHlTcGFjZXIge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLnB2dFJlbmRlcmVyQXJlYSB7XFxuICBwYWRkaW5nOiA1cHg7XFxufVxcblxcbi50b2dnbGUtd3JhcHBlciB7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cXG4udG9nZ2xlLXdyYXBwZXIgPiAudG9nZ2xlLXZhbCB7XFxuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcbn1cXG5cXG4udG9nZ2xlIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDRweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmhvdmVyYWJsZTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWNlZWYyO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?!./node_modules/@superset-ui/plugin-chart-pivot-table/node_modules/@superset-ui/react-pivottable/pivottable.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ })

}]);